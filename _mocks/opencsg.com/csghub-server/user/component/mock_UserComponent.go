// Code generated by mockery v2.53.5. DO NOT EDIT.

package component

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	types "opencsg.com/csghub-server/common/types"
)

// MockUserComponent is an autogenerated mock type for the UserComponent type
type MockUserComponent struct {
	mock.Mock
}

type MockUserComponent_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserComponent) EXPECT() *MockUserComponent_Expecter {
	return &MockUserComponent_Expecter{mock: &_m.Mock}
}

// CanAdmin provides a mock function with given fields: ctx, username
func (_m *MockUserComponent) CanAdmin(ctx context.Context, username string) (bool, error) {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for CanAdmin")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, username)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_CanAdmin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CanAdmin'
type MockUserComponent_CanAdmin_Call struct {
	*mock.Call
}

// CanAdmin is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *MockUserComponent_Expecter) CanAdmin(ctx interface{}, username interface{}) *MockUserComponent_CanAdmin_Call {
	return &MockUserComponent_CanAdmin_Call{Call: _e.mock.On("CanAdmin", ctx, username)}
}

func (_c *MockUserComponent_CanAdmin_Call) Run(run func(ctx context.Context, username string)) *MockUserComponent_CanAdmin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUserComponent_CanAdmin_Call) Return(_a0 bool, _a1 error) *MockUserComponent_CanAdmin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserComponent_CanAdmin_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockUserComponent_CanAdmin_Call {
	_c.Call.Return(run)
	return _c
}

// CheckIfUserHasBills provides a mock function with given fields: ctx, userName
func (_m *MockUserComponent) CheckIfUserHasBills(ctx context.Context, userName string) (bool, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for CheckIfUserHasBills")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, userName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_CheckIfUserHasBills_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckIfUserHasBills'
type MockUserComponent_CheckIfUserHasBills_Call struct {
	*mock.Call
}

// CheckIfUserHasBills is a helper method to define mock.On call
//   - ctx context.Context
//   - userName string
func (_e *MockUserComponent_Expecter) CheckIfUserHasBills(ctx interface{}, userName interface{}) *MockUserComponent_CheckIfUserHasBills_Call {
	return &MockUserComponent_CheckIfUserHasBills_Call{Call: _e.mock.On("CheckIfUserHasBills", ctx, userName)}
}

func (_c *MockUserComponent_CheckIfUserHasBills_Call) Run(run func(ctx context.Context, userName string)) *MockUserComponent_CheckIfUserHasBills_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUserComponent_CheckIfUserHasBills_Call) Return(_a0 bool, _a1 error) *MockUserComponent_CheckIfUserHasBills_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserComponent_CheckIfUserHasBills_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockUserComponent_CheckIfUserHasBills_Call {
	_c.Call.Return(run)
	return _c
}

// CheckIfUserHasOrgs provides a mock function with given fields: ctx, userName
func (_m *MockUserComponent) CheckIfUserHasOrgs(ctx context.Context, userName string) (bool, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for CheckIfUserHasOrgs")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, userName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_CheckIfUserHasOrgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckIfUserHasOrgs'
type MockUserComponent_CheckIfUserHasOrgs_Call struct {
	*mock.Call
}

// CheckIfUserHasOrgs is a helper method to define mock.On call
//   - ctx context.Context
//   - userName string
func (_e *MockUserComponent_Expecter) CheckIfUserHasOrgs(ctx interface{}, userName interface{}) *MockUserComponent_CheckIfUserHasOrgs_Call {
	return &MockUserComponent_CheckIfUserHasOrgs_Call{Call: _e.mock.On("CheckIfUserHasOrgs", ctx, userName)}
}

func (_c *MockUserComponent_CheckIfUserHasOrgs_Call) Run(run func(ctx context.Context, userName string)) *MockUserComponent_CheckIfUserHasOrgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUserComponent_CheckIfUserHasOrgs_Call) Return(_a0 bool, _a1 error) *MockUserComponent_CheckIfUserHasOrgs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserComponent_CheckIfUserHasOrgs_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockUserComponent_CheckIfUserHasOrgs_Call {
	_c.Call.Return(run)
	return _c
}

// CheckIfUserHasRunningOrBuildingDeployments provides a mock function with given fields: ctx, userName
func (_m *MockUserComponent) CheckIfUserHasRunningOrBuildingDeployments(ctx context.Context, userName string) (bool, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for CheckIfUserHasRunningOrBuildingDeployments")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, userName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckIfUserHasRunningOrBuildingDeployments'
type MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call struct {
	*mock.Call
}

// CheckIfUserHasRunningOrBuildingDeployments is a helper method to define mock.On call
//   - ctx context.Context
//   - userName string
func (_e *MockUserComponent_Expecter) CheckIfUserHasRunningOrBuildingDeployments(ctx interface{}, userName interface{}) *MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call {
	return &MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call{Call: _e.mock.On("CheckIfUserHasRunningOrBuildingDeployments", ctx, userName)}
}

func (_c *MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call) Run(run func(ctx context.Context, userName string)) *MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call) Return(_a0 bool, _a1 error) *MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockUserComponent_CheckIfUserHasRunningOrBuildingDeployments_Call {
	_c.Call.Return(run)
	return _c
}

// CheckOperatorAndUser provides a mock function with given fields: ctx, operator, username
func (_m *MockUserComponent) CheckOperatorAndUser(ctx context.Context, operator string, username string) (bool, error) {
	ret := _m.Called(ctx, operator, username)

	if len(ret) == 0 {
		panic("no return value specified for CheckOperatorAndUser")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, operator, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, operator, username)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, operator, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_CheckOperatorAndUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckOperatorAndUser'
type MockUserComponent_CheckOperatorAndUser_Call struct {
	*mock.Call
}

// CheckOperatorAndUser is a helper method to define mock.On call
//   - ctx context.Context
//   - operator string
//   - username string
func (_e *MockUserComponent_Expecter) CheckOperatorAndUser(ctx interface{}, operator interface{}, username interface{}) *MockUserComponent_CheckOperatorAndUser_Call {
	return &MockUserComponent_CheckOperatorAndUser_Call{Call: _e.mock.On("CheckOperatorAndUser", ctx, operator, username)}
}

func (_c *MockUserComponent_CheckOperatorAndUser_Call) Run(run func(ctx context.Context, operator string, username string)) *MockUserComponent_CheckOperatorAndUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUserComponent_CheckOperatorAndUser_Call) Return(_a0 bool, _a1 error) *MockUserComponent_CheckOperatorAndUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserComponent_CheckOperatorAndUser_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockUserComponent_CheckOperatorAndUser_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, operator, username
func (_m *MockUserComponent) Delete(ctx context.Context, operator string, username string) error {
	ret := _m.Called(ctx, operator, username)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, operator, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockUserComponent_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - operator string
//   - username string
func (_e *MockUserComponent_Expecter) Delete(ctx interface{}, operator interface{}, username interface{}) *MockUserComponent_Delete_Call {
	return &MockUserComponent_Delete_Call{Call: _e.mock.On("Delete", ctx, operator, username)}
}

func (_c *MockUserComponent_Delete_Call) Run(run func(ctx context.Context, operator string, username string)) *MockUserComponent_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUserComponent_Delete_Call) Return(_a0 error) *MockUserComponent_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_Delete_Call) RunAndReturn(run func(context.Context, string, string) error) *MockUserComponent_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// FindByUUIDs provides a mock function with given fields: ctx, uuids
func (_m *MockUserComponent) FindByUUIDs(ctx context.Context, uuids []string) ([]*types.User, error) {
	ret := _m.Called(ctx, uuids)

	if len(ret) == 0 {
		panic("no return value specified for FindByUUIDs")
	}

	var r0 []*types.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*types.User, error)); ok {
		return rf(ctx, uuids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*types.User); ok {
		r0 = rf(ctx, uuids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, uuids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_FindByUUIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByUUIDs'
type MockUserComponent_FindByUUIDs_Call struct {
	*mock.Call
}

// FindByUUIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - uuids []string
func (_e *MockUserComponent_Expecter) FindByUUIDs(ctx interface{}, uuids interface{}) *MockUserComponent_FindByUUIDs_Call {
	return &MockUserComponent_FindByUUIDs_Call{Call: _e.mock.On("FindByUUIDs", ctx, uuids)}
}

func (_c *MockUserComponent_FindByUUIDs_Call) Run(run func(ctx context.Context, uuids []string)) *MockUserComponent_FindByUUIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockUserComponent_FindByUUIDs_Call) Return(_a0 []*types.User, _a1 error) *MockUserComponent_FindByUUIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserComponent_FindByUUIDs_Call) RunAndReturn(run func(context.Context, []string) ([]*types.User, error)) *MockUserComponent_FindByUUIDs_Call {
	_c.Call.Return(run)
	return _c
}

// FixUserData provides a mock function with given fields: ctx, userName
func (_m *MockUserComponent) FixUserData(ctx context.Context, userName string) error {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for FixUserData")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, userName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_FixUserData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FixUserData'
type MockUserComponent_FixUserData_Call struct {
	*mock.Call
}

// FixUserData is a helper method to define mock.On call
//   - ctx context.Context
//   - userName string
func (_e *MockUserComponent_Expecter) FixUserData(ctx interface{}, userName interface{}) *MockUserComponent_FixUserData_Call {
	return &MockUserComponent_FixUserData_Call{Call: _e.mock.On("FixUserData", ctx, userName)}
}

func (_c *MockUserComponent_FixUserData_Call) Run(run func(ctx context.Context, userName string)) *MockUserComponent_FixUserData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUserComponent_FixUserData_Call) Return(_a0 error) *MockUserComponent_FixUserData_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_FixUserData_Call) RunAndReturn(run func(context.Context, string) error) *MockUserComponent_FixUserData_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateVerificationCodeAndSendEmail provides a mock function with given fields: ctx, uid, email
func (_m *MockUserComponent) GenerateVerificationCodeAndSendEmail(ctx context.Context, uid string, email string) error {
	ret := _m.Called(ctx, uid, email)

	if len(ret) == 0 {
		panic("no return value specified for GenerateVerificationCodeAndSendEmail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, uid, email)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_GenerateVerificationCodeAndSendEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateVerificationCodeAndSendEmail'
type MockUserComponent_GenerateVerificationCodeAndSendEmail_Call struct {
	*mock.Call
}

// GenerateVerificationCodeAndSendEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - uid string
//   - email string
func (_e *MockUserComponent_Expecter) GenerateVerificationCodeAndSendEmail(ctx interface{}, uid interface{}, email interface{}) *MockUserComponent_GenerateVerificationCodeAndSendEmail_Call {
	return &MockUserComponent_GenerateVerificationCodeAndSendEmail_Call{Call: _e.mock.On("GenerateVerificationCodeAndSendEmail", ctx, uid, email)}
}

func (_c *MockUserComponent_GenerateVerificationCodeAndSendEmail_Call) Run(run func(ctx context.Context, uid string, email string)) *MockUserComponent_GenerateVerificationCodeAndSendEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUserComponent_GenerateVerificationCodeAndSendEmail_Call) Return(_a0 error) *MockUserComponent_GenerateVerificationCodeAndSendEmail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_GenerateVerificationCodeAndSendEmail_Call) RunAndReturn(run func(context.Context, string, string) error) *MockUserComponent_GenerateVerificationCodeAndSendEmail_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, userNameOrUUID, visitorName, useUUID
func (_m *MockUserComponent) Get(ctx context.Context, userNameOrUUID string, visitorName string, useUUID bool) (*types.User, error) {
	ret := _m.Called(ctx, userNameOrUUID, visitorName, useUUID)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *types.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (*types.User, error)); ok {
		return rf(ctx, userNameOrUUID, visitorName, useUUID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) *types.User); ok {
		r0 = rf(ctx, userNameOrUUID, visitorName, useUUID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok {
		r1 = rf(ctx, userNameOrUUID, visitorName, useUUID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockUserComponent_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - userNameOrUUID string
//   - visitorName string
//   - useUUID bool
func (_e *MockUserComponent_Expecter) Get(ctx interface{}, userNameOrUUID interface{}, visitorName interface{}, useUUID interface{}) *MockUserComponent_Get_Call {
	return &MockUserComponent_Get_Call{Call: _e.mock.On("Get", ctx, userNameOrUUID, visitorName, useUUID)}
}

func (_c *MockUserComponent_Get_Call) Run(run func(ctx context.Context, userNameOrUUID string, visitorName string, useUUID bool)) *MockUserComponent_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockUserComponent_Get_Call) Return(_a0 *types.User, _a1 error) *MockUserComponent_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserComponent_Get_Call) RunAndReturn(run func(context.Context, string, string, bool) (*types.User, error)) *MockUserComponent_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetEmails provides a mock function with given fields: ctx, visitorName, per, page
func (_m *MockUserComponent) GetEmails(ctx context.Context, visitorName string, per int, page int) ([]string, int, error) {
	ret := _m.Called(ctx, visitorName, per, page)

	if len(ret) == 0 {
		panic("no return value specified for GetEmails")
	}

	var r0 []string
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) ([]string, int, error)); ok {
		return rf(ctx, visitorName, per, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) []string); ok {
		r0 = rf(ctx, visitorName, per, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, int) int); ok {
		r1 = rf(ctx, visitorName, per, page)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, int) error); ok {
		r2 = rf(ctx, visitorName, per, page)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_GetEmails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEmails'
type MockUserComponent_GetEmails_Call struct {
	*mock.Call
}

// GetEmails is a helper method to define mock.On call
//   - ctx context.Context
//   - visitorName string
//   - per int
//   - page int
func (_e *MockUserComponent_Expecter) GetEmails(ctx interface{}, visitorName interface{}, per interface{}, page interface{}) *MockUserComponent_GetEmails_Call {
	return &MockUserComponent_GetEmails_Call{Call: _e.mock.On("GetEmails", ctx, visitorName, per, page)}
}

func (_c *MockUserComponent_GetEmails_Call) Run(run func(ctx context.Context, visitorName string, per int, page int)) *MockUserComponent_GetEmails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockUserComponent_GetEmails_Call) Return(_a0 []string, _a1 int, _a2 error) *MockUserComponent_GetEmails_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_GetEmails_Call) RunAndReturn(run func(context.Context, string, int, int) ([]string, int, error)) *MockUserComponent_GetEmails_Call {
	_c.Call.Return(run)
	return _c
}

// GetEmailsInternal provides a mock function with given fields: ctx, per, page
func (_m *MockUserComponent) GetEmailsInternal(ctx context.Context, per int, page int) ([]string, int, error) {
	ret := _m.Called(ctx, per, page)

	if len(ret) == 0 {
		panic("no return value specified for GetEmailsInternal")
	}

	var r0 []string
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]string, int, error)); ok {
		return rf(ctx, per, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []string); ok {
		r0 = rf(ctx, per, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = rf(ctx, per, page)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = rf(ctx, per, page)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_GetEmailsInternal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEmailsInternal'
type MockUserComponent_GetEmailsInternal_Call struct {
	*mock.Call
}

// GetEmailsInternal is a helper method to define mock.On call
//   - ctx context.Context
//   - per int
//   - page int
func (_e *MockUserComponent_Expecter) GetEmailsInternal(ctx interface{}, per interface{}, page interface{}) *MockUserComponent_GetEmailsInternal_Call {
	return &MockUserComponent_GetEmailsInternal_Call{Call: _e.mock.On("GetEmailsInternal", ctx, per, page)}
}

func (_c *MockUserComponent_GetEmailsInternal_Call) Run(run func(ctx context.Context, per int, page int)) *MockUserComponent_GetEmailsInternal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockUserComponent_GetEmailsInternal_Call) Return(_a0 []string, _a1 int, _a2 error) *MockUserComponent_GetEmailsInternal_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_GetEmailsInternal_Call) RunAndReturn(run func(context.Context, int, int) ([]string, int, error)) *MockUserComponent_GetEmailsInternal_Call {
	_c.Call.Return(run)
	return _c
}

// GetInternal provides a mock function with given fields: ctx, userNameOrUUID, useUUID
func (_m *MockUserComponent) GetInternal(ctx context.Context, userNameOrUUID string, useUUID bool) (*types.User, error) {
	ret := _m.Called(ctx, userNameOrUUID, useUUID)

	if len(ret) == 0 {
		panic("no return value specified for GetInternal")
	}

	var r0 *types.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (*types.User, error)); ok {
		return rf(ctx, userNameOrUUID, useUUID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) *types.User); ok {
		r0 = rf(ctx, userNameOrUUID, useUUID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, userNameOrUUID, useUUID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_GetInternal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInternal'
type MockUserComponent_GetInternal_Call struct {
	*mock.Call
}

// GetInternal is a helper method to define mock.On call
//   - ctx context.Context
//   - userNameOrUUID string
//   - useUUID bool
func (_e *MockUserComponent_Expecter) GetInternal(ctx interface{}, userNameOrUUID interface{}, useUUID interface{}) *MockUserComponent_GetInternal_Call {
	return &MockUserComponent_GetInternal_Call{Call: _e.mock.On("GetInternal", ctx, userNameOrUUID, useUUID)}
}

func (_c *MockUserComponent_GetInternal_Call) Run(run func(ctx context.Context, userNameOrUUID string, useUUID bool)) *MockUserComponent_GetInternal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *MockUserComponent_GetInternal_Call) Return(_a0 *types.User, _a1 error) *MockUserComponent_GetInternal_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserComponent_GetInternal_Call) RunAndReturn(run func(context.Context, string, bool) (*types.User, error)) *MockUserComponent_GetInternal_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserUUIDs provides a mock function with given fields: ctx, per, page
func (_m *MockUserComponent) GetUserUUIDs(ctx context.Context, per int, page int) ([]string, int, error) {
	ret := _m.Called(ctx, per, page)

	if len(ret) == 0 {
		panic("no return value specified for GetUserUUIDs")
	}

	var r0 []string
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]string, int, error)); ok {
		return rf(ctx, per, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []string); ok {
		r0 = rf(ctx, per, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = rf(ctx, per, page)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = rf(ctx, per, page)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_GetUserUUIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserUUIDs'
type MockUserComponent_GetUserUUIDs_Call struct {
	*mock.Call
}

// GetUserUUIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - per int
//   - page int
func (_e *MockUserComponent_Expecter) GetUserUUIDs(ctx interface{}, per interface{}, page interface{}) *MockUserComponent_GetUserUUIDs_Call {
	return &MockUserComponent_GetUserUUIDs_Call{Call: _e.mock.On("GetUserUUIDs", ctx, per, page)}
}

func (_c *MockUserComponent_GetUserUUIDs_Call) Run(run func(ctx context.Context, per int, page int)) *MockUserComponent_GetUserUUIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockUserComponent_GetUserUUIDs_Call) Return(_a0 []string, _a1 int, _a2 error) *MockUserComponent_GetUserUUIDs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_GetUserUUIDs_Call) RunAndReturn(run func(context.Context, int, int) ([]string, int, error)) *MockUserComponent_GetUserUUIDs_Call {
	_c.Call.Return(run)
	return _c
}

// Index provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) Index(ctx context.Context, req types.UserListReq) ([]*types.User, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Index")
	}

	var r0 []*types.User
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, types.UserListReq) ([]*types.User, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.UserListReq) []*types.User); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.UserListReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, types.UserListReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_Index_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Index'
type MockUserComponent_Index_Call struct {
	*mock.Call
}

// Index is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.UserListReq
func (_e *MockUserComponent_Expecter) Index(ctx interface{}, req interface{}) *MockUserComponent_Index_Call {
	return &MockUserComponent_Index_Call{Call: _e.mock.On("Index", ctx, req)}
}

func (_c *MockUserComponent_Index_Call) Run(run func(ctx context.Context, req types.UserListReq)) *MockUserComponent_Index_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.UserListReq))
	})
	return _c
}

func (_c *MockUserComponent_Index_Call) Return(_a0 []*types.User, _a1 int, _a2 error) *MockUserComponent_Index_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_Index_Call) RunAndReturn(run func(context.Context, types.UserListReq) ([]*types.User, int, error)) *MockUserComponent_Index_Call {
	_c.Call.Return(run)
	return _c
}

// ResetUserTags provides a mock function with given fields: ctx, uid, tagIDs
func (_m *MockUserComponent) ResetUserTags(ctx context.Context, uid string, tagIDs []int64) error {
	ret := _m.Called(ctx, uid, tagIDs)

	if len(ret) == 0 {
		panic("no return value specified for ResetUserTags")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []int64) error); ok {
		r0 = rf(ctx, uid, tagIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_ResetUserTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetUserTags'
type MockUserComponent_ResetUserTags_Call struct {
	*mock.Call
}

// ResetUserTags is a helper method to define mock.On call
//   - ctx context.Context
//   - uid string
//   - tagIDs []int64
func (_e *MockUserComponent_Expecter) ResetUserTags(ctx interface{}, uid interface{}, tagIDs interface{}) *MockUserComponent_ResetUserTags_Call {
	return &MockUserComponent_ResetUserTags_Call{Call: _e.mock.On("ResetUserTags", ctx, uid, tagIDs)}
}

func (_c *MockUserComponent_ResetUserTags_Call) Run(run func(ctx context.Context, uid string, tagIDs []int64)) *MockUserComponent_ResetUserTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]int64))
	})
	return _c
}

func (_c *MockUserComponent_ResetUserTags_Call) Return(_a0 error) *MockUserComponent_ResetUserTags_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_ResetUserTags_Call) RunAndReturn(run func(context.Context, string, []int64) error) *MockUserComponent_ResetUserTags_Call {
	_c.Call.Return(run)
	return _c
}

// Signin provides a mock function with given fields: ctx, code, state
func (_m *MockUserComponent) Signin(ctx context.Context, code string, state string) (*types.JWTClaims, string, error) {
	ret := _m.Called(ctx, code, state)

	if len(ret) == 0 {
		panic("no return value specified for Signin")
	}

	var r0 *types.JWTClaims
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*types.JWTClaims, string, error)); ok {
		return rf(ctx, code, state)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *types.JWTClaims); ok {
		r0 = rf(ctx, code, state)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.JWTClaims)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) string); ok {
		r1 = rf(ctx, code, state)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = rf(ctx, code, state)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_Signin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Signin'
type MockUserComponent_Signin_Call struct {
	*mock.Call
}

// Signin is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
//   - state string
func (_e *MockUserComponent_Expecter) Signin(ctx interface{}, code interface{}, state interface{}) *MockUserComponent_Signin_Call {
	return &MockUserComponent_Signin_Call{Call: _e.mock.On("Signin", ctx, code, state)}
}

func (_c *MockUserComponent_Signin_Call) Run(run func(ctx context.Context, code string, state string)) *MockUserComponent_Signin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUserComponent_Signin_Call) Return(_a0 *types.JWTClaims, _a1 string, _a2 error) *MockUserComponent_Signin_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_Signin_Call) RunAndReturn(run func(context.Context, string, string) (*types.JWTClaims, string, error)) *MockUserComponent_Signin_Call {
	_c.Call.Return(run)
	return _c
}

// SoftDelete provides a mock function with given fields: ctx, operator, username, req
func (_m *MockUserComponent) SoftDelete(ctx context.Context, operator string, username string, req types.CloseAccountReq) error {
	ret := _m.Called(ctx, operator, username, req)

	if len(ret) == 0 {
		panic("no return value specified for SoftDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, types.CloseAccountReq) error); ok {
		r0 = rf(ctx, operator, username, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_SoftDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SoftDelete'
type MockUserComponent_SoftDelete_Call struct {
	*mock.Call
}

// SoftDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - operator string
//   - username string
//   - req types.CloseAccountReq
func (_e *MockUserComponent_Expecter) SoftDelete(ctx interface{}, operator interface{}, username interface{}, req interface{}) *MockUserComponent_SoftDelete_Call {
	return &MockUserComponent_SoftDelete_Call{Call: _e.mock.On("SoftDelete", ctx, operator, username, req)}
}

func (_c *MockUserComponent_SoftDelete_Call) Run(run func(ctx context.Context, operator string, username string, req types.CloseAccountReq)) *MockUserComponent_SoftDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(types.CloseAccountReq))
	})
	return _c
}

func (_c *MockUserComponent_SoftDelete_Call) Return(_a0 error) *MockUserComponent_SoftDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_SoftDelete_Call) RunAndReturn(run func(context.Context, string, string, types.CloseAccountReq) error) *MockUserComponent_SoftDelete_Call {
	_c.Call.Return(run)
	return _c
}

// StreamExportUsers provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) StreamExportUsers(ctx context.Context, req types.UserIndexReq) (chan types.UserIndexResp, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for StreamExportUsers")
	}

	var r0 chan types.UserIndexResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.UserIndexReq) (chan types.UserIndexResp, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.UserIndexReq) chan types.UserIndexResp); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan types.UserIndexResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.UserIndexReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_StreamExportUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamExportUsers'
type MockUserComponent_StreamExportUsers_Call struct {
	*mock.Call
}

// StreamExportUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.UserIndexReq
func (_e *MockUserComponent_Expecter) StreamExportUsers(ctx interface{}, req interface{}) *MockUserComponent_StreamExportUsers_Call {
	return &MockUserComponent_StreamExportUsers_Call{Call: _e.mock.On("StreamExportUsers", ctx, req)}
}

func (_c *MockUserComponent_StreamExportUsers_Call) Run(run func(ctx context.Context, req types.UserIndexReq)) *MockUserComponent_StreamExportUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.UserIndexReq))
	})
	return _c
}

func (_c *MockUserComponent_StreamExportUsers_Call) Return(data chan types.UserIndexResp, err error) *MockUserComponent_StreamExportUsers_Call {
	_c.Call.Return(data, err)
	return _c
}

func (_c *MockUserComponent_StreamExportUsers_Call) RunAndReturn(run func(context.Context, types.UserIndexReq) (chan types.UserIndexResp, error)) *MockUserComponent_StreamExportUsers_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateByUUID provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) UpdateByUUID(ctx context.Context, req *types.UpdateUserRequest) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for UpdateByUUID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UpdateUserRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_UpdateByUUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateByUUID'
type MockUserComponent_UpdateByUUID_Call struct {
	*mock.Call
}

// UpdateByUUID is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UpdateUserRequest
func (_e *MockUserComponent_Expecter) UpdateByUUID(ctx interface{}, req interface{}) *MockUserComponent_UpdateByUUID_Call {
	return &MockUserComponent_UpdateByUUID_Call{Call: _e.mock.On("UpdateByUUID", ctx, req)}
}

func (_c *MockUserComponent_UpdateByUUID_Call) Run(run func(ctx context.Context, req *types.UpdateUserRequest)) *MockUserComponent_UpdateByUUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UpdateUserRequest))
	})
	return _c
}

func (_c *MockUserComponent_UpdateByUUID_Call) Return(_a0 error) *MockUserComponent_UpdateByUUID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_UpdateByUUID_Call) RunAndReturn(run func(context.Context, *types.UpdateUserRequest) error) *MockUserComponent_UpdateByUUID_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserLabels provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) UpdateUserLabels(ctx context.Context, req *types.UserLabelsRequest) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserLabels")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserLabelsRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_UpdateUserLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserLabels'
type MockUserComponent_UpdateUserLabels_Call struct {
	*mock.Call
}

// UpdateUserLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserLabelsRequest
func (_e *MockUserComponent_Expecter) UpdateUserLabels(ctx interface{}, req interface{}) *MockUserComponent_UpdateUserLabels_Call {
	return &MockUserComponent_UpdateUserLabels_Call{Call: _e.mock.On("UpdateUserLabels", ctx, req)}
}

func (_c *MockUserComponent_UpdateUserLabels_Call) Run(run func(ctx context.Context, req *types.UserLabelsRequest)) *MockUserComponent_UpdateUserLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserLabelsRequest))
	})
	return _c
}

func (_c *MockUserComponent_UpdateUserLabels_Call) Return(_a0 error) *MockUserComponent_UpdateUserLabels_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_UpdateUserLabels_Call) RunAndReturn(run func(context.Context, *types.UserLabelsRequest) error) *MockUserComponent_UpdateUserLabels_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserComponent creates a new instance of MockUserComponent. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserComponent(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserComponent {
	mock := &MockUserComponent{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
