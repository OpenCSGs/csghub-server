// Code generated by mockery v2.53.0. DO NOT EDIT.

package accounting

import (
	mock "github.com/stretchr/testify/mock"
	types "opencsg.com/csghub-server/common/types"
)

// MockAccountingClient is an autogenerated mock type for the AccountingClient type
type MockAccountingClient struct {
	mock.Mock
}

type MockAccountingClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccountingClient) EXPECT() *MockAccountingClient_Expecter {
	return &MockAccountingClient_Expecter{mock: &_m.Mock}
}

// CreateOrUpdateQuota provides a mock function with given fields: currentUser, req
func (_m *MockAccountingClient) CreateOrUpdateQuota(currentUser string, req types.AcctQuotaReq) (any, error) {
	ret := _m.Called(currentUser, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateQuota")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.AcctQuotaReq) (any, error)); ok {
		return rf(currentUser, req)
	}
	if rf, ok := ret.Get(0).(func(string, types.AcctQuotaReq) any); ok {
		r0 = rf(currentUser, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, types.AcctQuotaReq) error); ok {
		r1 = rf(currentUser, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_CreateOrUpdateQuota_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateQuota'
type MockAccountingClient_CreateOrUpdateQuota_Call struct {
	*mock.Call
}

// CreateOrUpdateQuota is a helper method to define mock.On call
//   - currentUser string
//   - req types.AcctQuotaReq
func (_e *MockAccountingClient_Expecter) CreateOrUpdateQuota(currentUser interface{}, req interface{}) *MockAccountingClient_CreateOrUpdateQuota_Call {
	return &MockAccountingClient_CreateOrUpdateQuota_Call{Call: _e.mock.On("CreateOrUpdateQuota", currentUser, req)}
}

func (_c *MockAccountingClient_CreateOrUpdateQuota_Call) Run(run func(currentUser string, req types.AcctQuotaReq)) *MockAccountingClient_CreateOrUpdateQuota_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(types.AcctQuotaReq))
	})
	return _c
}

func (_c *MockAccountingClient_CreateOrUpdateQuota_Call) Return(_a0 any, _a1 error) *MockAccountingClient_CreateOrUpdateQuota_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_CreateOrUpdateQuota_Call) RunAndReturn(run func(string, types.AcctQuotaReq) (any, error)) *MockAccountingClient_CreateOrUpdateQuota_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrder provides a mock function with given fields: currentUser, req
func (_m *MockAccountingClient) CreateOrder(currentUser string, req types.AcctOrderCreateReq) (any, error) {
	ret := _m.Called(currentUser, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrder")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.AcctOrderCreateReq) (any, error)); ok {
		return rf(currentUser, req)
	}
	if rf, ok := ret.Get(0).(func(string, types.AcctOrderCreateReq) any); ok {
		r0 = rf(currentUser, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, types.AcctOrderCreateReq) error); ok {
		r1 = rf(currentUser, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_CreateOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrder'
type MockAccountingClient_CreateOrder_Call struct {
	*mock.Call
}

// CreateOrder is a helper method to define mock.On call
//   - currentUser string
//   - req types.AcctOrderCreateReq
func (_e *MockAccountingClient_Expecter) CreateOrder(currentUser interface{}, req interface{}) *MockAccountingClient_CreateOrder_Call {
	return &MockAccountingClient_CreateOrder_Call{Call: _e.mock.On("CreateOrder", currentUser, req)}
}

func (_c *MockAccountingClient_CreateOrder_Call) Run(run func(currentUser string, req types.AcctOrderCreateReq)) *MockAccountingClient_CreateOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(types.AcctOrderCreateReq))
	})
	return _c
}

func (_c *MockAccountingClient_CreateOrder_Call) Return(_a0 any, _a1 error) *MockAccountingClient_CreateOrder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_CreateOrder_Call) RunAndReturn(run func(string, types.AcctOrderCreateReq) (any, error)) *MockAccountingClient_CreateOrder_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePrice provides a mock function with given fields: currentUser, req
func (_m *MockAccountingClient) CreatePrice(currentUser string, req types.AcctPriceCreateReq) (any, error) {
	ret := _m.Called(currentUser, req)

	if len(ret) == 0 {
		panic("no return value specified for CreatePrice")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.AcctPriceCreateReq) (any, error)); ok {
		return rf(currentUser, req)
	}
	if rf, ok := ret.Get(0).(func(string, types.AcctPriceCreateReq) any); ok {
		r0 = rf(currentUser, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, types.AcctPriceCreateReq) error); ok {
		r1 = rf(currentUser, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_CreatePrice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePrice'
type MockAccountingClient_CreatePrice_Call struct {
	*mock.Call
}

// CreatePrice is a helper method to define mock.On call
//   - currentUser string
//   - req types.AcctPriceCreateReq
func (_e *MockAccountingClient_Expecter) CreatePrice(currentUser interface{}, req interface{}) *MockAccountingClient_CreatePrice_Call {
	return &MockAccountingClient_CreatePrice_Call{Call: _e.mock.On("CreatePrice", currentUser, req)}
}

func (_c *MockAccountingClient_CreatePrice_Call) Run(run func(currentUser string, req types.AcctPriceCreateReq)) *MockAccountingClient_CreatePrice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(types.AcctPriceCreateReq))
	})
	return _c
}

func (_c *MockAccountingClient_CreatePrice_Call) Return(_a0 any, _a1 error) *MockAccountingClient_CreatePrice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_CreatePrice_Call) RunAndReturn(run func(string, types.AcctPriceCreateReq) (any, error)) *MockAccountingClient_CreatePrice_Call {
	_c.Call.Return(run)
	return _c
}

// CreateQuotaStatement provides a mock function with given fields: currentUser, req
func (_m *MockAccountingClient) CreateQuotaStatement(currentUser string, req types.AcctQuotaStatementReq) (any, error) {
	ret := _m.Called(currentUser, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateQuotaStatement")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.AcctQuotaStatementReq) (any, error)); ok {
		return rf(currentUser, req)
	}
	if rf, ok := ret.Get(0).(func(string, types.AcctQuotaStatementReq) any); ok {
		r0 = rf(currentUser, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, types.AcctQuotaStatementReq) error); ok {
		r1 = rf(currentUser, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_CreateQuotaStatement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateQuotaStatement'
type MockAccountingClient_CreateQuotaStatement_Call struct {
	*mock.Call
}

// CreateQuotaStatement is a helper method to define mock.On call
//   - currentUser string
//   - req types.AcctQuotaStatementReq
func (_e *MockAccountingClient_Expecter) CreateQuotaStatement(currentUser interface{}, req interface{}) *MockAccountingClient_CreateQuotaStatement_Call {
	return &MockAccountingClient_CreateQuotaStatement_Call{Call: _e.mock.On("CreateQuotaStatement", currentUser, req)}
}

func (_c *MockAccountingClient_CreateQuotaStatement_Call) Run(run func(currentUser string, req types.AcctQuotaStatementReq)) *MockAccountingClient_CreateQuotaStatement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(types.AcctQuotaStatementReq))
	})
	return _c
}

func (_c *MockAccountingClient_CreateQuotaStatement_Call) Return(_a0 any, _a1 error) *MockAccountingClient_CreateQuotaStatement_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_CreateQuotaStatement_Call) RunAndReturn(run func(string, types.AcctQuotaStatementReq) (any, error)) *MockAccountingClient_CreateQuotaStatement_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePrice provides a mock function with given fields: currentUser, id
func (_m *MockAccountingClient) DeletePrice(currentUser string, id int64) (any, error) {
	ret := _m.Called(currentUser, id)

	if len(ret) == 0 {
		panic("no return value specified for DeletePrice")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64) (any, error)); ok {
		return rf(currentUser, id)
	}
	if rf, ok := ret.Get(0).(func(string, int64) any); ok {
		r0 = rf(currentUser, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int64) error); ok {
		r1 = rf(currentUser, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_DeletePrice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePrice'
type MockAccountingClient_DeletePrice_Call struct {
	*mock.Call
}

// DeletePrice is a helper method to define mock.On call
//   - currentUser string
//   - id int64
func (_e *MockAccountingClient_Expecter) DeletePrice(currentUser interface{}, id interface{}) *MockAccountingClient_DeletePrice_Call {
	return &MockAccountingClient_DeletePrice_Call{Call: _e.mock.On("DeletePrice", currentUser, id)}
}

func (_c *MockAccountingClient_DeletePrice_Call) Run(run func(currentUser string, id int64)) *MockAccountingClient_DeletePrice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64))
	})
	return _c
}

func (_c *MockAccountingClient_DeletePrice_Call) Return(_a0 any, _a1 error) *MockAccountingClient_DeletePrice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_DeletePrice_Call) RunAndReturn(run func(string, int64) (any, error)) *MockAccountingClient_DeletePrice_Call {
	_c.Call.Return(run)
	return _c
}

// GetPriceByID provides a mock function with given fields: currentUser, id
func (_m *MockAccountingClient) GetPriceByID(currentUser string, id int64) (any, error) {
	ret := _m.Called(currentUser, id)

	if len(ret) == 0 {
		panic("no return value specified for GetPriceByID")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int64) (any, error)); ok {
		return rf(currentUser, id)
	}
	if rf, ok := ret.Get(0).(func(string, int64) any); ok {
		r0 = rf(currentUser, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int64) error); ok {
		r1 = rf(currentUser, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_GetPriceByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPriceByID'
type MockAccountingClient_GetPriceByID_Call struct {
	*mock.Call
}

// GetPriceByID is a helper method to define mock.On call
//   - currentUser string
//   - id int64
func (_e *MockAccountingClient_Expecter) GetPriceByID(currentUser interface{}, id interface{}) *MockAccountingClient_GetPriceByID_Call {
	return &MockAccountingClient_GetPriceByID_Call{Call: _e.mock.On("GetPriceByID", currentUser, id)}
}

func (_c *MockAccountingClient_GetPriceByID_Call) Run(run func(currentUser string, id int64)) *MockAccountingClient_GetPriceByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64))
	})
	return _c
}

func (_c *MockAccountingClient_GetPriceByID_Call) Return(_a0 any, _a1 error) *MockAccountingClient_GetPriceByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_GetPriceByID_Call) RunAndReturn(run func(string, int64) (any, error)) *MockAccountingClient_GetPriceByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetQuotaByID provides a mock function with given fields: currentUser
func (_m *MockAccountingClient) GetQuotaByID(currentUser string) (any, error) {
	ret := _m.Called(currentUser)

	if len(ret) == 0 {
		panic("no return value specified for GetQuotaByID")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (any, error)); ok {
		return rf(currentUser)
	}
	if rf, ok := ret.Get(0).(func(string) any); ok {
		r0 = rf(currentUser)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(currentUser)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_GetQuotaByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetQuotaByID'
type MockAccountingClient_GetQuotaByID_Call struct {
	*mock.Call
}

// GetQuotaByID is a helper method to define mock.On call
//   - currentUser string
func (_e *MockAccountingClient_Expecter) GetQuotaByID(currentUser interface{}) *MockAccountingClient_GetQuotaByID_Call {
	return &MockAccountingClient_GetQuotaByID_Call{Call: _e.mock.On("GetQuotaByID", currentUser)}
}

func (_c *MockAccountingClient_GetQuotaByID_Call) Run(run func(currentUser string)) *MockAccountingClient_GetQuotaByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockAccountingClient_GetQuotaByID_Call) Return(_a0 any, _a1 error) *MockAccountingClient_GetQuotaByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_GetQuotaByID_Call) RunAndReturn(run func(string) (any, error)) *MockAccountingClient_GetQuotaByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetQuotaStatement provides a mock function with given fields: currentUser, req
func (_m *MockAccountingClient) GetQuotaStatement(currentUser string, req types.AcctQuotaStatementReq) (any, error) {
	ret := _m.Called(currentUser, req)

	if len(ret) == 0 {
		panic("no return value specified for GetQuotaStatement")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.AcctQuotaStatementReq) (any, error)); ok {
		return rf(currentUser, req)
	}
	if rf, ok := ret.Get(0).(func(string, types.AcctQuotaStatementReq) any); ok {
		r0 = rf(currentUser, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, types.AcctQuotaStatementReq) error); ok {
		r1 = rf(currentUser, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_GetQuotaStatement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetQuotaStatement'
type MockAccountingClient_GetQuotaStatement_Call struct {
	*mock.Call
}

// GetQuotaStatement is a helper method to define mock.On call
//   - currentUser string
//   - req types.AcctQuotaStatementReq
func (_e *MockAccountingClient_Expecter) GetQuotaStatement(currentUser interface{}, req interface{}) *MockAccountingClient_GetQuotaStatement_Call {
	return &MockAccountingClient_GetQuotaStatement_Call{Call: _e.mock.On("GetQuotaStatement", currentUser, req)}
}

func (_c *MockAccountingClient_GetQuotaStatement_Call) Run(run func(currentUser string, req types.AcctQuotaStatementReq)) *MockAccountingClient_GetQuotaStatement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(types.AcctQuotaStatementReq))
	})
	return _c
}

func (_c *MockAccountingClient_GetQuotaStatement_Call) Return(_a0 any, _a1 error) *MockAccountingClient_GetQuotaStatement_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_GetQuotaStatement_Call) RunAndReturn(run func(string, types.AcctQuotaStatementReq) (any, error)) *MockAccountingClient_GetQuotaStatement_Call {
	_c.Call.Return(run)
	return _c
}

// ListBillsByUserIDAndDate provides a mock function with given fields: req
func (_m *MockAccountingClient) ListBillsByUserIDAndDate(req types.ActStatementsReq) (any, error) {
	ret := _m.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for ListBillsByUserIDAndDate")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(types.ActStatementsReq) (any, error)); ok {
		return rf(req)
	}
	if rf, ok := ret.Get(0).(func(types.ActStatementsReq) any); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(types.ActStatementsReq) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_ListBillsByUserIDAndDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBillsByUserIDAndDate'
type MockAccountingClient_ListBillsByUserIDAndDate_Call struct {
	*mock.Call
}

// ListBillsByUserIDAndDate is a helper method to define mock.On call
//   - req types.ActStatementsReq
func (_e *MockAccountingClient_Expecter) ListBillsByUserIDAndDate(req interface{}) *MockAccountingClient_ListBillsByUserIDAndDate_Call {
	return &MockAccountingClient_ListBillsByUserIDAndDate_Call{Call: _e.mock.On("ListBillsByUserIDAndDate", req)}
}

func (_c *MockAccountingClient_ListBillsByUserIDAndDate_Call) Run(run func(req types.ActStatementsReq)) *MockAccountingClient_ListBillsByUserIDAndDate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.ActStatementsReq))
	})
	return _c
}

func (_c *MockAccountingClient_ListBillsByUserIDAndDate_Call) Return(_a0 any, _a1 error) *MockAccountingClient_ListBillsByUserIDAndDate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_ListBillsByUserIDAndDate_Call) RunAndReturn(run func(types.ActStatementsReq) (any, error)) *MockAccountingClient_ListBillsByUserIDAndDate_Call {
	_c.Call.Return(run)
	return _c
}

// ListMeteringsByUserIDAndTime provides a mock function with given fields: req
func (_m *MockAccountingClient) ListMeteringsByUserIDAndTime(req types.ActStatementsReq) (any, error) {
	ret := _m.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for ListMeteringsByUserIDAndTime")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(types.ActStatementsReq) (any, error)); ok {
		return rf(req)
	}
	if rf, ok := ret.Get(0).(func(types.ActStatementsReq) any); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(types.ActStatementsReq) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_ListMeteringsByUserIDAndTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMeteringsByUserIDAndTime'
type MockAccountingClient_ListMeteringsByUserIDAndTime_Call struct {
	*mock.Call
}

// ListMeteringsByUserIDAndTime is a helper method to define mock.On call
//   - req types.ActStatementsReq
func (_e *MockAccountingClient_Expecter) ListMeteringsByUserIDAndTime(req interface{}) *MockAccountingClient_ListMeteringsByUserIDAndTime_Call {
	return &MockAccountingClient_ListMeteringsByUserIDAndTime_Call{Call: _e.mock.On("ListMeteringsByUserIDAndTime", req)}
}

func (_c *MockAccountingClient_ListMeteringsByUserIDAndTime_Call) Run(run func(req types.ActStatementsReq)) *MockAccountingClient_ListMeteringsByUserIDAndTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.ActStatementsReq))
	})
	return _c
}

func (_c *MockAccountingClient_ListMeteringsByUserIDAndTime_Call) Return(_a0 any, _a1 error) *MockAccountingClient_ListMeteringsByUserIDAndTime_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_ListMeteringsByUserIDAndTime_Call) RunAndReturn(run func(types.ActStatementsReq) (any, error)) *MockAccountingClient_ListMeteringsByUserIDAndTime_Call {
	_c.Call.Return(run)
	return _c
}

// ListRechargeByUserIDAndTime provides a mock function with given fields: req
func (_m *MockAccountingClient) ListRechargeByUserIDAndTime(req types.AcctRechargeListReq) (any, error) {
	ret := _m.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for ListRechargeByUserIDAndTime")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(types.AcctRechargeListReq) (any, error)); ok {
		return rf(req)
	}
	if rf, ok := ret.Get(0).(func(types.AcctRechargeListReq) any); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(types.AcctRechargeListReq) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_ListRechargeByUserIDAndTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRechargeByUserIDAndTime'
type MockAccountingClient_ListRechargeByUserIDAndTime_Call struct {
	*mock.Call
}

// ListRechargeByUserIDAndTime is a helper method to define mock.On call
//   - req types.AcctRechargeListReq
func (_e *MockAccountingClient_Expecter) ListRechargeByUserIDAndTime(req interface{}) *MockAccountingClient_ListRechargeByUserIDAndTime_Call {
	return &MockAccountingClient_ListRechargeByUserIDAndTime_Call{Call: _e.mock.On("ListRechargeByUserIDAndTime", req)}
}

func (_c *MockAccountingClient_ListRechargeByUserIDAndTime_Call) Run(run func(req types.AcctRechargeListReq)) *MockAccountingClient_ListRechargeByUserIDAndTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.AcctRechargeListReq))
	})
	return _c
}

func (_c *MockAccountingClient_ListRechargeByUserIDAndTime_Call) Return(_a0 any, _a1 error) *MockAccountingClient_ListRechargeByUserIDAndTime_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_ListRechargeByUserIDAndTime_Call) RunAndReturn(run func(types.AcctRechargeListReq) (any, error)) *MockAccountingClient_ListRechargeByUserIDAndTime_Call {
	_c.Call.Return(run)
	return _c
}

// ListRecharges provides a mock function with given fields: req
func (_m *MockAccountingClient) ListRecharges(req types.RechargesIndexReq) (any, error) {
	ret := _m.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for ListRecharges")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(types.RechargesIndexReq) (any, error)); ok {
		return rf(req)
	}
	if rf, ok := ret.Get(0).(func(types.RechargesIndexReq) any); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(types.RechargesIndexReq) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_ListRecharges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRecharges'
type MockAccountingClient_ListRecharges_Call struct {
	*mock.Call
}

// ListRecharges is a helper method to define mock.On call
//   - req types.RechargesIndexReq
func (_e *MockAccountingClient_Expecter) ListRecharges(req interface{}) *MockAccountingClient_ListRecharges_Call {
	return &MockAccountingClient_ListRecharges_Call{Call: _e.mock.On("ListRecharges", req)}
}

func (_c *MockAccountingClient_ListRecharges_Call) Run(run func(req types.RechargesIndexReq)) *MockAccountingClient_ListRecharges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.RechargesIndexReq))
	})
	return _c
}

func (_c *MockAccountingClient_ListRecharges_Call) Return(_a0 any, _a1 error) *MockAccountingClient_ListRecharges_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_ListRecharges_Call) RunAndReturn(run func(types.RechargesIndexReq) (any, error)) *MockAccountingClient_ListRecharges_Call {
	_c.Call.Return(run)
	return _c
}

// ListStatementByUserIDAndTime provides a mock function with given fields: req
func (_m *MockAccountingClient) ListStatementByUserIDAndTime(req types.ActStatementsReq) (any, error) {
	ret := _m.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for ListStatementByUserIDAndTime")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(types.ActStatementsReq) (any, error)); ok {
		return rf(req)
	}
	if rf, ok := ret.Get(0).(func(types.ActStatementsReq) any); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(types.ActStatementsReq) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_ListStatementByUserIDAndTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListStatementByUserIDAndTime'
type MockAccountingClient_ListStatementByUserIDAndTime_Call struct {
	*mock.Call
}

// ListStatementByUserIDAndTime is a helper method to define mock.On call
//   - req types.ActStatementsReq
func (_e *MockAccountingClient_Expecter) ListStatementByUserIDAndTime(req interface{}) *MockAccountingClient_ListStatementByUserIDAndTime_Call {
	return &MockAccountingClient_ListStatementByUserIDAndTime_Call{Call: _e.mock.On("ListStatementByUserIDAndTime", req)}
}

func (_c *MockAccountingClient_ListStatementByUserIDAndTime_Call) Run(run func(req types.ActStatementsReq)) *MockAccountingClient_ListStatementByUserIDAndTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.ActStatementsReq))
	})
	return _c
}

func (_c *MockAccountingClient_ListStatementByUserIDAndTime_Call) Return(_a0 any, _a1 error) *MockAccountingClient_ListStatementByUserIDAndTime_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_ListStatementByUserIDAndTime_Call) RunAndReturn(run func(types.ActStatementsReq) (any, error)) *MockAccountingClient_ListStatementByUserIDAndTime_Call {
	_c.Call.Return(run)
	return _c
}

// PresentAccountingUser provides a mock function with given fields: userID, req
func (_m *MockAccountingClient) PresentAccountingUser(userID string, req types.ACTIVITY_REQ) (any, error) {
	ret := _m.Called(userID, req)

	if len(ret) == 0 {
		panic("no return value specified for PresentAccountingUser")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.ACTIVITY_REQ) (any, error)); ok {
		return rf(userID, req)
	}
	if rf, ok := ret.Get(0).(func(string, types.ACTIVITY_REQ) any); ok {
		r0 = rf(userID, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, types.ACTIVITY_REQ) error); ok {
		r1 = rf(userID, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_PresentAccountingUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PresentAccountingUser'
type MockAccountingClient_PresentAccountingUser_Call struct {
	*mock.Call
}

// PresentAccountingUser is a helper method to define mock.On call
//   - userID string
//   - req types.ACTIVITY_REQ
func (_e *MockAccountingClient_Expecter) PresentAccountingUser(userID interface{}, req interface{}) *MockAccountingClient_PresentAccountingUser_Call {
	return &MockAccountingClient_PresentAccountingUser_Call{Call: _e.mock.On("PresentAccountingUser", userID, req)}
}

func (_c *MockAccountingClient_PresentAccountingUser_Call) Run(run func(userID string, req types.ACTIVITY_REQ)) *MockAccountingClient_PresentAccountingUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(types.ACTIVITY_REQ))
	})
	return _c
}

func (_c *MockAccountingClient_PresentAccountingUser_Call) Return(_a0 any, _a1 error) *MockAccountingClient_PresentAccountingUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_PresentAccountingUser_Call) RunAndReturn(run func(string, types.ACTIVITY_REQ) (any, error)) *MockAccountingClient_PresentAccountingUser_Call {
	_c.Call.Return(run)
	return _c
}

// QueryAllUsersBalance provides a mock function with given fields: per, page
func (_m *MockAccountingClient) QueryAllUsersBalance(per int, page int) (any, error) {
	ret := _m.Called(per, page)

	if len(ret) == 0 {
		panic("no return value specified for QueryAllUsersBalance")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int) (any, error)); ok {
		return rf(per, page)
	}
	if rf, ok := ret.Get(0).(func(int, int) any); ok {
		r0 = rf(per, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = rf(per, page)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_QueryAllUsersBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryAllUsersBalance'
type MockAccountingClient_QueryAllUsersBalance_Call struct {
	*mock.Call
}

// QueryAllUsersBalance is a helper method to define mock.On call
//   - per int
//   - page int
func (_e *MockAccountingClient_Expecter) QueryAllUsersBalance(per interface{}, page interface{}) *MockAccountingClient_QueryAllUsersBalance_Call {
	return &MockAccountingClient_QueryAllUsersBalance_Call{Call: _e.mock.On("QueryAllUsersBalance", per, page)}
}

func (_c *MockAccountingClient_QueryAllUsersBalance_Call) Run(run func(per int, page int)) *MockAccountingClient_QueryAllUsersBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int))
	})
	return _c
}

func (_c *MockAccountingClient_QueryAllUsersBalance_Call) Return(_a0 any, _a1 error) *MockAccountingClient_QueryAllUsersBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_QueryAllUsersBalance_Call) RunAndReturn(run func(int, int) (any, error)) *MockAccountingClient_QueryAllUsersBalance_Call {
	_c.Call.Return(run)
	return _c
}

// QueryBalanceByUserID provides a mock function with given fields: userUUID
func (_m *MockAccountingClient) QueryBalanceByUserID(userUUID string) (any, error) {
	ret := _m.Called(userUUID)

	if len(ret) == 0 {
		panic("no return value specified for QueryBalanceByUserID")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (any, error)); ok {
		return rf(userUUID)
	}
	if rf, ok := ret.Get(0).(func(string) any); ok {
		r0 = rf(userUUID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(userUUID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_QueryBalanceByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryBalanceByUserID'
type MockAccountingClient_QueryBalanceByUserID_Call struct {
	*mock.Call
}

// QueryBalanceByUserID is a helper method to define mock.On call
//   - userUUID string
func (_e *MockAccountingClient_Expecter) QueryBalanceByUserID(userUUID interface{}) *MockAccountingClient_QueryBalanceByUserID_Call {
	return &MockAccountingClient_QueryBalanceByUserID_Call{Call: _e.mock.On("QueryBalanceByUserID", userUUID)}
}

func (_c *MockAccountingClient_QueryBalanceByUserID_Call) Run(run func(userUUID string)) *MockAccountingClient_QueryBalanceByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockAccountingClient_QueryBalanceByUserID_Call) Return(_a0 any, _a1 error) *MockAccountingClient_QueryBalanceByUserID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_QueryBalanceByUserID_Call) RunAndReturn(run func(string) (any, error)) *MockAccountingClient_QueryBalanceByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// QueryPricesBySKUType provides a mock function with given fields: currentUser, req
func (_m *MockAccountingClient) QueryPricesBySKUType(currentUser string, req types.AcctPriceListReq) (any, error) {
	ret := _m.Called(currentUser, req)

	if len(ret) == 0 {
		panic("no return value specified for QueryPricesBySKUType")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.AcctPriceListReq) (any, error)); ok {
		return rf(currentUser, req)
	}
	if rf, ok := ret.Get(0).(func(string, types.AcctPriceListReq) any); ok {
		r0 = rf(currentUser, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, types.AcctPriceListReq) error); ok {
		r1 = rf(currentUser, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_QueryPricesBySKUType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryPricesBySKUType'
type MockAccountingClient_QueryPricesBySKUType_Call struct {
	*mock.Call
}

// QueryPricesBySKUType is a helper method to define mock.On call
//   - currentUser string
//   - req types.AcctPriceListReq
func (_e *MockAccountingClient_Expecter) QueryPricesBySKUType(currentUser interface{}, req interface{}) *MockAccountingClient_QueryPricesBySKUType_Call {
	return &MockAccountingClient_QueryPricesBySKUType_Call{Call: _e.mock.On("QueryPricesBySKUType", currentUser, req)}
}

func (_c *MockAccountingClient_QueryPricesBySKUType_Call) Run(run func(currentUser string, req types.AcctPriceListReq)) *MockAccountingClient_QueryPricesBySKUType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(types.AcctPriceListReq))
	})
	return _c
}

func (_c *MockAccountingClient_QueryPricesBySKUType_Call) Return(_a0 any, _a1 error) *MockAccountingClient_QueryPricesBySKUType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_QueryPricesBySKUType_Call) RunAndReturn(run func(string, types.AcctPriceListReq) (any, error)) *MockAccountingClient_QueryPricesBySKUType_Call {
	_c.Call.Return(run)
	return _c
}

// RechargeAccountingUser provides a mock function with given fields: userID, req
func (_m *MockAccountingClient) RechargeAccountingUser(userID string, req types.RechargeReq) (any, error) {
	ret := _m.Called(userID, req)

	if len(ret) == 0 {
		panic("no return value specified for RechargeAccountingUser")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.RechargeReq) (any, error)); ok {
		return rf(userID, req)
	}
	if rf, ok := ret.Get(0).(func(string, types.RechargeReq) any); ok {
		r0 = rf(userID, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, types.RechargeReq) error); ok {
		r1 = rf(userID, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_RechargeAccountingUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RechargeAccountingUser'
type MockAccountingClient_RechargeAccountingUser_Call struct {
	*mock.Call
}

// RechargeAccountingUser is a helper method to define mock.On call
//   - userID string
//   - req types.RechargeReq
func (_e *MockAccountingClient_Expecter) RechargeAccountingUser(userID interface{}, req interface{}) *MockAccountingClient_RechargeAccountingUser_Call {
	return &MockAccountingClient_RechargeAccountingUser_Call{Call: _e.mock.On("RechargeAccountingUser", userID, req)}
}

func (_c *MockAccountingClient_RechargeAccountingUser_Call) Run(run func(userID string, req types.RechargeReq)) *MockAccountingClient_RechargeAccountingUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(types.RechargeReq))
	})
	return _c
}

func (_c *MockAccountingClient_RechargeAccountingUser_Call) Return(_a0 any, _a1 error) *MockAccountingClient_RechargeAccountingUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_RechargeAccountingUser_Call) RunAndReturn(run func(string, types.RechargeReq) (any, error)) *MockAccountingClient_RechargeAccountingUser_Call {
	_c.Call.Return(run)
	return _c
}

// StatementsIndex provides a mock function with given fields: req
func (_m *MockAccountingClient) StatementsIndex(req types.ActStatementsReq) (any, error) {
	ret := _m.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for StatementsIndex")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(types.ActStatementsReq) (any, error)); ok {
		return rf(req)
	}
	if rf, ok := ret.Get(0).(func(types.ActStatementsReq) any); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(types.ActStatementsReq) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_StatementsIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatementsIndex'
type MockAccountingClient_StatementsIndex_Call struct {
	*mock.Call
}

// StatementsIndex is a helper method to define mock.On call
//   - req types.ActStatementsReq
func (_e *MockAccountingClient_Expecter) StatementsIndex(req interface{}) *MockAccountingClient_StatementsIndex_Call {
	return &MockAccountingClient_StatementsIndex_Call{Call: _e.mock.On("StatementsIndex", req)}
}

func (_c *MockAccountingClient_StatementsIndex_Call) Run(run func(req types.ActStatementsReq)) *MockAccountingClient_StatementsIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.ActStatementsReq))
	})
	return _c
}

func (_c *MockAccountingClient_StatementsIndex_Call) Return(_a0 any, _a1 error) *MockAccountingClient_StatementsIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_StatementsIndex_Call) RunAndReturn(run func(types.ActStatementsReq) (any, error)) *MockAccountingClient_StatementsIndex_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePrice provides a mock function with given fields: currentUser, req, id
func (_m *MockAccountingClient) UpdatePrice(currentUser string, req types.AcctPriceCreateReq, id int64) (any, error) {
	ret := _m.Called(currentUser, req, id)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePrice")
	}

	var r0 any
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.AcctPriceCreateReq, int64) (any, error)); ok {
		return rf(currentUser, req, id)
	}
	if rf, ok := ret.Get(0).(func(string, types.AcctPriceCreateReq, int64) any); ok {
		r0 = rf(currentUser, req, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}

	if rf, ok := ret.Get(1).(func(string, types.AcctPriceCreateReq, int64) error); ok {
		r1 = rf(currentUser, req, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAccountingClient_UpdatePrice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePrice'
type MockAccountingClient_UpdatePrice_Call struct {
	*mock.Call
}

// UpdatePrice is a helper method to define mock.On call
//   - currentUser string
//   - req types.AcctPriceCreateReq
//   - id int64
func (_e *MockAccountingClient_Expecter) UpdatePrice(currentUser interface{}, req interface{}, id interface{}) *MockAccountingClient_UpdatePrice_Call {
	return &MockAccountingClient_UpdatePrice_Call{Call: _e.mock.On("UpdatePrice", currentUser, req, id)}
}

func (_c *MockAccountingClient_UpdatePrice_Call) Run(run func(currentUser string, req types.AcctPriceCreateReq, id int64)) *MockAccountingClient_UpdatePrice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(types.AcctPriceCreateReq), args[2].(int64))
	})
	return _c
}

func (_c *MockAccountingClient_UpdatePrice_Call) Return(_a0 any, _a1 error) *MockAccountingClient_UpdatePrice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAccountingClient_UpdatePrice_Call) RunAndReturn(run func(string, types.AcctPriceCreateReq, int64) (any, error)) *MockAccountingClient_UpdatePrice_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccountingClient creates a new instance of MockAccountingClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountingClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountingClient {
	mock := &MockAccountingClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
