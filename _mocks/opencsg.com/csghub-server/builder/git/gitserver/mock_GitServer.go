// Code generated by mockery v2.53.0. DO NOT EDIT.

package gitserver

import (
	context "context"

	gitserver "opencsg.com/csghub-server/builder/git/gitserver"
	database "opencsg.com/csghub-server/builder/store/database"

	io "io"

	mock "github.com/stretchr/testify/mock"

	types "opencsg.com/csghub-server/common/types"
)

// MockGitServer is an autogenerated mock type for the GitServer type
type MockGitServer struct {
	mock.Mock
}

type MockGitServer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGitServer) EXPECT() *MockGitServer_Expecter {
	return &MockGitServer_Expecter{mock: &_m.Mock}
}

// CreateMirrorRepo provides a mock function with given fields: ctx, req
func (_m *MockGitServer) CreateMirrorRepo(ctx context.Context, req gitserver.CreateMirrorRepoReq) (int64, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateMirrorRepo")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.CreateMirrorRepoReq) (int64, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.CreateMirrorRepoReq) int64); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.CreateMirrorRepoReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_CreateMirrorRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMirrorRepo'
type MockGitServer_CreateMirrorRepo_Call struct {
	*mock.Call
}

// CreateMirrorRepo is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.CreateMirrorRepoReq
func (_e *MockGitServer_Expecter) CreateMirrorRepo(ctx interface{}, req interface{}) *MockGitServer_CreateMirrorRepo_Call {
	return &MockGitServer_CreateMirrorRepo_Call{Call: _e.mock.On("CreateMirrorRepo", ctx, req)}
}

func (_c *MockGitServer_CreateMirrorRepo_Call) Run(run func(ctx context.Context, req gitserver.CreateMirrorRepoReq)) *MockGitServer_CreateMirrorRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.CreateMirrorRepoReq))
	})
	return _c
}

func (_c *MockGitServer_CreateMirrorRepo_Call) Return(_a0 int64, _a1 error) *MockGitServer_CreateMirrorRepo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_CreateMirrorRepo_Call) RunAndReturn(run func(context.Context, gitserver.CreateMirrorRepoReq) (int64, error)) *MockGitServer_CreateMirrorRepo_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrganization provides a mock function with given fields: req, orgOwner
func (_m *MockGitServer) CreateOrganization(req *types.CreateOrgReq, orgOwner database.User) (*database.Organization, error) {
	ret := _m.Called(req, orgOwner)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrganization")
	}

	var r0 *database.Organization
	var r1 error
	if rf, ok := ret.Get(0).(func(*types.CreateOrgReq, database.User) (*database.Organization, error)); ok {
		return rf(req, orgOwner)
	}
	if rf, ok := ret.Get(0).(func(*types.CreateOrgReq, database.User) *database.Organization); ok {
		r0 = rf(req, orgOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Organization)
		}
	}

	if rf, ok := ret.Get(1).(func(*types.CreateOrgReq, database.User) error); ok {
		r1 = rf(req, orgOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_CreateOrganization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrganization'
type MockGitServer_CreateOrganization_Call struct {
	*mock.Call
}

// CreateOrganization is a helper method to define mock.On call
//   - req *types.CreateOrgReq
//   - orgOwner database.User
func (_e *MockGitServer_Expecter) CreateOrganization(req interface{}, orgOwner interface{}) *MockGitServer_CreateOrganization_Call {
	return &MockGitServer_CreateOrganization_Call{Call: _e.mock.On("CreateOrganization", req, orgOwner)}
}

func (_c *MockGitServer_CreateOrganization_Call) Run(run func(req *types.CreateOrgReq, orgOwner database.User)) *MockGitServer_CreateOrganization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.CreateOrgReq), args[1].(database.User))
	})
	return _c
}

func (_c *MockGitServer_CreateOrganization_Call) Return(_a0 *database.Organization, _a1 error) *MockGitServer_CreateOrganization_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_CreateOrganization_Call) RunAndReturn(run func(*types.CreateOrgReq, database.User) (*database.Organization, error)) *MockGitServer_CreateOrganization_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRepo provides a mock function with given fields: ctx, req
func (_m *MockGitServer) CreateRepo(ctx context.Context, req gitserver.CreateRepoReq) (*gitserver.CreateRepoResp, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepo")
	}

	var r0 *gitserver.CreateRepoResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.CreateRepoReq) (*gitserver.CreateRepoResp, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.CreateRepoReq) *gitserver.CreateRepoResp); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitserver.CreateRepoResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.CreateRepoReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_CreateRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRepo'
type MockGitServer_CreateRepo_Call struct {
	*mock.Call
}

// CreateRepo is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.CreateRepoReq
func (_e *MockGitServer_Expecter) CreateRepo(ctx interface{}, req interface{}) *MockGitServer_CreateRepo_Call {
	return &MockGitServer_CreateRepo_Call{Call: _e.mock.On("CreateRepo", ctx, req)}
}

func (_c *MockGitServer_CreateRepo_Call) Run(run func(ctx context.Context, req gitserver.CreateRepoReq)) *MockGitServer_CreateRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.CreateRepoReq))
	})
	return _c
}

func (_c *MockGitServer_CreateRepo_Call) Return(_a0 *gitserver.CreateRepoResp, _a1 error) *MockGitServer_CreateRepo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_CreateRepo_Call) RunAndReturn(run func(context.Context, gitserver.CreateRepoReq) (*gitserver.CreateRepoResp, error)) *MockGitServer_CreateRepo_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRepoFile provides a mock function with given fields: req
func (_m *MockGitServer) CreateRepoFile(req *types.CreateFileReq) error {
	ret := _m.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for CreateRepoFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.CreateFileReq) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_CreateRepoFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRepoFile'
type MockGitServer_CreateRepoFile_Call struct {
	*mock.Call
}

// CreateRepoFile is a helper method to define mock.On call
//   - req *types.CreateFileReq
func (_e *MockGitServer_Expecter) CreateRepoFile(req interface{}) *MockGitServer_CreateRepoFile_Call {
	return &MockGitServer_CreateRepoFile_Call{Call: _e.mock.On("CreateRepoFile", req)}
}

func (_c *MockGitServer_CreateRepoFile_Call) Run(run func(req *types.CreateFileReq)) *MockGitServer_CreateRepoFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.CreateFileReq))
	})
	return _c
}

func (_c *MockGitServer_CreateRepoFile_Call) Return(err error) *MockGitServer_CreateRepoFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockGitServer_CreateRepoFile_Call) RunAndReturn(run func(*types.CreateFileReq) error) *MockGitServer_CreateRepoFile_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSSHKey provides a mock function with given fields: _a0
func (_m *MockGitServer) CreateSSHKey(_a0 *types.CreateSSHKeyRequest) (*database.SSHKey, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for CreateSSHKey")
	}

	var r0 *database.SSHKey
	var r1 error
	if rf, ok := ret.Get(0).(func(*types.CreateSSHKeyRequest) (*database.SSHKey, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*types.CreateSSHKeyRequest) *database.SSHKey); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(*types.CreateSSHKeyRequest) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_CreateSSHKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSSHKey'
type MockGitServer_CreateSSHKey_Call struct {
	*mock.Call
}

// CreateSSHKey is a helper method to define mock.On call
//   - _a0 *types.CreateSSHKeyRequest
func (_e *MockGitServer_Expecter) CreateSSHKey(_a0 interface{}) *MockGitServer_CreateSSHKey_Call {
	return &MockGitServer_CreateSSHKey_Call{Call: _e.mock.On("CreateSSHKey", _a0)}
}

func (_c *MockGitServer_CreateSSHKey_Call) Run(run func(_a0 *types.CreateSSHKeyRequest)) *MockGitServer_CreateSSHKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.CreateSSHKeyRequest))
	})
	return _c
}

func (_c *MockGitServer_CreateSSHKey_Call) Return(_a0 *database.SSHKey, _a1 error) *MockGitServer_CreateSSHKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_CreateSSHKey_Call) RunAndReturn(run func(*types.CreateSSHKeyRequest) (*database.SSHKey, error)) *MockGitServer_CreateSSHKey_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: _a0
func (_m *MockGitServer) CreateUser(_a0 gitserver.CreateUserRequest) (*gitserver.CreateUserResponse, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *gitserver.CreateUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(gitserver.CreateUserRequest) (*gitserver.CreateUserResponse, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(gitserver.CreateUserRequest) *gitserver.CreateUserResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitserver.CreateUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(gitserver.CreateUserRequest) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockGitServer_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - _a0 gitserver.CreateUserRequest
func (_e *MockGitServer_Expecter) CreateUser(_a0 interface{}) *MockGitServer_CreateUser_Call {
	return &MockGitServer_CreateUser_Call{Call: _e.mock.On("CreateUser", _a0)}
}

func (_c *MockGitServer_CreateUser_Call) Run(run func(_a0 gitserver.CreateUserRequest)) *MockGitServer_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gitserver.CreateUserRequest))
	})
	return _c
}

func (_c *MockGitServer_CreateUser_Call) Return(_a0 *gitserver.CreateUserResponse, _a1 error) *MockGitServer_CreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_CreateUser_Call) RunAndReturn(run func(gitserver.CreateUserRequest) (*gitserver.CreateUserResponse, error)) *MockGitServer_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUserToken provides a mock function with given fields: _a0
func (_m *MockGitServer) CreateUserToken(_a0 *types.CreateUserTokenRequest) (*database.AccessToken, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for CreateUserToken")
	}

	var r0 *database.AccessToken
	var r1 error
	if rf, ok := ret.Get(0).(func(*types.CreateUserTokenRequest) (*database.AccessToken, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(*types.CreateUserTokenRequest) *database.AccessToken); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.AccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(*types.CreateUserTokenRequest) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_CreateUserToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUserToken'
type MockGitServer_CreateUserToken_Call struct {
	*mock.Call
}

// CreateUserToken is a helper method to define mock.On call
//   - _a0 *types.CreateUserTokenRequest
func (_e *MockGitServer_Expecter) CreateUserToken(_a0 interface{}) *MockGitServer_CreateUserToken_Call {
	return &MockGitServer_CreateUserToken_Call{Call: _e.mock.On("CreateUserToken", _a0)}
}

func (_c *MockGitServer_CreateUserToken_Call) Run(run func(_a0 *types.CreateUserTokenRequest)) *MockGitServer_CreateUserToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.CreateUserTokenRequest))
	})
	return _c
}

func (_c *MockGitServer_CreateUserToken_Call) Return(_a0 *database.AccessToken, _a1 error) *MockGitServer_CreateUserToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_CreateUserToken_Call) RunAndReturn(run func(*types.CreateUserTokenRequest) (*database.AccessToken, error)) *MockGitServer_CreateUserToken_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteOrganization provides a mock function with given fields: _a0
func (_m *MockGitServer) DeleteOrganization(_a0 string) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOrganization")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_DeleteOrganization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteOrganization'
type MockGitServer_DeleteOrganization_Call struct {
	*mock.Call
}

// DeleteOrganization is a helper method to define mock.On call
//   - _a0 string
func (_e *MockGitServer_Expecter) DeleteOrganization(_a0 interface{}) *MockGitServer_DeleteOrganization_Call {
	return &MockGitServer_DeleteOrganization_Call{Call: _e.mock.On("DeleteOrganization", _a0)}
}

func (_c *MockGitServer_DeleteOrganization_Call) Run(run func(_a0 string)) *MockGitServer_DeleteOrganization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGitServer_DeleteOrganization_Call) Return(_a0 error) *MockGitServer_DeleteOrganization_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_DeleteOrganization_Call) RunAndReturn(run func(string) error) *MockGitServer_DeleteOrganization_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRepo provides a mock function with given fields: ctx, req
func (_m *MockGitServer) DeleteRepo(ctx context.Context, req gitserver.DeleteRepoReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepo")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.DeleteRepoReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_DeleteRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRepo'
type MockGitServer_DeleteRepo_Call struct {
	*mock.Call
}

// DeleteRepo is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.DeleteRepoReq
func (_e *MockGitServer_Expecter) DeleteRepo(ctx interface{}, req interface{}) *MockGitServer_DeleteRepo_Call {
	return &MockGitServer_DeleteRepo_Call{Call: _e.mock.On("DeleteRepo", ctx, req)}
}

func (_c *MockGitServer_DeleteRepo_Call) Run(run func(ctx context.Context, req gitserver.DeleteRepoReq)) *MockGitServer_DeleteRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.DeleteRepoReq))
	})
	return _c
}

func (_c *MockGitServer_DeleteRepo_Call) Return(_a0 error) *MockGitServer_DeleteRepo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_DeleteRepo_Call) RunAndReturn(run func(context.Context, gitserver.DeleteRepoReq) error) *MockGitServer_DeleteRepo_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRepoBranch provides a mock function with given fields: ctx, req
func (_m *MockGitServer) DeleteRepoBranch(ctx context.Context, req gitserver.DeleteBranchReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepoBranch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.DeleteBranchReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_DeleteRepoBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRepoBranch'
type MockGitServer_DeleteRepoBranch_Call struct {
	*mock.Call
}

// DeleteRepoBranch is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.DeleteBranchReq
func (_e *MockGitServer_Expecter) DeleteRepoBranch(ctx interface{}, req interface{}) *MockGitServer_DeleteRepoBranch_Call {
	return &MockGitServer_DeleteRepoBranch_Call{Call: _e.mock.On("DeleteRepoBranch", ctx, req)}
}

func (_c *MockGitServer_DeleteRepoBranch_Call) Run(run func(ctx context.Context, req gitserver.DeleteBranchReq)) *MockGitServer_DeleteRepoBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.DeleteBranchReq))
	})
	return _c
}

func (_c *MockGitServer_DeleteRepoBranch_Call) Return(_a0 error) *MockGitServer_DeleteRepoBranch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_DeleteRepoBranch_Call) RunAndReturn(run func(context.Context, gitserver.DeleteBranchReq) error) *MockGitServer_DeleteRepoBranch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRepoFile provides a mock function with given fields: req
func (_m *MockGitServer) DeleteRepoFile(req *types.DeleteFileReq) error {
	ret := _m.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRepoFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.DeleteFileReq) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_DeleteRepoFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRepoFile'
type MockGitServer_DeleteRepoFile_Call struct {
	*mock.Call
}

// DeleteRepoFile is a helper method to define mock.On call
//   - req *types.DeleteFileReq
func (_e *MockGitServer_Expecter) DeleteRepoFile(req interface{}) *MockGitServer_DeleteRepoFile_Call {
	return &MockGitServer_DeleteRepoFile_Call{Call: _e.mock.On("DeleteRepoFile", req)}
}

func (_c *MockGitServer_DeleteRepoFile_Call) Run(run func(req *types.DeleteFileReq)) *MockGitServer_DeleteRepoFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.DeleteFileReq))
	})
	return _c
}

func (_c *MockGitServer_DeleteRepoFile_Call) Return(err error) *MockGitServer_DeleteRepoFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockGitServer_DeleteRepoFile_Call) RunAndReturn(run func(*types.DeleteFileReq) error) *MockGitServer_DeleteRepoFile_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSSHKey provides a mock function with given fields: _a0
func (_m *MockGitServer) DeleteSSHKey(_a0 int) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSSHKey")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_DeleteSSHKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSSHKey'
type MockGitServer_DeleteSSHKey_Call struct {
	*mock.Call
}

// DeleteSSHKey is a helper method to define mock.On call
//   - _a0 int
func (_e *MockGitServer_Expecter) DeleteSSHKey(_a0 interface{}) *MockGitServer_DeleteSSHKey_Call {
	return &MockGitServer_DeleteSSHKey_Call{Call: _e.mock.On("DeleteSSHKey", _a0)}
}

func (_c *MockGitServer_DeleteSSHKey_Call) Run(run func(_a0 int)) *MockGitServer_DeleteSSHKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *MockGitServer_DeleteSSHKey_Call) Return(_a0 error) *MockGitServer_DeleteSSHKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_DeleteSSHKey_Call) RunAndReturn(run func(int) error) *MockGitServer_DeleteSSHKey_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUserToken provides a mock function with given fields: _a0
func (_m *MockGitServer) DeleteUserToken(_a0 *types.DeleteUserTokenRequest) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUserToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.DeleteUserTokenRequest) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_DeleteUserToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUserToken'
type MockGitServer_DeleteUserToken_Call struct {
	*mock.Call
}

// DeleteUserToken is a helper method to define mock.On call
//   - _a0 *types.DeleteUserTokenRequest
func (_e *MockGitServer_Expecter) DeleteUserToken(_a0 interface{}) *MockGitServer_DeleteUserToken_Call {
	return &MockGitServer_DeleteUserToken_Call{Call: _e.mock.On("DeleteUserToken", _a0)}
}

func (_c *MockGitServer_DeleteUserToken_Call) Run(run func(_a0 *types.DeleteUserTokenRequest)) *MockGitServer_DeleteUserToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.DeleteUserTokenRequest))
	})
	return _c
}

func (_c *MockGitServer_DeleteUserToken_Call) Return(_a0 error) *MockGitServer_DeleteUserToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_DeleteUserToken_Call) RunAndReturn(run func(*types.DeleteUserTokenRequest) error) *MockGitServer_DeleteUserToken_Call {
	_c.Call.Return(run)
	return _c
}

// FixOrganization provides a mock function with given fields: req, orgOwner
func (_m *MockGitServer) FixOrganization(req *types.CreateOrgReq, orgOwner database.User) error {
	ret := _m.Called(req, orgOwner)

	if len(ret) == 0 {
		panic("no return value specified for FixOrganization")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.CreateOrgReq, database.User) error); ok {
		r0 = rf(req, orgOwner)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_FixOrganization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FixOrganization'
type MockGitServer_FixOrganization_Call struct {
	*mock.Call
}

// FixOrganization is a helper method to define mock.On call
//   - req *types.CreateOrgReq
//   - orgOwner database.User
func (_e *MockGitServer_Expecter) FixOrganization(req interface{}, orgOwner interface{}) *MockGitServer_FixOrganization_Call {
	return &MockGitServer_FixOrganization_Call{Call: _e.mock.On("FixOrganization", req, orgOwner)}
}

func (_c *MockGitServer_FixOrganization_Call) Run(run func(req *types.CreateOrgReq, orgOwner database.User)) *MockGitServer_FixOrganization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.CreateOrgReq), args[1].(database.User))
	})
	return _c
}

func (_c *MockGitServer_FixOrganization_Call) Return(_a0 error) *MockGitServer_FixOrganization_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_FixOrganization_Call) RunAndReturn(run func(*types.CreateOrgReq, database.User) error) *MockGitServer_FixOrganization_Call {
	_c.Call.Return(run)
	return _c
}

// FixUserData provides a mock function with given fields: ctx, userName
func (_m *MockGitServer) FixUserData(ctx context.Context, userName string) error {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for FixUserData")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, userName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_FixUserData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FixUserData'
type MockGitServer_FixUserData_Call struct {
	*mock.Call
}

// FixUserData is a helper method to define mock.On call
//   - ctx context.Context
//   - userName string
func (_e *MockGitServer_Expecter) FixUserData(ctx interface{}, userName interface{}) *MockGitServer_FixUserData_Call {
	return &MockGitServer_FixUserData_Call{Call: _e.mock.On("FixUserData", ctx, userName)}
}

func (_c *MockGitServer_FixUserData_Call) Run(run func(ctx context.Context, userName string)) *MockGitServer_FixUserData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGitServer_FixUserData_Call) Return(_a0 error) *MockGitServer_FixUserData_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_FixUserData_Call) RunAndReturn(run func(context.Context, string) error) *MockGitServer_FixUserData_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommitDiff provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetCommitDiff(ctx context.Context, req gitserver.GetRepoLastCommitReq) ([]byte, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitDiff")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoLastCommitReq) ([]byte, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoLastCommitReq) []byte); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoLastCommitReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetCommitDiff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommitDiff'
type MockGitServer_GetCommitDiff_Call struct {
	*mock.Call
}

// GetCommitDiff is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoLastCommitReq
func (_e *MockGitServer_Expecter) GetCommitDiff(ctx interface{}, req interface{}) *MockGitServer_GetCommitDiff_Call {
	return &MockGitServer_GetCommitDiff_Call{Call: _e.mock.On("GetCommitDiff", ctx, req)}
}

func (_c *MockGitServer_GetCommitDiff_Call) Run(run func(ctx context.Context, req gitserver.GetRepoLastCommitReq)) *MockGitServer_GetCommitDiff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoLastCommitReq))
	})
	return _c
}

func (_c *MockGitServer_GetCommitDiff_Call) Return(_a0 []byte, _a1 error) *MockGitServer_GetCommitDiff_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetCommitDiff_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoLastCommitReq) ([]byte, error)) *MockGitServer_GetCommitDiff_Call {
	_c.Call.Return(run)
	return _c
}

// GetDiffBetweenTwoCommits provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetDiffBetweenTwoCommits(ctx context.Context, req gitserver.GetDiffBetweenTwoCommitsReq) (*types.GiteaCallbackPushReq, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetDiffBetweenTwoCommits")
	}

	var r0 *types.GiteaCallbackPushReq
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetDiffBetweenTwoCommitsReq) (*types.GiteaCallbackPushReq, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetDiffBetweenTwoCommitsReq) *types.GiteaCallbackPushReq); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.GiteaCallbackPushReq)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetDiffBetweenTwoCommitsReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetDiffBetweenTwoCommits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDiffBetweenTwoCommits'
type MockGitServer_GetDiffBetweenTwoCommits_Call struct {
	*mock.Call
}

// GetDiffBetweenTwoCommits is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetDiffBetweenTwoCommitsReq
func (_e *MockGitServer_Expecter) GetDiffBetweenTwoCommits(ctx interface{}, req interface{}) *MockGitServer_GetDiffBetweenTwoCommits_Call {
	return &MockGitServer_GetDiffBetweenTwoCommits_Call{Call: _e.mock.On("GetDiffBetweenTwoCommits", ctx, req)}
}

func (_c *MockGitServer_GetDiffBetweenTwoCommits_Call) Run(run func(ctx context.Context, req gitserver.GetDiffBetweenTwoCommitsReq)) *MockGitServer_GetDiffBetweenTwoCommits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetDiffBetweenTwoCommitsReq))
	})
	return _c
}

func (_c *MockGitServer_GetDiffBetweenTwoCommits_Call) Return(_a0 *types.GiteaCallbackPushReq, _a1 error) *MockGitServer_GetDiffBetweenTwoCommits_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetDiffBetweenTwoCommits_Call) RunAndReturn(run func(context.Context, gitserver.GetDiffBetweenTwoCommitsReq) (*types.GiteaCallbackPushReq, error)) *MockGitServer_GetDiffBetweenTwoCommits_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogsTree provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetLogsTree(ctx context.Context, req types.GetLogsTreeRequest) (*types.LogsTreeResp, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetLogsTree")
	}

	var r0 *types.LogsTreeResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.GetLogsTreeRequest) (*types.LogsTreeResp, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.GetLogsTreeRequest) *types.LogsTreeResp); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.LogsTreeResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.GetLogsTreeRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetLogsTree_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsTree'
type MockGitServer_GetLogsTree_Call struct {
	*mock.Call
}

// GetLogsTree is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.GetLogsTreeRequest
func (_e *MockGitServer_Expecter) GetLogsTree(ctx interface{}, req interface{}) *MockGitServer_GetLogsTree_Call {
	return &MockGitServer_GetLogsTree_Call{Call: _e.mock.On("GetLogsTree", ctx, req)}
}

func (_c *MockGitServer_GetLogsTree_Call) Run(run func(ctx context.Context, req types.GetLogsTreeRequest)) *MockGitServer_GetLogsTree_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.GetLogsTreeRequest))
	})
	return _c
}

func (_c *MockGitServer_GetLogsTree_Call) Return(_a0 *types.LogsTreeResp, _a1 error) *MockGitServer_GetLogsTree_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetLogsTree_Call) RunAndReturn(run func(context.Context, types.GetLogsTreeRequest) (*types.LogsTreeResp, error)) *MockGitServer_GetLogsTree_Call {
	_c.Call.Return(run)
	return _c
}

// GetMirrorTaskInfo provides a mock function with given fields: ctx, taskId
func (_m *MockGitServer) GetMirrorTaskInfo(ctx context.Context, taskId int64) (*gitserver.MirrorTaskInfo, error) {
	ret := _m.Called(ctx, taskId)

	if len(ret) == 0 {
		panic("no return value specified for GetMirrorTaskInfo")
	}

	var r0 *gitserver.MirrorTaskInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*gitserver.MirrorTaskInfo, error)); ok {
		return rf(ctx, taskId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *gitserver.MirrorTaskInfo); ok {
		r0 = rf(ctx, taskId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitserver.MirrorTaskInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, taskId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetMirrorTaskInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMirrorTaskInfo'
type MockGitServer_GetMirrorTaskInfo_Call struct {
	*mock.Call
}

// GetMirrorTaskInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - taskId int64
func (_e *MockGitServer_Expecter) GetMirrorTaskInfo(ctx interface{}, taskId interface{}) *MockGitServer_GetMirrorTaskInfo_Call {
	return &MockGitServer_GetMirrorTaskInfo_Call{Call: _e.mock.On("GetMirrorTaskInfo", ctx, taskId)}
}

func (_c *MockGitServer_GetMirrorTaskInfo_Call) Run(run func(ctx context.Context, taskId int64)) *MockGitServer_GetMirrorTaskInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockGitServer_GetMirrorTaskInfo_Call) Return(_a0 *gitserver.MirrorTaskInfo, _a1 error) *MockGitServer_GetMirrorTaskInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetMirrorTaskInfo_Call) RunAndReturn(run func(context.Context, int64) (*gitserver.MirrorTaskInfo, error)) *MockGitServer_GetMirrorTaskInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepo provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepo(ctx context.Context, req gitserver.GetRepoReq) (*gitserver.CreateRepoResp, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepo")
	}

	var r0 *gitserver.CreateRepoResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoReq) (*gitserver.CreateRepoResp, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoReq) *gitserver.CreateRepoResp); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitserver.CreateRepoResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepo'
type MockGitServer_GetRepo_Call struct {
	*mock.Call
}

// GetRepo is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoReq
func (_e *MockGitServer_Expecter) GetRepo(ctx interface{}, req interface{}) *MockGitServer_GetRepo_Call {
	return &MockGitServer_GetRepo_Call{Call: _e.mock.On("GetRepo", ctx, req)}
}

func (_c *MockGitServer_GetRepo_Call) Run(run func(ctx context.Context, req gitserver.GetRepoReq)) *MockGitServer_GetRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepo_Call) Return(_a0 *gitserver.CreateRepoResp, _a1 error) *MockGitServer_GetRepo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepo_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoReq) (*gitserver.CreateRepoResp, error)) *MockGitServer_GetRepo_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoAllFiles provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoAllFiles(ctx context.Context, req gitserver.GetRepoAllFilesReq) ([]*types.File, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoAllFiles")
	}

	var r0 []*types.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoAllFilesReq) ([]*types.File, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoAllFilesReq) []*types.File); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoAllFilesReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepoAllFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoAllFiles'
type MockGitServer_GetRepoAllFiles_Call struct {
	*mock.Call
}

// GetRepoAllFiles is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoAllFilesReq
func (_e *MockGitServer_Expecter) GetRepoAllFiles(ctx interface{}, req interface{}) *MockGitServer_GetRepoAllFiles_Call {
	return &MockGitServer_GetRepoAllFiles_Call{Call: _e.mock.On("GetRepoAllFiles", ctx, req)}
}

func (_c *MockGitServer_GetRepoAllFiles_Call) Run(run func(ctx context.Context, req gitserver.GetRepoAllFilesReq)) *MockGitServer_GetRepoAllFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoAllFilesReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoAllFiles_Call) Return(_a0 []*types.File, _a1 error) *MockGitServer_GetRepoAllFiles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepoAllFiles_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoAllFilesReq) ([]*types.File, error)) *MockGitServer_GetRepoAllFiles_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoAllLfsPointers provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoAllLfsPointers(ctx context.Context, req gitserver.GetRepoAllFilesReq) ([]*types.LFSPointer, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoAllLfsPointers")
	}

	var r0 []*types.LFSPointer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoAllFilesReq) ([]*types.LFSPointer, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoAllFilesReq) []*types.LFSPointer); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.LFSPointer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoAllFilesReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepoAllLfsPointers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoAllLfsPointers'
type MockGitServer_GetRepoAllLfsPointers_Call struct {
	*mock.Call
}

// GetRepoAllLfsPointers is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoAllFilesReq
func (_e *MockGitServer_Expecter) GetRepoAllLfsPointers(ctx interface{}, req interface{}) *MockGitServer_GetRepoAllLfsPointers_Call {
	return &MockGitServer_GetRepoAllLfsPointers_Call{Call: _e.mock.On("GetRepoAllLfsPointers", ctx, req)}
}

func (_c *MockGitServer_GetRepoAllLfsPointers_Call) Run(run func(ctx context.Context, req gitserver.GetRepoAllFilesReq)) *MockGitServer_GetRepoAllLfsPointers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoAllFilesReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoAllLfsPointers_Call) Return(_a0 []*types.LFSPointer, _a1 error) *MockGitServer_GetRepoAllLfsPointers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepoAllLfsPointers_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoAllFilesReq) ([]*types.LFSPointer, error)) *MockGitServer_GetRepoAllLfsPointers_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoBranchByName provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoBranchByName(ctx context.Context, req gitserver.GetBranchReq) (*types.Branch, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoBranchByName")
	}

	var r0 *types.Branch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetBranchReq) (*types.Branch, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetBranchReq) *types.Branch); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Branch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetBranchReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepoBranchByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoBranchByName'
type MockGitServer_GetRepoBranchByName_Call struct {
	*mock.Call
}

// GetRepoBranchByName is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetBranchReq
func (_e *MockGitServer_Expecter) GetRepoBranchByName(ctx interface{}, req interface{}) *MockGitServer_GetRepoBranchByName_Call {
	return &MockGitServer_GetRepoBranchByName_Call{Call: _e.mock.On("GetRepoBranchByName", ctx, req)}
}

func (_c *MockGitServer_GetRepoBranchByName_Call) Run(run func(ctx context.Context, req gitserver.GetBranchReq)) *MockGitServer_GetRepoBranchByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetBranchReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoBranchByName_Call) Return(_a0 *types.Branch, _a1 error) *MockGitServer_GetRepoBranchByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepoBranchByName_Call) RunAndReturn(run func(context.Context, gitserver.GetBranchReq) (*types.Branch, error)) *MockGitServer_GetRepoBranchByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoBranches provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoBranches(ctx context.Context, req gitserver.GetBranchesReq) ([]types.Branch, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoBranches")
	}

	var r0 []types.Branch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetBranchesReq) ([]types.Branch, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetBranchesReq) []types.Branch); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Branch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetBranchesReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepoBranches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoBranches'
type MockGitServer_GetRepoBranches_Call struct {
	*mock.Call
}

// GetRepoBranches is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetBranchesReq
func (_e *MockGitServer_Expecter) GetRepoBranches(ctx interface{}, req interface{}) *MockGitServer_GetRepoBranches_Call {
	return &MockGitServer_GetRepoBranches_Call{Call: _e.mock.On("GetRepoBranches", ctx, req)}
}

func (_c *MockGitServer_GetRepoBranches_Call) Run(run func(ctx context.Context, req gitserver.GetBranchesReq)) *MockGitServer_GetRepoBranches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetBranchesReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoBranches_Call) Return(_a0 []types.Branch, _a1 error) *MockGitServer_GetRepoBranches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepoBranches_Call) RunAndReturn(run func(context.Context, gitserver.GetBranchesReq) ([]types.Branch, error)) *MockGitServer_GetRepoBranches_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoCommits provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoCommits(ctx context.Context, req gitserver.GetRepoCommitsReq) ([]types.Commit, *types.RepoPageOpts, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoCommits")
	}

	var r0 []types.Commit
	var r1 *types.RepoPageOpts
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoCommitsReq) ([]types.Commit, *types.RepoPageOpts, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoCommitsReq) []types.Commit); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoCommitsReq) *types.RepoPageOpts); ok {
		r1 = rf(ctx, req)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*types.RepoPageOpts)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, gitserver.GetRepoCommitsReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockGitServer_GetRepoCommits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoCommits'
type MockGitServer_GetRepoCommits_Call struct {
	*mock.Call
}

// GetRepoCommits is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoCommitsReq
func (_e *MockGitServer_Expecter) GetRepoCommits(ctx interface{}, req interface{}) *MockGitServer_GetRepoCommits_Call {
	return &MockGitServer_GetRepoCommits_Call{Call: _e.mock.On("GetRepoCommits", ctx, req)}
}

func (_c *MockGitServer_GetRepoCommits_Call) Run(run func(ctx context.Context, req gitserver.GetRepoCommitsReq)) *MockGitServer_GetRepoCommits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoCommitsReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoCommits_Call) Return(_a0 []types.Commit, _a1 *types.RepoPageOpts, _a2 error) *MockGitServer_GetRepoCommits_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockGitServer_GetRepoCommits_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoCommitsReq) ([]types.Commit, *types.RepoPageOpts, error)) *MockGitServer_GetRepoCommits_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoFileContents provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoFileContents(ctx context.Context, req gitserver.GetRepoInfoByPathReq) (*types.File, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoFileContents")
	}

	var r0 *types.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) (*types.File, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) *types.File); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoInfoByPathReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepoFileContents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoFileContents'
type MockGitServer_GetRepoFileContents_Call struct {
	*mock.Call
}

// GetRepoFileContents is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoInfoByPathReq
func (_e *MockGitServer_Expecter) GetRepoFileContents(ctx interface{}, req interface{}) *MockGitServer_GetRepoFileContents_Call {
	return &MockGitServer_GetRepoFileContents_Call{Call: _e.mock.On("GetRepoFileContents", ctx, req)}
}

func (_c *MockGitServer_GetRepoFileContents_Call) Run(run func(ctx context.Context, req gitserver.GetRepoInfoByPathReq)) *MockGitServer_GetRepoFileContents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoInfoByPathReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoFileContents_Call) Return(_a0 *types.File, _a1 error) *MockGitServer_GetRepoFileContents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepoFileContents_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoInfoByPathReq) (*types.File, error)) *MockGitServer_GetRepoFileContents_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoFileRaw provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoFileRaw(ctx context.Context, req gitserver.GetRepoInfoByPathReq) (string, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoFileRaw")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) (string, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) string); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoInfoByPathReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepoFileRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoFileRaw'
type MockGitServer_GetRepoFileRaw_Call struct {
	*mock.Call
}

// GetRepoFileRaw is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoInfoByPathReq
func (_e *MockGitServer_Expecter) GetRepoFileRaw(ctx interface{}, req interface{}) *MockGitServer_GetRepoFileRaw_Call {
	return &MockGitServer_GetRepoFileRaw_Call{Call: _e.mock.On("GetRepoFileRaw", ctx, req)}
}

func (_c *MockGitServer_GetRepoFileRaw_Call) Run(run func(ctx context.Context, req gitserver.GetRepoInfoByPathReq)) *MockGitServer_GetRepoFileRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoInfoByPathReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoFileRaw_Call) Return(_a0 string, _a1 error) *MockGitServer_GetRepoFileRaw_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepoFileRaw_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoInfoByPathReq) (string, error)) *MockGitServer_GetRepoFileRaw_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoFileReader provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoFileReader(ctx context.Context, req gitserver.GetRepoInfoByPathReq) (io.ReadCloser, int64, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoFileReader")
	}

	var r0 io.ReadCloser
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) (io.ReadCloser, int64, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) io.ReadCloser); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoInfoByPathReq) int64); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(context.Context, gitserver.GetRepoInfoByPathReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockGitServer_GetRepoFileReader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoFileReader'
type MockGitServer_GetRepoFileReader_Call struct {
	*mock.Call
}

// GetRepoFileReader is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoInfoByPathReq
func (_e *MockGitServer_Expecter) GetRepoFileReader(ctx interface{}, req interface{}) *MockGitServer_GetRepoFileReader_Call {
	return &MockGitServer_GetRepoFileReader_Call{Call: _e.mock.On("GetRepoFileReader", ctx, req)}
}

func (_c *MockGitServer_GetRepoFileReader_Call) Run(run func(ctx context.Context, req gitserver.GetRepoInfoByPathReq)) *MockGitServer_GetRepoFileReader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoInfoByPathReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoFileReader_Call) Return(_a0 io.ReadCloser, _a1 int64, _a2 error) *MockGitServer_GetRepoFileReader_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockGitServer_GetRepoFileReader_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoInfoByPathReq) (io.ReadCloser, int64, error)) *MockGitServer_GetRepoFileReader_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoFileTree provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoFileTree(ctx context.Context, req gitserver.GetRepoInfoByPathReq) ([]*types.File, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoFileTree")
	}

	var r0 []*types.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) ([]*types.File, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) []*types.File); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoInfoByPathReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepoFileTree_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoFileTree'
type MockGitServer_GetRepoFileTree_Call struct {
	*mock.Call
}

// GetRepoFileTree is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoInfoByPathReq
func (_e *MockGitServer_Expecter) GetRepoFileTree(ctx interface{}, req interface{}) *MockGitServer_GetRepoFileTree_Call {
	return &MockGitServer_GetRepoFileTree_Call{Call: _e.mock.On("GetRepoFileTree", ctx, req)}
}

func (_c *MockGitServer_GetRepoFileTree_Call) Run(run func(ctx context.Context, req gitserver.GetRepoInfoByPathReq)) *MockGitServer_GetRepoFileTree_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoInfoByPathReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoFileTree_Call) Return(_a0 []*types.File, _a1 error) *MockGitServer_GetRepoFileTree_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepoFileTree_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoInfoByPathReq) ([]*types.File, error)) *MockGitServer_GetRepoFileTree_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoLastCommit provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoLastCommit(ctx context.Context, req gitserver.GetRepoLastCommitReq) (*types.Commit, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoLastCommit")
	}

	var r0 *types.Commit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoLastCommitReq) (*types.Commit, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoLastCommitReq) *types.Commit); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoLastCommitReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepoLastCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoLastCommit'
type MockGitServer_GetRepoLastCommit_Call struct {
	*mock.Call
}

// GetRepoLastCommit is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoLastCommitReq
func (_e *MockGitServer_Expecter) GetRepoLastCommit(ctx interface{}, req interface{}) *MockGitServer_GetRepoLastCommit_Call {
	return &MockGitServer_GetRepoLastCommit_Call{Call: _e.mock.On("GetRepoLastCommit", ctx, req)}
}

func (_c *MockGitServer_GetRepoLastCommit_Call) Run(run func(ctx context.Context, req gitserver.GetRepoLastCommitReq)) *MockGitServer_GetRepoLastCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoLastCommitReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoLastCommit_Call) Return(_a0 *types.Commit, _a1 error) *MockGitServer_GetRepoLastCommit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepoLastCommit_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoLastCommitReq) (*types.Commit, error)) *MockGitServer_GetRepoLastCommit_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoLfsFileRaw provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetRepoLfsFileRaw(ctx context.Context, req gitserver.GetRepoInfoByPathReq) (io.ReadCloser, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoLfsFileRaw")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) (io.ReadCloser, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoInfoByPathReq) io.ReadCloser); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoInfoByPathReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetRepoLfsFileRaw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoLfsFileRaw'
type MockGitServer_GetRepoLfsFileRaw_Call struct {
	*mock.Call
}

// GetRepoLfsFileRaw is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoInfoByPathReq
func (_e *MockGitServer_Expecter) GetRepoLfsFileRaw(ctx interface{}, req interface{}) *MockGitServer_GetRepoLfsFileRaw_Call {
	return &MockGitServer_GetRepoLfsFileRaw_Call{Call: _e.mock.On("GetRepoLfsFileRaw", ctx, req)}
}

func (_c *MockGitServer_GetRepoLfsFileRaw_Call) Run(run func(ctx context.Context, req gitserver.GetRepoInfoByPathReq)) *MockGitServer_GetRepoLfsFileRaw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoInfoByPathReq))
	})
	return _c
}

func (_c *MockGitServer_GetRepoLfsFileRaw_Call) Return(_a0 io.ReadCloser, _a1 error) *MockGitServer_GetRepoLfsFileRaw_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetRepoLfsFileRaw_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoInfoByPathReq) (io.ReadCloser, error)) *MockGitServer_GetRepoLfsFileRaw_Call {
	_c.Call.Return(run)
	return _c
}

// GetSingleCommit provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetSingleCommit(ctx context.Context, req gitserver.GetRepoLastCommitReq) (*types.CommitResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetSingleCommit")
	}

	var r0 *types.CommitResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoLastCommitReq) (*types.CommitResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.GetRepoLastCommitReq) *types.CommitResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CommitResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.GetRepoLastCommitReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetSingleCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSingleCommit'
type MockGitServer_GetSingleCommit_Call struct {
	*mock.Call
}

// GetSingleCommit is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.GetRepoLastCommitReq
func (_e *MockGitServer_Expecter) GetSingleCommit(ctx interface{}, req interface{}) *MockGitServer_GetSingleCommit_Call {
	return &MockGitServer_GetSingleCommit_Call{Call: _e.mock.On("GetSingleCommit", ctx, req)}
}

func (_c *MockGitServer_GetSingleCommit_Call) Run(run func(ctx context.Context, req gitserver.GetRepoLastCommitReq)) *MockGitServer_GetSingleCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.GetRepoLastCommitReq))
	})
	return _c
}

func (_c *MockGitServer_GetSingleCommit_Call) Return(_a0 *types.CommitResponse, _a1 error) *MockGitServer_GetSingleCommit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetSingleCommit_Call) RunAndReturn(run func(context.Context, gitserver.GetRepoLastCommitReq) (*types.CommitResponse, error)) *MockGitServer_GetSingleCommit_Call {
	_c.Call.Return(run)
	return _c
}

// GetTree provides a mock function with given fields: ctx, req
func (_m *MockGitServer) GetTree(ctx context.Context, req types.GetTreeRequest) (*types.GetRepoFileTreeResp, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetTree")
	}

	var r0 *types.GetRepoFileTreeResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.GetTreeRequest) (*types.GetRepoFileTreeResp, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.GetTreeRequest) *types.GetRepoFileTreeResp); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.GetRepoFileTreeResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.GetTreeRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_GetTree_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTree'
type MockGitServer_GetTree_Call struct {
	*mock.Call
}

// GetTree is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.GetTreeRequest
func (_e *MockGitServer_Expecter) GetTree(ctx interface{}, req interface{}) *MockGitServer_GetTree_Call {
	return &MockGitServer_GetTree_Call{Call: _e.mock.On("GetTree", ctx, req)}
}

func (_c *MockGitServer_GetTree_Call) Run(run func(ctx context.Context, req types.GetTreeRequest)) *MockGitServer_GetTree_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.GetTreeRequest))
	})
	return _c
}

func (_c *MockGitServer_GetTree_Call) Return(_a0 *types.GetRepoFileTreeResp, _a1 error) *MockGitServer_GetTree_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_GetTree_Call) RunAndReturn(run func(context.Context, types.GetTreeRequest) (*types.GetRepoFileTreeResp, error)) *MockGitServer_GetTree_Call {
	_c.Call.Return(run)
	return _c
}

// InfoRefsResponse provides a mock function with given fields: ctx, req
func (_m *MockGitServer) InfoRefsResponse(ctx context.Context, req gitserver.InfoRefsReq) (io.Reader, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for InfoRefsResponse")
	}

	var r0 io.Reader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.InfoRefsReq) (io.Reader, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.InfoRefsReq) io.Reader); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Reader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.InfoRefsReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_InfoRefsResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfoRefsResponse'
type MockGitServer_InfoRefsResponse_Call struct {
	*mock.Call
}

// InfoRefsResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.InfoRefsReq
func (_e *MockGitServer_Expecter) InfoRefsResponse(ctx interface{}, req interface{}) *MockGitServer_InfoRefsResponse_Call {
	return &MockGitServer_InfoRefsResponse_Call{Call: _e.mock.On("InfoRefsResponse", ctx, req)}
}

func (_c *MockGitServer_InfoRefsResponse_Call) Run(run func(ctx context.Context, req gitserver.InfoRefsReq)) *MockGitServer_InfoRefsResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.InfoRefsReq))
	})
	return _c
}

func (_c *MockGitServer_InfoRefsResponse_Call) Return(_a0 io.Reader, _a1 error) *MockGitServer_InfoRefsResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_InfoRefsResponse_Call) RunAndReturn(run func(context.Context, gitserver.InfoRefsReq) (io.Reader, error)) *MockGitServer_InfoRefsResponse_Call {
	_c.Call.Return(run)
	return _c
}

// MirrorSync provides a mock function with given fields: ctx, req
func (_m *MockGitServer) MirrorSync(ctx context.Context, req gitserver.MirrorSyncReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for MirrorSync")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.MirrorSyncReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_MirrorSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MirrorSync'
type MockGitServer_MirrorSync_Call struct {
	*mock.Call
}

// MirrorSync is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.MirrorSyncReq
func (_e *MockGitServer_Expecter) MirrorSync(ctx interface{}, req interface{}) *MockGitServer_MirrorSync_Call {
	return &MockGitServer_MirrorSync_Call{Call: _e.mock.On("MirrorSync", ctx, req)}
}

func (_c *MockGitServer_MirrorSync_Call) Run(run func(ctx context.Context, req gitserver.MirrorSyncReq)) *MockGitServer_MirrorSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.MirrorSyncReq))
	})
	return _c
}

func (_c *MockGitServer_MirrorSync_Call) Return(_a0 error) *MockGitServer_MirrorSync_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_MirrorSync_Call) RunAndReturn(run func(context.Context, gitserver.MirrorSyncReq) error) *MockGitServer_MirrorSync_Call {
	_c.Call.Return(run)
	return _c
}

// ReceivePack provides a mock function with given fields: ctx, req
func (_m *MockGitServer) ReceivePack(ctx context.Context, req gitserver.ReceivePackReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ReceivePack")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.ReceivePackReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_ReceivePack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReceivePack'
type MockGitServer_ReceivePack_Call struct {
	*mock.Call
}

// ReceivePack is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.ReceivePackReq
func (_e *MockGitServer_Expecter) ReceivePack(ctx interface{}, req interface{}) *MockGitServer_ReceivePack_Call {
	return &MockGitServer_ReceivePack_Call{Call: _e.mock.On("ReceivePack", ctx, req)}
}

func (_c *MockGitServer_ReceivePack_Call) Run(run func(ctx context.Context, req gitserver.ReceivePackReq)) *MockGitServer_ReceivePack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.ReceivePackReq))
	})
	return _c
}

func (_c *MockGitServer_ReceivePack_Call) Return(_a0 error) *MockGitServer_ReceivePack_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_ReceivePack_Call) RunAndReturn(run func(context.Context, gitserver.ReceivePackReq) error) *MockGitServer_ReceivePack_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateOrganization provides a mock function with given fields: _a0, _a1
func (_m *MockGitServer) UpdateOrganization(_a0 *types.EditOrgReq, _a1 *database.Organization) (*database.Organization, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOrganization")
	}

	var r0 *database.Organization
	var r1 error
	if rf, ok := ret.Get(0).(func(*types.EditOrgReq, *database.Organization) (*database.Organization, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(*types.EditOrgReq, *database.Organization) *database.Organization); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Organization)
		}
	}

	if rf, ok := ret.Get(1).(func(*types.EditOrgReq, *database.Organization) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_UpdateOrganization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateOrganization'
type MockGitServer_UpdateOrganization_Call struct {
	*mock.Call
}

// UpdateOrganization is a helper method to define mock.On call
//   - _a0 *types.EditOrgReq
//   - _a1 *database.Organization
func (_e *MockGitServer_Expecter) UpdateOrganization(_a0 interface{}, _a1 interface{}) *MockGitServer_UpdateOrganization_Call {
	return &MockGitServer_UpdateOrganization_Call{Call: _e.mock.On("UpdateOrganization", _a0, _a1)}
}

func (_c *MockGitServer_UpdateOrganization_Call) Run(run func(_a0 *types.EditOrgReq, _a1 *database.Organization)) *MockGitServer_UpdateOrganization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.EditOrgReq), args[1].(*database.Organization))
	})
	return _c
}

func (_c *MockGitServer_UpdateOrganization_Call) Return(_a0 *database.Organization, _a1 error) *MockGitServer_UpdateOrganization_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_UpdateOrganization_Call) RunAndReturn(run func(*types.EditOrgReq, *database.Organization) (*database.Organization, error)) *MockGitServer_UpdateOrganization_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRepo provides a mock function with given fields: ctx, req
func (_m *MockGitServer) UpdateRepo(ctx context.Context, req gitserver.UpdateRepoReq) (*gitserver.CreateRepoResp, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepo")
	}

	var r0 *gitserver.CreateRepoResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.UpdateRepoReq) (*gitserver.CreateRepoResp, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.UpdateRepoReq) *gitserver.CreateRepoResp); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitserver.CreateRepoResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, gitserver.UpdateRepoReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_UpdateRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRepo'
type MockGitServer_UpdateRepo_Call struct {
	*mock.Call
}

// UpdateRepo is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.UpdateRepoReq
func (_e *MockGitServer_Expecter) UpdateRepo(ctx interface{}, req interface{}) *MockGitServer_UpdateRepo_Call {
	return &MockGitServer_UpdateRepo_Call{Call: _e.mock.On("UpdateRepo", ctx, req)}
}

func (_c *MockGitServer_UpdateRepo_Call) Run(run func(ctx context.Context, req gitserver.UpdateRepoReq)) *MockGitServer_UpdateRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.UpdateRepoReq))
	})
	return _c
}

func (_c *MockGitServer_UpdateRepo_Call) Return(_a0 *gitserver.CreateRepoResp, _a1 error) *MockGitServer_UpdateRepo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_UpdateRepo_Call) RunAndReturn(run func(context.Context, gitserver.UpdateRepoReq) (*gitserver.CreateRepoResp, error)) *MockGitServer_UpdateRepo_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRepoFile provides a mock function with given fields: req
func (_m *MockGitServer) UpdateRepoFile(req *types.UpdateFileReq) error {
	ret := _m.Called(req)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRepoFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.UpdateFileReq) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_UpdateRepoFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRepoFile'
type MockGitServer_UpdateRepoFile_Call struct {
	*mock.Call
}

// UpdateRepoFile is a helper method to define mock.On call
//   - req *types.UpdateFileReq
func (_e *MockGitServer_Expecter) UpdateRepoFile(req interface{}) *MockGitServer_UpdateRepoFile_Call {
	return &MockGitServer_UpdateRepoFile_Call{Call: _e.mock.On("UpdateRepoFile", req)}
}

func (_c *MockGitServer_UpdateRepoFile_Call) Run(run func(req *types.UpdateFileReq)) *MockGitServer_UpdateRepoFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.UpdateFileReq))
	})
	return _c
}

func (_c *MockGitServer_UpdateRepoFile_Call) Return(err error) *MockGitServer_UpdateRepoFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockGitServer_UpdateRepoFile_Call) RunAndReturn(run func(*types.UpdateFileReq) error) *MockGitServer_UpdateRepoFile_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: _a0, _a1
func (_m *MockGitServer) UpdateUser(_a0 *types.UpdateUserRequest, _a1 *database.User) (*database.User, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 *database.User
	var r1 error
	if rf, ok := ret.Get(0).(func(*types.UpdateUserRequest, *database.User) (*database.User, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(*types.UpdateUserRequest, *database.User) *database.User); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.User)
		}
	}

	if rf, ok := ret.Get(1).(func(*types.UpdateUserRequest, *database.User) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitServer_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockGitServer_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - _a0 *types.UpdateUserRequest
//   - _a1 *database.User
func (_e *MockGitServer_Expecter) UpdateUser(_a0 interface{}, _a1 interface{}) *MockGitServer_UpdateUser_Call {
	return &MockGitServer_UpdateUser_Call{Call: _e.mock.On("UpdateUser", _a0, _a1)}
}

func (_c *MockGitServer_UpdateUser_Call) Run(run func(_a0 *types.UpdateUserRequest, _a1 *database.User)) *MockGitServer_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.UpdateUserRequest), args[1].(*database.User))
	})
	return _c
}

func (_c *MockGitServer_UpdateUser_Call) Return(_a0 *database.User, _a1 error) *MockGitServer_UpdateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitServer_UpdateUser_Call) RunAndReturn(run func(*types.UpdateUserRequest, *database.User) (*database.User, error)) *MockGitServer_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserV2 provides a mock function with given fields: _a0
func (_m *MockGitServer) UpdateUserV2(_a0 gitserver.UpdateUserRequest) error {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserV2")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(gitserver.UpdateUserRequest) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_UpdateUserV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserV2'
type MockGitServer_UpdateUserV2_Call struct {
	*mock.Call
}

// UpdateUserV2 is a helper method to define mock.On call
//   - _a0 gitserver.UpdateUserRequest
func (_e *MockGitServer_Expecter) UpdateUserV2(_a0 interface{}) *MockGitServer_UpdateUserV2_Call {
	return &MockGitServer_UpdateUserV2_Call{Call: _e.mock.On("UpdateUserV2", _a0)}
}

func (_c *MockGitServer_UpdateUserV2_Call) Run(run func(_a0 gitserver.UpdateUserRequest)) *MockGitServer_UpdateUserV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gitserver.UpdateUserRequest))
	})
	return _c
}

func (_c *MockGitServer_UpdateUserV2_Call) Return(_a0 error) *MockGitServer_UpdateUserV2_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_UpdateUserV2_Call) RunAndReturn(run func(gitserver.UpdateUserRequest) error) *MockGitServer_UpdateUserV2_Call {
	_c.Call.Return(run)
	return _c
}

// UploadPack provides a mock function with given fields: ctx, req
func (_m *MockGitServer) UploadPack(ctx context.Context, req gitserver.UploadPackReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for UploadPack")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, gitserver.UploadPackReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitServer_UploadPack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadPack'
type MockGitServer_UploadPack_Call struct {
	*mock.Call
}

// UploadPack is a helper method to define mock.On call
//   - ctx context.Context
//   - req gitserver.UploadPackReq
func (_e *MockGitServer_Expecter) UploadPack(ctx interface{}, req interface{}) *MockGitServer_UploadPack_Call {
	return &MockGitServer_UploadPack_Call{Call: _e.mock.On("UploadPack", ctx, req)}
}

func (_c *MockGitServer_UploadPack_Call) Run(run func(ctx context.Context, req gitserver.UploadPackReq)) *MockGitServer_UploadPack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(gitserver.UploadPackReq))
	})
	return _c
}

func (_c *MockGitServer_UploadPack_Call) Return(_a0 error) *MockGitServer_UploadPack_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitServer_UploadPack_Call) RunAndReturn(run func(context.Context, gitserver.UploadPackReq) error) *MockGitServer_UploadPack_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGitServer creates a new instance of MockGitServer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGitServer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGitServer {
	mock := &MockGitServer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
