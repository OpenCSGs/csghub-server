// Code generated by mockery v2.53.5. DO NOT EDIT.

package database

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	database "opencsg.com/csghub-server/builder/store/database"
)

// MockSSHKeyStore is an autogenerated mock type for the SSHKeyStore type
type MockSSHKeyStore struct {
	mock.Mock
}

type MockSSHKeyStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSSHKeyStore) EXPECT() *MockSSHKeyStore_Expecter {
	return &MockSSHKeyStore_Expecter{mock: &_m.Mock}
}

// Create provides a mock function with given fields: ctx, sshKey
func (_m *MockSSHKeyStore) Create(ctx context.Context, sshKey *database.SSHKey) (*database.SSHKey, error) {
	ret := _m.Called(ctx, sshKey)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *database.SSHKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *database.SSHKey) (*database.SSHKey, error)); ok {
		return rf(ctx, sshKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *database.SSHKey) *database.SSHKey); ok {
		r0 = rf(ctx, sshKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *database.SSHKey) error); ok {
		r1 = rf(ctx, sshKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSSHKeyStore_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockSSHKeyStore_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - sshKey *database.SSHKey
func (_e *MockSSHKeyStore_Expecter) Create(ctx interface{}, sshKey interface{}) *MockSSHKeyStore_Create_Call {
	return &MockSSHKeyStore_Create_Call{Call: _e.mock.On("Create", ctx, sshKey)}
}

func (_c *MockSSHKeyStore_Create_Call) Run(run func(ctx context.Context, sshKey *database.SSHKey)) *MockSSHKeyStore_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*database.SSHKey))
	})
	return _c
}

func (_c *MockSSHKeyStore_Create_Call) Return(_a0 *database.SSHKey, _a1 error) *MockSSHKeyStore_Create_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSSHKeyStore_Create_Call) RunAndReturn(run func(context.Context, *database.SSHKey) (*database.SSHKey, error)) *MockSSHKeyStore_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, id
func (_m *MockSSHKeyStore) Delete(ctx context.Context, id int64) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSSHKeyStore_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockSSHKeyStore_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockSSHKeyStore_Expecter) Delete(ctx interface{}, id interface{}) *MockSSHKeyStore_Delete_Call {
	return &MockSSHKeyStore_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockSSHKeyStore_Delete_Call) Run(run func(ctx context.Context, id int64)) *MockSSHKeyStore_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockSSHKeyStore_Delete_Call) Return(err error) *MockSSHKeyStore_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockSSHKeyStore_Delete_Call) RunAndReturn(run func(context.Context, int64) error) *MockSSHKeyStore_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// FindByFingerpringSHA256 provides a mock function with given fields: ctx, fingerprint
func (_m *MockSSHKeyStore) FindByFingerpringSHA256(ctx context.Context, fingerprint string) (*database.SSHKey, error) {
	ret := _m.Called(ctx, fingerprint)

	if len(ret) == 0 {
		panic("no return value specified for FindByFingerpringSHA256")
	}

	var r0 *database.SSHKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*database.SSHKey, error)); ok {
		return rf(ctx, fingerprint)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *database.SSHKey); ok {
		r0 = rf(ctx, fingerprint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, fingerprint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSSHKeyStore_FindByFingerpringSHA256_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByFingerpringSHA256'
type MockSSHKeyStore_FindByFingerpringSHA256_Call struct {
	*mock.Call
}

// FindByFingerpringSHA256 is a helper method to define mock.On call
//   - ctx context.Context
//   - fingerprint string
func (_e *MockSSHKeyStore_Expecter) FindByFingerpringSHA256(ctx interface{}, fingerprint interface{}) *MockSSHKeyStore_FindByFingerpringSHA256_Call {
	return &MockSSHKeyStore_FindByFingerpringSHA256_Call{Call: _e.mock.On("FindByFingerpringSHA256", ctx, fingerprint)}
}

func (_c *MockSSHKeyStore_FindByFingerpringSHA256_Call) Run(run func(ctx context.Context, fingerprint string)) *MockSSHKeyStore_FindByFingerpringSHA256_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSSHKeyStore_FindByFingerpringSHA256_Call) Return(_a0 *database.SSHKey, _a1 error) *MockSSHKeyStore_FindByFingerpringSHA256_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSSHKeyStore_FindByFingerpringSHA256_Call) RunAndReturn(run func(context.Context, string) (*database.SSHKey, error)) *MockSSHKeyStore_FindByFingerpringSHA256_Call {
	_c.Call.Return(run)
	return _c
}

// FindByID provides a mock function with given fields: ctx, id
func (_m *MockSSHKeyStore) FindByID(ctx context.Context, id int64) (*database.SSHKey, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for FindByID")
	}

	var r0 *database.SSHKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*database.SSHKey, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *database.SSHKey); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSSHKeyStore_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type MockSSHKeyStore_FindByID_Call struct {
	*mock.Call
}

// FindByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockSSHKeyStore_Expecter) FindByID(ctx interface{}, id interface{}) *MockSSHKeyStore_FindByID_Call {
	return &MockSSHKeyStore_FindByID_Call{Call: _e.mock.On("FindByID", ctx, id)}
}

func (_c *MockSSHKeyStore_FindByID_Call) Run(run func(ctx context.Context, id int64)) *MockSSHKeyStore_FindByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockSSHKeyStore_FindByID_Call) Return(_a0 *database.SSHKey, _a1 error) *MockSSHKeyStore_FindByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSSHKeyStore_FindByID_Call) RunAndReturn(run func(context.Context, int64) (*database.SSHKey, error)) *MockSSHKeyStore_FindByID_Call {
	_c.Call.Return(run)
	return _c
}

// FindByKeyContent provides a mock function with given fields: ctx, key
func (_m *MockSSHKeyStore) FindByKeyContent(ctx context.Context, key string) (*database.SSHKey, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for FindByKeyContent")
	}

	var r0 *database.SSHKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*database.SSHKey, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *database.SSHKey); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSSHKeyStore_FindByKeyContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByKeyContent'
type MockSSHKeyStore_FindByKeyContent_Call struct {
	*mock.Call
}

// FindByKeyContent is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockSSHKeyStore_Expecter) FindByKeyContent(ctx interface{}, key interface{}) *MockSSHKeyStore_FindByKeyContent_Call {
	return &MockSSHKeyStore_FindByKeyContent_Call{Call: _e.mock.On("FindByKeyContent", ctx, key)}
}

func (_c *MockSSHKeyStore_FindByKeyContent_Call) Run(run func(ctx context.Context, key string)) *MockSSHKeyStore_FindByKeyContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSSHKeyStore_FindByKeyContent_Call) Return(_a0 *database.SSHKey, _a1 error) *MockSSHKeyStore_FindByKeyContent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSSHKeyStore_FindByKeyContent_Call) RunAndReturn(run func(context.Context, string) (*database.SSHKey, error)) *MockSSHKeyStore_FindByKeyContent_Call {
	_c.Call.Return(run)
	return _c
}

// FindByNameAndUserID provides a mock function with given fields: ctx, name, userID
func (_m *MockSSHKeyStore) FindByNameAndUserID(ctx context.Context, name string, userID int64) (*database.SSHKey, error) {
	ret := _m.Called(ctx, name, userID)

	if len(ret) == 0 {
		panic("no return value specified for FindByNameAndUserID")
	}

	var r0 *database.SSHKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) (*database.SSHKey, error)); ok {
		return rf(ctx, name, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *database.SSHKey); ok {
		r0 = rf(ctx, name, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64) error); ok {
		r1 = rf(ctx, name, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSSHKeyStore_FindByNameAndUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByNameAndUserID'
type MockSSHKeyStore_FindByNameAndUserID_Call struct {
	*mock.Call
}

// FindByNameAndUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - userID int64
func (_e *MockSSHKeyStore_Expecter) FindByNameAndUserID(ctx interface{}, name interface{}, userID interface{}) *MockSSHKeyStore_FindByNameAndUserID_Call {
	return &MockSSHKeyStore_FindByNameAndUserID_Call{Call: _e.mock.On("FindByNameAndUserID", ctx, name, userID)}
}

func (_c *MockSSHKeyStore_FindByNameAndUserID_Call) Run(run func(ctx context.Context, name string, userID int64)) *MockSSHKeyStore_FindByNameAndUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockSSHKeyStore_FindByNameAndUserID_Call) Return(_a0 *database.SSHKey, _a1 error) *MockSSHKeyStore_FindByNameAndUserID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSSHKeyStore_FindByNameAndUserID_Call) RunAndReturn(run func(context.Context, string, int64) (*database.SSHKey, error)) *MockSSHKeyStore_FindByNameAndUserID_Call {
	_c.Call.Return(run)
	return _c
}

// FindByUsernameAndName provides a mock function with given fields: ctx, username, keyName
func (_m *MockSSHKeyStore) FindByUsernameAndName(ctx context.Context, username string, keyName string) (database.SSHKey, error) {
	ret := _m.Called(ctx, username, keyName)

	if len(ret) == 0 {
		panic("no return value specified for FindByUsernameAndName")
	}

	var r0 database.SSHKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (database.SSHKey, error)); ok {
		return rf(ctx, username, keyName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) database.SSHKey); ok {
		r0 = rf(ctx, username, keyName)
	} else {
		r0 = ret.Get(0).(database.SSHKey)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, username, keyName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSSHKeyStore_FindByUsernameAndName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByUsernameAndName'
type MockSSHKeyStore_FindByUsernameAndName_Call struct {
	*mock.Call
}

// FindByUsernameAndName is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - keyName string
func (_e *MockSSHKeyStore_Expecter) FindByUsernameAndName(ctx interface{}, username interface{}, keyName interface{}) *MockSSHKeyStore_FindByUsernameAndName_Call {
	return &MockSSHKeyStore_FindByUsernameAndName_Call{Call: _e.mock.On("FindByUsernameAndName", ctx, username, keyName)}
}

func (_c *MockSSHKeyStore_FindByUsernameAndName_Call) Run(run func(ctx context.Context, username string, keyName string)) *MockSSHKeyStore_FindByUsernameAndName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockSSHKeyStore_FindByUsernameAndName_Call) Return(sshKey database.SSHKey, err error) *MockSSHKeyStore_FindByUsernameAndName_Call {
	_c.Call.Return(sshKey, err)
	return _c
}

func (_c *MockSSHKeyStore_FindByUsernameAndName_Call) RunAndReturn(run func(context.Context, string, string) (database.SSHKey, error)) *MockSSHKeyStore_FindByUsernameAndName_Call {
	_c.Call.Return(run)
	return _c
}

// Index provides a mock function with given fields: ctx, username, per, page
func (_m *MockSSHKeyStore) Index(ctx context.Context, username string, per int, page int) ([]database.SSHKey, error) {
	ret := _m.Called(ctx, username, per, page)

	if len(ret) == 0 {
		panic("no return value specified for Index")
	}

	var r0 []database.SSHKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) ([]database.SSHKey, error)); ok {
		return rf(ctx, username, per, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) []database.SSHKey); ok {
		r0 = rf(ctx, username, per, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, int) error); ok {
		r1 = rf(ctx, username, per, page)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSSHKeyStore_Index_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Index'
type MockSSHKeyStore_Index_Call struct {
	*mock.Call
}

// Index is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - per int
//   - page int
func (_e *MockSSHKeyStore_Expecter) Index(ctx interface{}, username interface{}, per interface{}, page interface{}) *MockSSHKeyStore_Index_Call {
	return &MockSSHKeyStore_Index_Call{Call: _e.mock.On("Index", ctx, username, per, page)}
}

func (_c *MockSSHKeyStore_Index_Call) Run(run func(ctx context.Context, username string, per int, page int)) *MockSSHKeyStore_Index_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockSSHKeyStore_Index_Call) Return(sshKeys []database.SSHKey, err error) *MockSSHKeyStore_Index_Call {
	_c.Call.Return(sshKeys, err)
	return _c
}

func (_c *MockSSHKeyStore_Index_Call) RunAndReturn(run func(context.Context, string, int, int) ([]database.SSHKey, error)) *MockSSHKeyStore_Index_Call {
	_c.Call.Return(run)
	return _c
}

// IsExist provides a mock function with given fields: ctx, username, keyName
func (_m *MockSSHKeyStore) IsExist(ctx context.Context, username string, keyName string) (bool, error) {
	ret := _m.Called(ctx, username, keyName)

	if len(ret) == 0 {
		panic("no return value specified for IsExist")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, username, keyName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, username, keyName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, username, keyName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSSHKeyStore_IsExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsExist'
type MockSSHKeyStore_IsExist_Call struct {
	*mock.Call
}

// IsExist is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - keyName string
func (_e *MockSSHKeyStore_Expecter) IsExist(ctx interface{}, username interface{}, keyName interface{}) *MockSSHKeyStore_IsExist_Call {
	return &MockSSHKeyStore_IsExist_Call{Call: _e.mock.On("IsExist", ctx, username, keyName)}
}

func (_c *MockSSHKeyStore_IsExist_Call) Run(run func(ctx context.Context, username string, keyName string)) *MockSSHKeyStore_IsExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockSSHKeyStore_IsExist_Call) Return(exists bool, err error) *MockSSHKeyStore_IsExist_Call {
	_c.Call.Return(exists, err)
	return _c
}

func (_c *MockSSHKeyStore_IsExist_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockSSHKeyStore_IsExist_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSSHKeyStore creates a new instance of MockSSHKeyStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSSHKeyStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSSHKeyStore {
	mock := &MockSSHKeyStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
