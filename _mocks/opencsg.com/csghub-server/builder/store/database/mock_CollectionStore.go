// Code generated by mockery v2.49.1. DO NOT EDIT.

package database

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	database "opencsg.com/csghub-server/builder/store/database"

	types "opencsg.com/csghub-server/common/types"
)

// MockCollectionStore is an autogenerated mock type for the CollectionStore type
type MockCollectionStore struct {
	mock.Mock
}

type MockCollectionStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCollectionStore) EXPECT() *MockCollectionStore_Expecter {
	return &MockCollectionStore_Expecter{mock: &_m.Mock}
}

// AddCollectionRepos provides a mock function with given fields: ctx, crs
func (_m *MockCollectionStore) AddCollectionRepos(ctx context.Context, crs []database.CollectionRepository) error {
	ret := _m.Called(ctx, crs)

	if len(ret) == 0 {
		panic("no return value specified for AddCollectionRepos")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []database.CollectionRepository) error); ok {
		r0 = rf(ctx, crs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCollectionStore_AddCollectionRepos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCollectionRepos'
type MockCollectionStore_AddCollectionRepos_Call struct {
	*mock.Call
}

// AddCollectionRepos is a helper method to define mock.On call
//   - ctx context.Context
//   - crs []database.CollectionRepository
func (_e *MockCollectionStore_Expecter) AddCollectionRepos(ctx interface{}, crs interface{}) *MockCollectionStore_AddCollectionRepos_Call {
	return &MockCollectionStore_AddCollectionRepos_Call{Call: _e.mock.On("AddCollectionRepos", ctx, crs)}
}

func (_c *MockCollectionStore_AddCollectionRepos_Call) Run(run func(ctx context.Context, crs []database.CollectionRepository)) *MockCollectionStore_AddCollectionRepos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]database.CollectionRepository))
	})
	return _c
}

func (_c *MockCollectionStore_AddCollectionRepos_Call) Return(_a0 error) *MockCollectionStore_AddCollectionRepos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollectionStore_AddCollectionRepos_Call) RunAndReturn(run func(context.Context, []database.CollectionRepository) error) *MockCollectionStore_AddCollectionRepos_Call {
	_c.Call.Return(run)
	return _c
}

// ByUserLikes provides a mock function with given fields: ctx, userID, per, page
func (_m *MockCollectionStore) ByUserLikes(ctx context.Context, userID int64, per int, page int) ([]database.Collection, int, error) {
	ret := _m.Called(ctx, userID, per, page)

	if len(ret) == 0 {
		panic("no return value specified for ByUserLikes")
	}

	var r0 []database.Collection
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int, int) ([]database.Collection, int, error)); ok {
		return rf(ctx, userID, per, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int, int) []database.Collection); ok {
		r0 = rf(ctx, userID, per, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int, int) int); ok {
		r1 = rf(ctx, userID, per, page)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int64, int, int) error); ok {
		r2 = rf(ctx, userID, per, page)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollectionStore_ByUserLikes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByUserLikes'
type MockCollectionStore_ByUserLikes_Call struct {
	*mock.Call
}

// ByUserLikes is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int64
//   - per int
//   - page int
func (_e *MockCollectionStore_Expecter) ByUserLikes(ctx interface{}, userID interface{}, per interface{}, page interface{}) *MockCollectionStore_ByUserLikes_Call {
	return &MockCollectionStore_ByUserLikes_Call{Call: _e.mock.On("ByUserLikes", ctx, userID, per, page)}
}

func (_c *MockCollectionStore_ByUserLikes_Call) Run(run func(ctx context.Context, userID int64, per int, page int)) *MockCollectionStore_ByUserLikes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockCollectionStore_ByUserLikes_Call) Return(collections []database.Collection, total int, err error) *MockCollectionStore_ByUserLikes_Call {
	_c.Call.Return(collections, total, err)
	return _c
}

func (_c *MockCollectionStore_ByUserLikes_Call) RunAndReturn(run func(context.Context, int64, int, int) ([]database.Collection, int, error)) *MockCollectionStore_ByUserLikes_Call {
	_c.Call.Return(run)
	return _c
}

// ByUserOrgs provides a mock function with given fields: ctx, namespace, per, page, onlyPublic
func (_m *MockCollectionStore) ByUserOrgs(ctx context.Context, namespace string, per int, page int, onlyPublic bool) ([]database.Collection, int, error) {
	ret := _m.Called(ctx, namespace, per, page, onlyPublic)

	if len(ret) == 0 {
		panic("no return value specified for ByUserOrgs")
	}

	var r0 []database.Collection
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int, bool) ([]database.Collection, int, error)); ok {
		return rf(ctx, namespace, per, page, onlyPublic)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int, bool) []database.Collection); ok {
		r0 = rf(ctx, namespace, per, page, onlyPublic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, int, bool) int); ok {
		r1 = rf(ctx, namespace, per, page, onlyPublic)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, int, bool) error); ok {
		r2 = rf(ctx, namespace, per, page, onlyPublic)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollectionStore_ByUserOrgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByUserOrgs'
type MockCollectionStore_ByUserOrgs_Call struct {
	*mock.Call
}

// ByUserOrgs is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - per int
//   - page int
//   - onlyPublic bool
func (_e *MockCollectionStore_Expecter) ByUserOrgs(ctx interface{}, namespace interface{}, per interface{}, page interface{}, onlyPublic interface{}) *MockCollectionStore_ByUserOrgs_Call {
	return &MockCollectionStore_ByUserOrgs_Call{Call: _e.mock.On("ByUserOrgs", ctx, namespace, per, page, onlyPublic)}
}

func (_c *MockCollectionStore_ByUserOrgs_Call) Run(run func(ctx context.Context, namespace string, per int, page int, onlyPublic bool)) *MockCollectionStore_ByUserOrgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockCollectionStore_ByUserOrgs_Call) Return(collections []database.Collection, total int, err error) *MockCollectionStore_ByUserOrgs_Call {
	_c.Call.Return(collections, total, err)
	return _c
}

func (_c *MockCollectionStore_ByUserOrgs_Call) RunAndReturn(run func(context.Context, string, int, int, bool) ([]database.Collection, int, error)) *MockCollectionStore_ByUserOrgs_Call {
	_c.Call.Return(run)
	return _c
}

// ByUsername provides a mock function with given fields: ctx, username, per, page, onlyPublic
func (_m *MockCollectionStore) ByUsername(ctx context.Context, username string, per int, page int, onlyPublic bool) ([]database.Collection, int, error) {
	ret := _m.Called(ctx, username, per, page, onlyPublic)

	if len(ret) == 0 {
		panic("no return value specified for ByUsername")
	}

	var r0 []database.Collection
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int, bool) ([]database.Collection, int, error)); ok {
		return rf(ctx, username, per, page, onlyPublic)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int, bool) []database.Collection); ok {
		r0 = rf(ctx, username, per, page, onlyPublic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, int, bool) int); ok {
		r1 = rf(ctx, username, per, page, onlyPublic)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, int, bool) error); ok {
		r2 = rf(ctx, username, per, page, onlyPublic)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollectionStore_ByUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ByUsername'
type MockCollectionStore_ByUsername_Call struct {
	*mock.Call
}

// ByUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - per int
//   - page int
//   - onlyPublic bool
func (_e *MockCollectionStore_Expecter) ByUsername(ctx interface{}, username interface{}, per interface{}, page interface{}, onlyPublic interface{}) *MockCollectionStore_ByUsername_Call {
	return &MockCollectionStore_ByUsername_Call{Call: _e.mock.On("ByUsername", ctx, username, per, page, onlyPublic)}
}

func (_c *MockCollectionStore_ByUsername_Call) Run(run func(ctx context.Context, username string, per int, page int, onlyPublic bool)) *MockCollectionStore_ByUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockCollectionStore_ByUsername_Call) Return(collections []database.Collection, total int, err error) *MockCollectionStore_ByUsername_Call {
	_c.Call.Return(collections, total, err)
	return _c
}

func (_c *MockCollectionStore_ByUsername_Call) RunAndReturn(run func(context.Context, string, int, int, bool) ([]database.Collection, int, error)) *MockCollectionStore_ByUsername_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCollection provides a mock function with given fields: ctx, collection
func (_m *MockCollectionStore) CreateCollection(ctx context.Context, collection database.Collection) (*database.Collection, error) {
	ret := _m.Called(ctx, collection)

	if len(ret) == 0 {
		panic("no return value specified for CreateCollection")
	}

	var r0 *database.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.Collection) (*database.Collection, error)); ok {
		return rf(ctx, collection)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.Collection) *database.Collection); ok {
		r0 = rf(ctx, collection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.Collection) error); ok {
		r1 = rf(ctx, collection)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollectionStore_CreateCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCollection'
type MockCollectionStore_CreateCollection_Call struct {
	*mock.Call
}

// CreateCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - collection database.Collection
func (_e *MockCollectionStore_Expecter) CreateCollection(ctx interface{}, collection interface{}) *MockCollectionStore_CreateCollection_Call {
	return &MockCollectionStore_CreateCollection_Call{Call: _e.mock.On("CreateCollection", ctx, collection)}
}

func (_c *MockCollectionStore_CreateCollection_Call) Run(run func(ctx context.Context, collection database.Collection)) *MockCollectionStore_CreateCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.Collection))
	})
	return _c
}

func (_c *MockCollectionStore_CreateCollection_Call) Return(_a0 *database.Collection, _a1 error) *MockCollectionStore_CreateCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollectionStore_CreateCollection_Call) RunAndReturn(run func(context.Context, database.Collection) (*database.Collection, error)) *MockCollectionStore_CreateCollection_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCollection provides a mock function with given fields: ctx, id, uid
func (_m *MockCollectionStore) DeleteCollection(ctx context.Context, id int64, uid int64) error {
	ret := _m.Called(ctx, id, uid)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) error); ok {
		r0 = rf(ctx, id, uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCollectionStore_DeleteCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCollection'
type MockCollectionStore_DeleteCollection_Call struct {
	*mock.Call
}

// DeleteCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
//   - uid int64
func (_e *MockCollectionStore_Expecter) DeleteCollection(ctx interface{}, id interface{}, uid interface{}) *MockCollectionStore_DeleteCollection_Call {
	return &MockCollectionStore_DeleteCollection_Call{Call: _e.mock.On("DeleteCollection", ctx, id, uid)}
}

func (_c *MockCollectionStore_DeleteCollection_Call) Run(run func(ctx context.Context, id int64, uid int64)) *MockCollectionStore_DeleteCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *MockCollectionStore_DeleteCollection_Call) Return(_a0 error) *MockCollectionStore_DeleteCollection_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollectionStore_DeleteCollection_Call) RunAndReturn(run func(context.Context, int64, int64) error) *MockCollectionStore_DeleteCollection_Call {
	_c.Call.Return(run)
	return _c
}

// FindById provides a mock function with given fields: ctx, id
func (_m *MockCollectionStore) FindById(ctx context.Context, id int64) (database.Collection, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for FindById")
	}

	var r0 database.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (database.Collection, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) database.Collection); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(database.Collection)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollectionStore_FindById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindById'
type MockCollectionStore_FindById_Call struct {
	*mock.Call
}

// FindById is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockCollectionStore_Expecter) FindById(ctx interface{}, id interface{}) *MockCollectionStore_FindById_Call {
	return &MockCollectionStore_FindById_Call{Call: _e.mock.On("FindById", ctx, id)}
}

func (_c *MockCollectionStore_FindById_Call) Run(run func(ctx context.Context, id int64)) *MockCollectionStore_FindById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockCollectionStore_FindById_Call) Return(collection database.Collection, err error) *MockCollectionStore_FindById_Call {
	_c.Call.Return(collection, err)
	return _c
}

func (_c *MockCollectionStore_FindById_Call) RunAndReturn(run func(context.Context, int64) (database.Collection, error)) *MockCollectionStore_FindById_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollection provides a mock function with given fields: ctx, id
func (_m *MockCollectionStore) GetCollection(ctx context.Context, id int64) (*database.Collection, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetCollection")
	}

	var r0 *database.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*database.Collection, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *database.Collection); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollectionStore_GetCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollection'
type MockCollectionStore_GetCollection_Call struct {
	*mock.Call
}

// GetCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockCollectionStore_Expecter) GetCollection(ctx interface{}, id interface{}) *MockCollectionStore_GetCollection_Call {
	return &MockCollectionStore_GetCollection_Call{Call: _e.mock.On("GetCollection", ctx, id)}
}

func (_c *MockCollectionStore_GetCollection_Call) Run(run func(ctx context.Context, id int64)) *MockCollectionStore_GetCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockCollectionStore_GetCollection_Call) Return(_a0 *database.Collection, _a1 error) *MockCollectionStore_GetCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollectionStore_GetCollection_Call) RunAndReturn(run func(context.Context, int64) (*database.Collection, error)) *MockCollectionStore_GetCollection_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollections provides a mock function with given fields: ctx, filter, per, page, showPrivate
func (_m *MockCollectionStore) GetCollections(ctx context.Context, filter *types.CollectionFilter, per int, page int, showPrivate bool) ([]database.Collection, int, error) {
	ret := _m.Called(ctx, filter, per, page, showPrivate)

	if len(ret) == 0 {
		panic("no return value specified for GetCollections")
	}

	var r0 []database.Collection
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.CollectionFilter, int, int, bool) ([]database.Collection, int, error)); ok {
		return rf(ctx, filter, per, page, showPrivate)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.CollectionFilter, int, int, bool) []database.Collection); ok {
		r0 = rf(ctx, filter, per, page, showPrivate)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.CollectionFilter, int, int, bool) int); ok {
		r1 = rf(ctx, filter, per, page, showPrivate)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.CollectionFilter, int, int, bool) error); ok {
		r2 = rf(ctx, filter, per, page, showPrivate)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollectionStore_GetCollections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollections'
type MockCollectionStore_GetCollections_Call struct {
	*mock.Call
}

// GetCollections is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *types.CollectionFilter
//   - per int
//   - page int
//   - showPrivate bool
func (_e *MockCollectionStore_Expecter) GetCollections(ctx interface{}, filter interface{}, per interface{}, page interface{}, showPrivate interface{}) *MockCollectionStore_GetCollections_Call {
	return &MockCollectionStore_GetCollections_Call{Call: _e.mock.On("GetCollections", ctx, filter, per, page, showPrivate)}
}

func (_c *MockCollectionStore_GetCollections_Call) Run(run func(ctx context.Context, filter *types.CollectionFilter, per int, page int, showPrivate bool)) *MockCollectionStore_GetCollections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.CollectionFilter), args[2].(int), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockCollectionStore_GetCollections_Call) Return(collections []database.Collection, total int, err error) *MockCollectionStore_GetCollections_Call {
	_c.Call.Return(collections, total, err)
	return _c
}

func (_c *MockCollectionStore_GetCollections_Call) RunAndReturn(run func(context.Context, *types.CollectionFilter, int, int, bool) ([]database.Collection, int, error)) *MockCollectionStore_GetCollections_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollectionsByIDs provides a mock function with given fields: ctx, collections, ids, total, onlyPublic
func (_m *MockCollectionStore) GetCollectionsByIDs(ctx context.Context, collections []database.Collection, ids []interface{}, total int, onlyPublic bool) ([]database.Collection, int, error) {
	ret := _m.Called(ctx, collections, ids, total, onlyPublic)

	if len(ret) == 0 {
		panic("no return value specified for GetCollectionsByIDs")
	}

	var r0 []database.Collection
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []database.Collection, []interface{}, int, bool) ([]database.Collection, int, error)); ok {
		return rf(ctx, collections, ids, total, onlyPublic)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []database.Collection, []interface{}, int, bool) []database.Collection); ok {
		r0 = rf(ctx, collections, ids, total, onlyPublic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []database.Collection, []interface{}, int, bool) int); ok {
		r1 = rf(ctx, collections, ids, total, onlyPublic)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, []database.Collection, []interface{}, int, bool) error); ok {
		r2 = rf(ctx, collections, ids, total, onlyPublic)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollectionStore_GetCollectionsByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollectionsByIDs'
type MockCollectionStore_GetCollectionsByIDs_Call struct {
	*mock.Call
}

// GetCollectionsByIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - collections []database.Collection
//   - ids []interface{}
//   - total int
//   - onlyPublic bool
func (_e *MockCollectionStore_Expecter) GetCollectionsByIDs(ctx interface{}, collections interface{}, ids interface{}, total interface{}, onlyPublic interface{}) *MockCollectionStore_GetCollectionsByIDs_Call {
	return &MockCollectionStore_GetCollectionsByIDs_Call{Call: _e.mock.On("GetCollectionsByIDs", ctx, collections, ids, total, onlyPublic)}
}

func (_c *MockCollectionStore_GetCollectionsByIDs_Call) Run(run func(ctx context.Context, collections []database.Collection, ids []interface{}, total int, onlyPublic bool)) *MockCollectionStore_GetCollectionsByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]database.Collection), args[2].([]interface{}), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockCollectionStore_GetCollectionsByIDs_Call) Return(_a0 []database.Collection, _a1 int, _a2 error) *MockCollectionStore_GetCollectionsByIDs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollectionStore_GetCollectionsByIDs_Call) RunAndReturn(run func(context.Context, []database.Collection, []interface{}, int, bool) ([]database.Collection, int, error)) *MockCollectionStore_GetCollectionsByIDs_Call {
	_c.Call.Return(run)
	return _c
}

// QueryByTrending provides a mock function with given fields: ctx, filter, per, page
func (_m *MockCollectionStore) QueryByTrending(ctx context.Context, filter *types.CollectionFilter, per int, page int) ([]database.Collection, int, error) {
	ret := _m.Called(ctx, filter, per, page)

	if len(ret) == 0 {
		panic("no return value specified for QueryByTrending")
	}

	var r0 []database.Collection
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.CollectionFilter, int, int) ([]database.Collection, int, error)); ok {
		return rf(ctx, filter, per, page)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.CollectionFilter, int, int) []database.Collection); ok {
		r0 = rf(ctx, filter, per, page)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.CollectionFilter, int, int) int); ok {
		r1 = rf(ctx, filter, per, page)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.CollectionFilter, int, int) error); ok {
		r2 = rf(ctx, filter, per, page)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollectionStore_QueryByTrending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryByTrending'
type MockCollectionStore_QueryByTrending_Call struct {
	*mock.Call
}

// QueryByTrending is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *types.CollectionFilter
//   - per int
//   - page int
func (_e *MockCollectionStore_Expecter) QueryByTrending(ctx interface{}, filter interface{}, per interface{}, page interface{}) *MockCollectionStore_QueryByTrending_Call {
	return &MockCollectionStore_QueryByTrending_Call{Call: _e.mock.On("QueryByTrending", ctx, filter, per, page)}
}

func (_c *MockCollectionStore_QueryByTrending_Call) Run(run func(ctx context.Context, filter *types.CollectionFilter, per int, page int)) *MockCollectionStore_QueryByTrending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.CollectionFilter), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockCollectionStore_QueryByTrending_Call) Return(collections []database.Collection, total int, err error) *MockCollectionStore_QueryByTrending_Call {
	_c.Call.Return(collections, total, err)
	return _c
}

func (_c *MockCollectionStore_QueryByTrending_Call) RunAndReturn(run func(context.Context, *types.CollectionFilter, int, int) ([]database.Collection, int, error)) *MockCollectionStore_QueryByTrending_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveCollectionRepos provides a mock function with given fields: ctx, crs
func (_m *MockCollectionStore) RemoveCollectionRepos(ctx context.Context, crs []database.CollectionRepository) error {
	ret := _m.Called(ctx, crs)

	if len(ret) == 0 {
		panic("no return value specified for RemoveCollectionRepos")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []database.CollectionRepository) error); ok {
		r0 = rf(ctx, crs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCollectionStore_RemoveCollectionRepos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveCollectionRepos'
type MockCollectionStore_RemoveCollectionRepos_Call struct {
	*mock.Call
}

// RemoveCollectionRepos is a helper method to define mock.On call
//   - ctx context.Context
//   - crs []database.CollectionRepository
func (_e *MockCollectionStore_Expecter) RemoveCollectionRepos(ctx interface{}, crs interface{}) *MockCollectionStore_RemoveCollectionRepos_Call {
	return &MockCollectionStore_RemoveCollectionRepos_Call{Call: _e.mock.On("RemoveCollectionRepos", ctx, crs)}
}

func (_c *MockCollectionStore_RemoveCollectionRepos_Call) Run(run func(ctx context.Context, crs []database.CollectionRepository)) *MockCollectionStore_RemoveCollectionRepos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]database.CollectionRepository))
	})
	return _c
}

func (_c *MockCollectionStore_RemoveCollectionRepos_Call) Return(_a0 error) *MockCollectionStore_RemoveCollectionRepos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollectionStore_RemoveCollectionRepos_Call) RunAndReturn(run func(context.Context, []database.CollectionRepository) error) *MockCollectionStore_RemoveCollectionRepos_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCollection provides a mock function with given fields: ctx, collection
func (_m *MockCollectionStore) UpdateCollection(ctx context.Context, collection database.Collection) (*database.Collection, error) {
	ret := _m.Called(ctx, collection)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCollection")
	}

	var r0 *database.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.Collection) (*database.Collection, error)); ok {
		return rf(ctx, collection)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.Collection) *database.Collection); ok {
		r0 = rf(ctx, collection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.Collection) error); ok {
		r1 = rf(ctx, collection)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollectionStore_UpdateCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCollection'
type MockCollectionStore_UpdateCollection_Call struct {
	*mock.Call
}

// UpdateCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - collection database.Collection
func (_e *MockCollectionStore_Expecter) UpdateCollection(ctx interface{}, collection interface{}) *MockCollectionStore_UpdateCollection_Call {
	return &MockCollectionStore_UpdateCollection_Call{Call: _e.mock.On("UpdateCollection", ctx, collection)}
}

func (_c *MockCollectionStore_UpdateCollection_Call) Run(run func(ctx context.Context, collection database.Collection)) *MockCollectionStore_UpdateCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.Collection))
	})
	return _c
}

func (_c *MockCollectionStore_UpdateCollection_Call) Return(_a0 *database.Collection, _a1 error) *MockCollectionStore_UpdateCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollectionStore_UpdateCollection_Call) RunAndReturn(run func(context.Context, database.Collection) (*database.Collection, error)) *MockCollectionStore_UpdateCollection_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCollectionStore creates a new instance of MockCollectionStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCollectionStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCollectionStore {
	mock := &MockCollectionStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
