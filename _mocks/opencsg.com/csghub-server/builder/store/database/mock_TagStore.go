// Code generated by mockery v2.53.0. DO NOT EDIT.

package database

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	database "opencsg.com/csghub-server/builder/store/database"

	types "opencsg.com/csghub-server/common/types"
)

// MockTagStore is an autogenerated mock type for the TagStore type
type MockTagStore struct {
	mock.Mock
}

type MockTagStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTagStore) EXPECT() *MockTagStore_Expecter {
	return &MockTagStore_Expecter{mock: &_m.Mock}
}

// AllCategories provides a mock function with given fields: ctx, scope
func (_m *MockTagStore) AllCategories(ctx context.Context, scope types.TagScope) ([]database.TagCategory, error) {
	ret := _m.Called(ctx, scope)

	if len(ret) == 0 {
		panic("no return value specified for AllCategories")
	}

	var r0 []database.TagCategory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TagScope) ([]database.TagCategory, error)); ok {
		return rf(ctx, scope)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.TagScope) []database.TagCategory); ok {
		r0 = rf(ctx, scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.TagCategory)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.TagScope) error); ok {
		r1 = rf(ctx, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllCategories'
type MockTagStore_AllCategories_Call struct {
	*mock.Call
}

// AllCategories is a helper method to define mock.On call
//   - ctx context.Context
//   - scope types.TagScope
func (_e *MockTagStore_Expecter) AllCategories(ctx interface{}, scope interface{}) *MockTagStore_AllCategories_Call {
	return &MockTagStore_AllCategories_Call{Call: _e.mock.On("AllCategories", ctx, scope)}
}

func (_c *MockTagStore_AllCategories_Call) Run(run func(ctx context.Context, scope types.TagScope)) *MockTagStore_AllCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TagScope))
	})
	return _c
}

func (_c *MockTagStore_AllCategories_Call) Return(_a0 []database.TagCategory, _a1 error) *MockTagStore_AllCategories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllCategories_Call) RunAndReturn(run func(context.Context, types.TagScope) ([]database.TagCategory, error)) *MockTagStore_AllCategories_Call {
	_c.Call.Return(run)
	return _c
}

// AllCodeCategories provides a mock function with given fields: ctx
func (_m *MockTagStore) AllCodeCategories(ctx context.Context) ([]database.TagCategory, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllCodeCategories")
	}

	var r0 []database.TagCategory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]database.TagCategory, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []database.TagCategory); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.TagCategory)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllCodeCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllCodeCategories'
type MockTagStore_AllCodeCategories_Call struct {
	*mock.Call
}

// AllCodeCategories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllCodeCategories(ctx interface{}) *MockTagStore_AllCodeCategories_Call {
	return &MockTagStore_AllCodeCategories_Call{Call: _e.mock.On("AllCodeCategories", ctx)}
}

func (_c *MockTagStore_AllCodeCategories_Call) Run(run func(ctx context.Context)) *MockTagStore_AllCodeCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllCodeCategories_Call) Return(_a0 []database.TagCategory, _a1 error) *MockTagStore_AllCodeCategories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllCodeCategories_Call) RunAndReturn(run func(context.Context) ([]database.TagCategory, error)) *MockTagStore_AllCodeCategories_Call {
	_c.Call.Return(run)
	return _c
}

// AllCodeTags provides a mock function with given fields: ctx
func (_m *MockTagStore) AllCodeTags(ctx context.Context) ([]*database.Tag, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllCodeTags")
	}

	var r0 []*database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*database.Tag, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*database.Tag); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllCodeTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllCodeTags'
type MockTagStore_AllCodeTags_Call struct {
	*mock.Call
}

// AllCodeTags is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllCodeTags(ctx interface{}) *MockTagStore_AllCodeTags_Call {
	return &MockTagStore_AllCodeTags_Call{Call: _e.mock.On("AllCodeTags", ctx)}
}

func (_c *MockTagStore_AllCodeTags_Call) Run(run func(ctx context.Context)) *MockTagStore_AllCodeTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllCodeTags_Call) Return(_a0 []*database.Tag, _a1 error) *MockTagStore_AllCodeTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllCodeTags_Call) RunAndReturn(run func(context.Context) ([]*database.Tag, error)) *MockTagStore_AllCodeTags_Call {
	_c.Call.Return(run)
	return _c
}

// AllDatasetCategories provides a mock function with given fields: ctx
func (_m *MockTagStore) AllDatasetCategories(ctx context.Context) ([]database.TagCategory, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllDatasetCategories")
	}

	var r0 []database.TagCategory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]database.TagCategory, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []database.TagCategory); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.TagCategory)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllDatasetCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllDatasetCategories'
type MockTagStore_AllDatasetCategories_Call struct {
	*mock.Call
}

// AllDatasetCategories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllDatasetCategories(ctx interface{}) *MockTagStore_AllDatasetCategories_Call {
	return &MockTagStore_AllDatasetCategories_Call{Call: _e.mock.On("AllDatasetCategories", ctx)}
}

func (_c *MockTagStore_AllDatasetCategories_Call) Run(run func(ctx context.Context)) *MockTagStore_AllDatasetCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllDatasetCategories_Call) Return(_a0 []database.TagCategory, _a1 error) *MockTagStore_AllDatasetCategories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllDatasetCategories_Call) RunAndReturn(run func(context.Context) ([]database.TagCategory, error)) *MockTagStore_AllDatasetCategories_Call {
	_c.Call.Return(run)
	return _c
}

// AllDatasetTags provides a mock function with given fields: ctx
func (_m *MockTagStore) AllDatasetTags(ctx context.Context) ([]*database.Tag, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllDatasetTags")
	}

	var r0 []*database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*database.Tag, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*database.Tag); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllDatasetTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllDatasetTags'
type MockTagStore_AllDatasetTags_Call struct {
	*mock.Call
}

// AllDatasetTags is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllDatasetTags(ctx interface{}) *MockTagStore_AllDatasetTags_Call {
	return &MockTagStore_AllDatasetTags_Call{Call: _e.mock.On("AllDatasetTags", ctx)}
}

func (_c *MockTagStore_AllDatasetTags_Call) Run(run func(ctx context.Context)) *MockTagStore_AllDatasetTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllDatasetTags_Call) Return(_a0 []*database.Tag, _a1 error) *MockTagStore_AllDatasetTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllDatasetTags_Call) RunAndReturn(run func(context.Context) ([]*database.Tag, error)) *MockTagStore_AllDatasetTags_Call {
	_c.Call.Return(run)
	return _c
}

// AllMCPTags provides a mock function with given fields: ctx
func (_m *MockTagStore) AllMCPTags(ctx context.Context) ([]*database.Tag, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllMCPTags")
	}

	var r0 []*database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*database.Tag, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*database.Tag); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllMCPTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllMCPTags'
type MockTagStore_AllMCPTags_Call struct {
	*mock.Call
}

// AllMCPTags is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllMCPTags(ctx interface{}) *MockTagStore_AllMCPTags_Call {
	return &MockTagStore_AllMCPTags_Call{Call: _e.mock.On("AllMCPTags", ctx)}
}

func (_c *MockTagStore_AllMCPTags_Call) Run(run func(ctx context.Context)) *MockTagStore_AllMCPTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllMCPTags_Call) Return(_a0 []*database.Tag, _a1 error) *MockTagStore_AllMCPTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllMCPTags_Call) RunAndReturn(run func(context.Context) ([]*database.Tag, error)) *MockTagStore_AllMCPTags_Call {
	_c.Call.Return(run)
	return _c
}

// AllModelCategories provides a mock function with given fields: ctx
func (_m *MockTagStore) AllModelCategories(ctx context.Context) ([]database.TagCategory, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllModelCategories")
	}

	var r0 []database.TagCategory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]database.TagCategory, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []database.TagCategory); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.TagCategory)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllModelCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllModelCategories'
type MockTagStore_AllModelCategories_Call struct {
	*mock.Call
}

// AllModelCategories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllModelCategories(ctx interface{}) *MockTagStore_AllModelCategories_Call {
	return &MockTagStore_AllModelCategories_Call{Call: _e.mock.On("AllModelCategories", ctx)}
}

func (_c *MockTagStore_AllModelCategories_Call) Run(run func(ctx context.Context)) *MockTagStore_AllModelCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllModelCategories_Call) Return(_a0 []database.TagCategory, _a1 error) *MockTagStore_AllModelCategories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllModelCategories_Call) RunAndReturn(run func(context.Context) ([]database.TagCategory, error)) *MockTagStore_AllModelCategories_Call {
	_c.Call.Return(run)
	return _c
}

// AllModelTags provides a mock function with given fields: ctx
func (_m *MockTagStore) AllModelTags(ctx context.Context) ([]*database.Tag, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllModelTags")
	}

	var r0 []*database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*database.Tag, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*database.Tag); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllModelTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllModelTags'
type MockTagStore_AllModelTags_Call struct {
	*mock.Call
}

// AllModelTags is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllModelTags(ctx interface{}) *MockTagStore_AllModelTags_Call {
	return &MockTagStore_AllModelTags_Call{Call: _e.mock.On("AllModelTags", ctx)}
}

func (_c *MockTagStore_AllModelTags_Call) Run(run func(ctx context.Context)) *MockTagStore_AllModelTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllModelTags_Call) Return(_a0 []*database.Tag, _a1 error) *MockTagStore_AllModelTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllModelTags_Call) RunAndReturn(run func(context.Context) ([]*database.Tag, error)) *MockTagStore_AllModelTags_Call {
	_c.Call.Return(run)
	return _c
}

// AllPromptCategories provides a mock function with given fields: ctx
func (_m *MockTagStore) AllPromptCategories(ctx context.Context) ([]database.TagCategory, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllPromptCategories")
	}

	var r0 []database.TagCategory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]database.TagCategory, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []database.TagCategory); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.TagCategory)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllPromptCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllPromptCategories'
type MockTagStore_AllPromptCategories_Call struct {
	*mock.Call
}

// AllPromptCategories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllPromptCategories(ctx interface{}) *MockTagStore_AllPromptCategories_Call {
	return &MockTagStore_AllPromptCategories_Call{Call: _e.mock.On("AllPromptCategories", ctx)}
}

func (_c *MockTagStore_AllPromptCategories_Call) Run(run func(ctx context.Context)) *MockTagStore_AllPromptCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllPromptCategories_Call) Return(_a0 []database.TagCategory, _a1 error) *MockTagStore_AllPromptCategories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllPromptCategories_Call) RunAndReturn(run func(context.Context) ([]database.TagCategory, error)) *MockTagStore_AllPromptCategories_Call {
	_c.Call.Return(run)
	return _c
}

// AllPromptTags provides a mock function with given fields: ctx
func (_m *MockTagStore) AllPromptTags(ctx context.Context) ([]*database.Tag, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllPromptTags")
	}

	var r0 []*database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*database.Tag, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*database.Tag); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllPromptTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllPromptTags'
type MockTagStore_AllPromptTags_Call struct {
	*mock.Call
}

// AllPromptTags is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllPromptTags(ctx interface{}) *MockTagStore_AllPromptTags_Call {
	return &MockTagStore_AllPromptTags_Call{Call: _e.mock.On("AllPromptTags", ctx)}
}

func (_c *MockTagStore_AllPromptTags_Call) Run(run func(ctx context.Context)) *MockTagStore_AllPromptTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllPromptTags_Call) Return(_a0 []*database.Tag, _a1 error) *MockTagStore_AllPromptTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllPromptTags_Call) RunAndReturn(run func(context.Context) ([]*database.Tag, error)) *MockTagStore_AllPromptTags_Call {
	_c.Call.Return(run)
	return _c
}

// AllSpaceCategories provides a mock function with given fields: ctx
func (_m *MockTagStore) AllSpaceCategories(ctx context.Context) ([]database.TagCategory, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllSpaceCategories")
	}

	var r0 []database.TagCategory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]database.TagCategory, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []database.TagCategory); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]database.TagCategory)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllSpaceCategories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllSpaceCategories'
type MockTagStore_AllSpaceCategories_Call struct {
	*mock.Call
}

// AllSpaceCategories is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllSpaceCategories(ctx interface{}) *MockTagStore_AllSpaceCategories_Call {
	return &MockTagStore_AllSpaceCategories_Call{Call: _e.mock.On("AllSpaceCategories", ctx)}
}

func (_c *MockTagStore_AllSpaceCategories_Call) Run(run func(ctx context.Context)) *MockTagStore_AllSpaceCategories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllSpaceCategories_Call) Return(_a0 []database.TagCategory, _a1 error) *MockTagStore_AllSpaceCategories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllSpaceCategories_Call) RunAndReturn(run func(context.Context) ([]database.TagCategory, error)) *MockTagStore_AllSpaceCategories_Call {
	_c.Call.Return(run)
	return _c
}

// AllSpaceTags provides a mock function with given fields: ctx
func (_m *MockTagStore) AllSpaceTags(ctx context.Context) ([]*database.Tag, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AllSpaceTags")
	}

	var r0 []*database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*database.Tag, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*database.Tag); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllSpaceTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllSpaceTags'
type MockTagStore_AllSpaceTags_Call struct {
	*mock.Call
}

// AllSpaceTags is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTagStore_Expecter) AllSpaceTags(ctx interface{}) *MockTagStore_AllSpaceTags_Call {
	return &MockTagStore_AllSpaceTags_Call{Call: _e.mock.On("AllSpaceTags", ctx)}
}

func (_c *MockTagStore_AllSpaceTags_Call) Run(run func(ctx context.Context)) *MockTagStore_AllSpaceTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTagStore_AllSpaceTags_Call) Return(_a0 []*database.Tag, _a1 error) *MockTagStore_AllSpaceTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllSpaceTags_Call) RunAndReturn(run func(context.Context) ([]*database.Tag, error)) *MockTagStore_AllSpaceTags_Call {
	_c.Call.Return(run)
	return _c
}

// AllTags provides a mock function with given fields: ctx, filter
func (_m *MockTagStore) AllTags(ctx context.Context, filter *types.TagFilter) ([]*database.Tag, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for AllTags")
	}

	var r0 []*database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.TagFilter) ([]*database.Tag, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.TagFilter) []*database.Tag); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.TagFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_AllTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllTags'
type MockTagStore_AllTags_Call struct {
	*mock.Call
}

// AllTags is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *types.TagFilter
func (_e *MockTagStore_Expecter) AllTags(ctx interface{}, filter interface{}) *MockTagStore_AllTags_Call {
	return &MockTagStore_AllTags_Call{Call: _e.mock.On("AllTags", ctx, filter)}
}

func (_c *MockTagStore_AllTags_Call) Run(run func(ctx context.Context, filter *types.TagFilter)) *MockTagStore_AllTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.TagFilter))
	})
	return _c
}

func (_c *MockTagStore_AllTags_Call) Return(_a0 []*database.Tag, _a1 error) *MockTagStore_AllTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_AllTags_Call) RunAndReturn(run func(context.Context, *types.TagFilter) ([]*database.Tag, error)) *MockTagStore_AllTags_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCategory provides a mock function with given fields: ctx, category
func (_m *MockTagStore) CreateCategory(ctx context.Context, category database.TagCategory) (*database.TagCategory, error) {
	ret := _m.Called(ctx, category)

	if len(ret) == 0 {
		panic("no return value specified for CreateCategory")
	}

	var r0 *database.TagCategory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.TagCategory) (*database.TagCategory, error)); ok {
		return rf(ctx, category)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.TagCategory) *database.TagCategory); ok {
		r0 = rf(ctx, category)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.TagCategory)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.TagCategory) error); ok {
		r1 = rf(ctx, category)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_CreateCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCategory'
type MockTagStore_CreateCategory_Call struct {
	*mock.Call
}

// CreateCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - category database.TagCategory
func (_e *MockTagStore_Expecter) CreateCategory(ctx interface{}, category interface{}) *MockTagStore_CreateCategory_Call {
	return &MockTagStore_CreateCategory_Call{Call: _e.mock.On("CreateCategory", ctx, category)}
}

func (_c *MockTagStore_CreateCategory_Call) Run(run func(ctx context.Context, category database.TagCategory)) *MockTagStore_CreateCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.TagCategory))
	})
	return _c
}

func (_c *MockTagStore_CreateCategory_Call) Return(_a0 *database.TagCategory, _a1 error) *MockTagStore_CreateCategory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_CreateCategory_Call) RunAndReturn(run func(context.Context, database.TagCategory) (*database.TagCategory, error)) *MockTagStore_CreateCategory_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTag provides a mock function with given fields: ctx, category, name, group, scope
func (_m *MockTagStore) CreateTag(ctx context.Context, category string, name string, group string, scope types.TagScope) (database.Tag, error) {
	ret := _m.Called(ctx, category, name, group, scope)

	if len(ret) == 0 {
		panic("no return value specified for CreateTag")
	}

	var r0 database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, types.TagScope) (database.Tag, error)); ok {
		return rf(ctx, category, name, group, scope)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, types.TagScope) database.Tag); ok {
		r0 = rf(ctx, category, name, group, scope)
	} else {
		r0 = ret.Get(0).(database.Tag)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, types.TagScope) error); ok {
		r1 = rf(ctx, category, name, group, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_CreateTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTag'
type MockTagStore_CreateTag_Call struct {
	*mock.Call
}

// CreateTag is a helper method to define mock.On call
//   - ctx context.Context
//   - category string
//   - name string
//   - group string
//   - scope types.TagScope
func (_e *MockTagStore_Expecter) CreateTag(ctx interface{}, category interface{}, name interface{}, group interface{}, scope interface{}) *MockTagStore_CreateTag_Call {
	return &MockTagStore_CreateTag_Call{Call: _e.mock.On("CreateTag", ctx, category, name, group, scope)}
}

func (_c *MockTagStore_CreateTag_Call) Run(run func(ctx context.Context, category string, name string, group string, scope types.TagScope)) *MockTagStore_CreateTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(types.TagScope))
	})
	return _c
}

func (_c *MockTagStore_CreateTag_Call) Return(_a0 database.Tag, _a1 error) *MockTagStore_CreateTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_CreateTag_Call) RunAndReturn(run func(context.Context, string, string, string, types.TagScope) (database.Tag, error)) *MockTagStore_CreateTag_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCategory provides a mock function with given fields: ctx, id
func (_m *MockTagStore) DeleteCategory(ctx context.Context, id int64) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCategory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTagStore_DeleteCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCategory'
type MockTagStore_DeleteCategory_Call struct {
	*mock.Call
}

// DeleteCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockTagStore_Expecter) DeleteCategory(ctx interface{}, id interface{}) *MockTagStore_DeleteCategory_Call {
	return &MockTagStore_DeleteCategory_Call{Call: _e.mock.On("DeleteCategory", ctx, id)}
}

func (_c *MockTagStore_DeleteCategory_Call) Run(run func(ctx context.Context, id int64)) *MockTagStore_DeleteCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockTagStore_DeleteCategory_Call) Return(_a0 error) *MockTagStore_DeleteCategory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTagStore_DeleteCategory_Call) RunAndReturn(run func(context.Context, int64) error) *MockTagStore_DeleteCategory_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTagByID provides a mock function with given fields: ctx, id
func (_m *MockTagStore) DeleteTagByID(ctx context.Context, id int64) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTagByID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTagStore_DeleteTagByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTagByID'
type MockTagStore_DeleteTagByID_Call struct {
	*mock.Call
}

// DeleteTagByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockTagStore_Expecter) DeleteTagByID(ctx interface{}, id interface{}) *MockTagStore_DeleteTagByID_Call {
	return &MockTagStore_DeleteTagByID_Call{Call: _e.mock.On("DeleteTagByID", ctx, id)}
}

func (_c *MockTagStore_DeleteTagByID_Call) Run(run func(ctx context.Context, id int64)) *MockTagStore_DeleteTagByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockTagStore_DeleteTagByID_Call) Return(_a0 error) *MockTagStore_DeleteTagByID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTagStore_DeleteTagByID_Call) RunAndReturn(run func(context.Context, int64) error) *MockTagStore_DeleteTagByID_Call {
	_c.Call.Return(run)
	return _c
}

// FindOrCreate provides a mock function with given fields: ctx, tag
func (_m *MockTagStore) FindOrCreate(ctx context.Context, tag database.Tag) (*database.Tag, error) {
	ret := _m.Called(ctx, tag)

	if len(ret) == 0 {
		panic("no return value specified for FindOrCreate")
	}

	var r0 *database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.Tag) (*database.Tag, error)); ok {
		return rf(ctx, tag)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.Tag) *database.Tag); ok {
		r0 = rf(ctx, tag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.Tag) error); ok {
		r1 = rf(ctx, tag)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_FindOrCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOrCreate'
type MockTagStore_FindOrCreate_Call struct {
	*mock.Call
}

// FindOrCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - tag database.Tag
func (_e *MockTagStore_Expecter) FindOrCreate(ctx interface{}, tag interface{}) *MockTagStore_FindOrCreate_Call {
	return &MockTagStore_FindOrCreate_Call{Call: _e.mock.On("FindOrCreate", ctx, tag)}
}

func (_c *MockTagStore_FindOrCreate_Call) Run(run func(ctx context.Context, tag database.Tag)) *MockTagStore_FindOrCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.Tag))
	})
	return _c
}

func (_c *MockTagStore_FindOrCreate_Call) Return(_a0 *database.Tag, _a1 error) *MockTagStore_FindOrCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_FindOrCreate_Call) RunAndReturn(run func(context.Context, database.Tag) (*database.Tag, error)) *MockTagStore_FindOrCreate_Call {
	_c.Call.Return(run)
	return _c
}

// FindTag provides a mock function with given fields: ctx, name, scope, category
func (_m *MockTagStore) FindTag(ctx context.Context, name string, scope string, category string) (*database.Tag, error) {
	ret := _m.Called(ctx, name, scope, category)

	if len(ret) == 0 {
		panic("no return value specified for FindTag")
	}

	var r0 *database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*database.Tag, error)); ok {
		return rf(ctx, name, scope, category)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *database.Tag); ok {
		r0 = rf(ctx, name, scope, category)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, name, scope, category)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_FindTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTag'
type MockTagStore_FindTag_Call struct {
	*mock.Call
}

// FindTag is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - scope string
//   - category string
func (_e *MockTagStore_Expecter) FindTag(ctx interface{}, name interface{}, scope interface{}, category interface{}) *MockTagStore_FindTag_Call {
	return &MockTagStore_FindTag_Call{Call: _e.mock.On("FindTag", ctx, name, scope, category)}
}

func (_c *MockTagStore_FindTag_Call) Run(run func(ctx context.Context, name string, scope string, category string)) *MockTagStore_FindTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockTagStore_FindTag_Call) Return(_a0 *database.Tag, _a1 error) *MockTagStore_FindTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_FindTag_Call) RunAndReturn(run func(context.Context, string, string, string) (*database.Tag, error)) *MockTagStore_FindTag_Call {
	_c.Call.Return(run)
	return _c
}

// FindTagByID provides a mock function with given fields: ctx, id
func (_m *MockTagStore) FindTagByID(ctx context.Context, id int64) (*database.Tag, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for FindTagByID")
	}

	var r0 *database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*database.Tag, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *database.Tag); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_FindTagByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTagByID'
type MockTagStore_FindTagByID_Call struct {
	*mock.Call
}

// FindTagByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockTagStore_Expecter) FindTagByID(ctx interface{}, id interface{}) *MockTagStore_FindTagByID_Call {
	return &MockTagStore_FindTagByID_Call{Call: _e.mock.On("FindTagByID", ctx, id)}
}

func (_c *MockTagStore_FindTagByID_Call) Run(run func(ctx context.Context, id int64)) *MockTagStore_FindTagByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockTagStore_FindTagByID_Call) Return(_a0 *database.Tag, _a1 error) *MockTagStore_FindTagByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_FindTagByID_Call) RunAndReturn(run func(context.Context, int64) (*database.Tag, error)) *MockTagStore_FindTagByID_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRepoTags provides a mock function with given fields: ctx, repoID, tagIDs
func (_m *MockTagStore) RemoveRepoTags(ctx context.Context, repoID int64, tagIDs []int64) error {
	ret := _m.Called(ctx, repoID, tagIDs)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRepoTags")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, []int64) error); ok {
		r0 = rf(ctx, repoID, tagIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTagStore_RemoveRepoTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRepoTags'
type MockTagStore_RemoveRepoTags_Call struct {
	*mock.Call
}

// RemoveRepoTags is a helper method to define mock.On call
//   - ctx context.Context
//   - repoID int64
//   - tagIDs []int64
func (_e *MockTagStore_Expecter) RemoveRepoTags(ctx interface{}, repoID interface{}, tagIDs interface{}) *MockTagStore_RemoveRepoTags_Call {
	return &MockTagStore_RemoveRepoTags_Call{Call: _e.mock.On("RemoveRepoTags", ctx, repoID, tagIDs)}
}

func (_c *MockTagStore_RemoveRepoTags_Call) Run(run func(ctx context.Context, repoID int64, tagIDs []int64)) *MockTagStore_RemoveRepoTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].([]int64))
	})
	return _c
}

func (_c *MockTagStore_RemoveRepoTags_Call) Return(err error) *MockTagStore_RemoveRepoTags_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTagStore_RemoveRepoTags_Call) RunAndReturn(run func(context.Context, int64, []int64) error) *MockTagStore_RemoveRepoTags_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRepoTagsByCategory provides a mock function with given fields: ctx, repoID, category
func (_m *MockTagStore) RemoveRepoTagsByCategory(ctx context.Context, repoID int64, category []string) error {
	ret := _m.Called(ctx, repoID, category)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRepoTagsByCategory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, []string) error); ok {
		r0 = rf(ctx, repoID, category)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTagStore_RemoveRepoTagsByCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRepoTagsByCategory'
type MockTagStore_RemoveRepoTagsByCategory_Call struct {
	*mock.Call
}

// RemoveRepoTagsByCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - repoID int64
//   - category []string
func (_e *MockTagStore_Expecter) RemoveRepoTagsByCategory(ctx interface{}, repoID interface{}, category interface{}) *MockTagStore_RemoveRepoTagsByCategory_Call {
	return &MockTagStore_RemoveRepoTagsByCategory_Call{Call: _e.mock.On("RemoveRepoTagsByCategory", ctx, repoID, category)}
}

func (_c *MockTagStore_RemoveRepoTagsByCategory_Call) Run(run func(ctx context.Context, repoID int64, category []string)) *MockTagStore_RemoveRepoTagsByCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].([]string))
	})
	return _c
}

func (_c *MockTagStore_RemoveRepoTagsByCategory_Call) Return(err error) *MockTagStore_RemoveRepoTagsByCategory_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTagStore_RemoveRepoTagsByCategory_Call) RunAndReturn(run func(context.Context, int64, []string) error) *MockTagStore_RemoveRepoTagsByCategory_Call {
	_c.Call.Return(run)
	return _c
}

// SaveTags provides a mock function with given fields: ctx, tags
func (_m *MockTagStore) SaveTags(ctx context.Context, tags []*database.Tag) error {
	ret := _m.Called(ctx, tags)

	if len(ret) == 0 {
		panic("no return value specified for SaveTags")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*database.Tag) error); ok {
		r0 = rf(ctx, tags)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTagStore_SaveTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveTags'
type MockTagStore_SaveTags_Call struct {
	*mock.Call
}

// SaveTags is a helper method to define mock.On call
//   - ctx context.Context
//   - tags []*database.Tag
func (_e *MockTagStore_Expecter) SaveTags(ctx interface{}, tags interface{}) *MockTagStore_SaveTags_Call {
	return &MockTagStore_SaveTags_Call{Call: _e.mock.On("SaveTags", ctx, tags)}
}

func (_c *MockTagStore_SaveTags_Call) Run(run func(ctx context.Context, tags []*database.Tag)) *MockTagStore_SaveTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*database.Tag))
	})
	return _c
}

func (_c *MockTagStore_SaveTags_Call) Return(_a0 error) *MockTagStore_SaveTags_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTagStore_SaveTags_Call) RunAndReturn(run func(context.Context, []*database.Tag) error) *MockTagStore_SaveTags_Call {
	_c.Call.Return(run)
	return _c
}

// SetLibraryTag provides a mock function with given fields: ctx, repoType, namespace, name, newTag, oldTag
func (_m *MockTagStore) SetLibraryTag(ctx context.Context, repoType types.RepositoryType, namespace string, name string, newTag *database.Tag, oldTag *database.Tag) error {
	ret := _m.Called(ctx, repoType, namespace, name, newTag, oldTag)

	if len(ret) == 0 {
		panic("no return value specified for SetLibraryTag")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.RepositoryType, string, string, *database.Tag, *database.Tag) error); ok {
		r0 = rf(ctx, repoType, namespace, name, newTag, oldTag)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTagStore_SetLibraryTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLibraryTag'
type MockTagStore_SetLibraryTag_Call struct {
	*mock.Call
}

// SetLibraryTag is a helper method to define mock.On call
//   - ctx context.Context
//   - repoType types.RepositoryType
//   - namespace string
//   - name string
//   - newTag *database.Tag
//   - oldTag *database.Tag
func (_e *MockTagStore_Expecter) SetLibraryTag(ctx interface{}, repoType interface{}, namespace interface{}, name interface{}, newTag interface{}, oldTag interface{}) *MockTagStore_SetLibraryTag_Call {
	return &MockTagStore_SetLibraryTag_Call{Call: _e.mock.On("SetLibraryTag", ctx, repoType, namespace, name, newTag, oldTag)}
}

func (_c *MockTagStore_SetLibraryTag_Call) Run(run func(ctx context.Context, repoType types.RepositoryType, namespace string, name string, newTag *database.Tag, oldTag *database.Tag)) *MockTagStore_SetLibraryTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.RepositoryType), args[2].(string), args[3].(string), args[4].(*database.Tag), args[5].(*database.Tag))
	})
	return _c
}

func (_c *MockTagStore_SetLibraryTag_Call) Return(err error) *MockTagStore_SetLibraryTag_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTagStore_SetLibraryTag_Call) RunAndReturn(run func(context.Context, types.RepositoryType, string, string, *database.Tag, *database.Tag) error) *MockTagStore_SetLibraryTag_Call {
	_c.Call.Return(run)
	return _c
}

// SetMetaTags provides a mock function with given fields: ctx, repoType, namespace, name, tags
func (_m *MockTagStore) SetMetaTags(ctx context.Context, repoType types.RepositoryType, namespace string, name string, tags []*database.Tag) ([]*database.RepositoryTag, error) {
	ret := _m.Called(ctx, repoType, namespace, name, tags)

	if len(ret) == 0 {
		panic("no return value specified for SetMetaTags")
	}

	var r0 []*database.RepositoryTag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.RepositoryType, string, string, []*database.Tag) ([]*database.RepositoryTag, error)); ok {
		return rf(ctx, repoType, namespace, name, tags)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.RepositoryType, string, string, []*database.Tag) []*database.RepositoryTag); ok {
		r0 = rf(ctx, repoType, namespace, name, tags)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*database.RepositoryTag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.RepositoryType, string, string, []*database.Tag) error); ok {
		r1 = rf(ctx, repoType, namespace, name, tags)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_SetMetaTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetMetaTags'
type MockTagStore_SetMetaTags_Call struct {
	*mock.Call
}

// SetMetaTags is a helper method to define mock.On call
//   - ctx context.Context
//   - repoType types.RepositoryType
//   - namespace string
//   - name string
//   - tags []*database.Tag
func (_e *MockTagStore_Expecter) SetMetaTags(ctx interface{}, repoType interface{}, namespace interface{}, name interface{}, tags interface{}) *MockTagStore_SetMetaTags_Call {
	return &MockTagStore_SetMetaTags_Call{Call: _e.mock.On("SetMetaTags", ctx, repoType, namespace, name, tags)}
}

func (_c *MockTagStore_SetMetaTags_Call) Run(run func(ctx context.Context, repoType types.RepositoryType, namespace string, name string, tags []*database.Tag)) *MockTagStore_SetMetaTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.RepositoryType), args[2].(string), args[3].(string), args[4].([]*database.Tag))
	})
	return _c
}

func (_c *MockTagStore_SetMetaTags_Call) Return(repoTags []*database.RepositoryTag, err error) *MockTagStore_SetMetaTags_Call {
	_c.Call.Return(repoTags, err)
	return _c
}

func (_c *MockTagStore_SetMetaTags_Call) RunAndReturn(run func(context.Context, types.RepositoryType, string, string, []*database.Tag) ([]*database.RepositoryTag, error)) *MockTagStore_SetMetaTags_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCategory provides a mock function with given fields: ctx, category
func (_m *MockTagStore) UpdateCategory(ctx context.Context, category database.TagCategory) (*database.TagCategory, error) {
	ret := _m.Called(ctx, category)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCategory")
	}

	var r0 *database.TagCategory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, database.TagCategory) (*database.TagCategory, error)); ok {
		return rf(ctx, category)
	}
	if rf, ok := ret.Get(0).(func(context.Context, database.TagCategory) *database.TagCategory); ok {
		r0 = rf(ctx, category)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.TagCategory)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, database.TagCategory) error); ok {
		r1 = rf(ctx, category)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_UpdateCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCategory'
type MockTagStore_UpdateCategory_Call struct {
	*mock.Call
}

// UpdateCategory is a helper method to define mock.On call
//   - ctx context.Context
//   - category database.TagCategory
func (_e *MockTagStore_Expecter) UpdateCategory(ctx interface{}, category interface{}) *MockTagStore_UpdateCategory_Call {
	return &MockTagStore_UpdateCategory_Call{Call: _e.mock.On("UpdateCategory", ctx, category)}
}

func (_c *MockTagStore_UpdateCategory_Call) Run(run func(ctx context.Context, category database.TagCategory)) *MockTagStore_UpdateCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(database.TagCategory))
	})
	return _c
}

func (_c *MockTagStore_UpdateCategory_Call) Return(_a0 *database.TagCategory, _a1 error) *MockTagStore_UpdateCategory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_UpdateCategory_Call) RunAndReturn(run func(context.Context, database.TagCategory) (*database.TagCategory, error)) *MockTagStore_UpdateCategory_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTagByID provides a mock function with given fields: ctx, tag
func (_m *MockTagStore) UpdateTagByID(ctx context.Context, tag *database.Tag) (*database.Tag, error) {
	ret := _m.Called(ctx, tag)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTagByID")
	}

	var r0 *database.Tag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *database.Tag) (*database.Tag, error)); ok {
		return rf(ctx, tag)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *database.Tag) *database.Tag); ok {
		r0 = rf(ctx, tag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Tag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *database.Tag) error); ok {
		r1 = rf(ctx, tag)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTagStore_UpdateTagByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTagByID'
type MockTagStore_UpdateTagByID_Call struct {
	*mock.Call
}

// UpdateTagByID is a helper method to define mock.On call
//   - ctx context.Context
//   - tag *database.Tag
func (_e *MockTagStore_Expecter) UpdateTagByID(ctx interface{}, tag interface{}) *MockTagStore_UpdateTagByID_Call {
	return &MockTagStore_UpdateTagByID_Call{Call: _e.mock.On("UpdateTagByID", ctx, tag)}
}

func (_c *MockTagStore_UpdateTagByID_Call) Run(run func(ctx context.Context, tag *database.Tag)) *MockTagStore_UpdateTagByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*database.Tag))
	})
	return _c
}

func (_c *MockTagStore_UpdateTagByID_Call) Return(_a0 *database.Tag, _a1 error) *MockTagStore_UpdateTagByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockTagStore_UpdateTagByID_Call) RunAndReturn(run func(context.Context, *database.Tag) (*database.Tag, error)) *MockTagStore_UpdateTagByID_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertRepoTags provides a mock function with given fields: ctx, repoID, oldTagIDs, newTagIDs
func (_m *MockTagStore) UpsertRepoTags(ctx context.Context, repoID int64, oldTagIDs []int64, newTagIDs []int64) error {
	ret := _m.Called(ctx, repoID, oldTagIDs, newTagIDs)

	if len(ret) == 0 {
		panic("no return value specified for UpsertRepoTags")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, []int64, []int64) error); ok {
		r0 = rf(ctx, repoID, oldTagIDs, newTagIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTagStore_UpsertRepoTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertRepoTags'
type MockTagStore_UpsertRepoTags_Call struct {
	*mock.Call
}

// UpsertRepoTags is a helper method to define mock.On call
//   - ctx context.Context
//   - repoID int64
//   - oldTagIDs []int64
//   - newTagIDs []int64
func (_e *MockTagStore_Expecter) UpsertRepoTags(ctx interface{}, repoID interface{}, oldTagIDs interface{}, newTagIDs interface{}) *MockTagStore_UpsertRepoTags_Call {
	return &MockTagStore_UpsertRepoTags_Call{Call: _e.mock.On("UpsertRepoTags", ctx, repoID, oldTagIDs, newTagIDs)}
}

func (_c *MockTagStore_UpsertRepoTags_Call) Run(run func(ctx context.Context, repoID int64, oldTagIDs []int64, newTagIDs []int64)) *MockTagStore_UpsertRepoTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].([]int64), args[3].([]int64))
	})
	return _c
}

func (_c *MockTagStore_UpsertRepoTags_Call) Return(err error) *MockTagStore_UpsertRepoTags_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTagStore_UpsertRepoTags_Call) RunAndReturn(run func(context.Context, int64, []int64, []int64) error) *MockTagStore_UpsertRepoTags_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTagStore creates a new instance of MockTagStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTagStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTagStore {
	mock := &MockTagStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
