// Code generated by mockery v2.53.5. DO NOT EDIT.

package deploy

import (
	context "context"

	deploy "opencsg.com/csghub-server/builder/deploy"
	database "opencsg.com/csghub-server/builder/store/database"

	loki "opencsg.com/csghub-server/builder/loki"

	mock "github.com/stretchr/testify/mock"

	types "opencsg.com/csghub-server/common/types"
)

// MockDeployer is an autogenerated mock type for the Deployer type
type MockDeployer struct {
	mock.Mock
}

type MockDeployer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDeployer) EXPECT() *MockDeployer_Expecter {
	return &MockDeployer_Expecter{mock: &_m.Mock}
}

// CheckHeartbeatTimeout provides a mock function with given fields: ctx, clusterId
func (_m *MockDeployer) CheckHeartbeatTimeout(ctx context.Context, clusterId string) (bool, error) {
	ret := _m.Called(ctx, clusterId)

	if len(ret) == 0 {
		panic("no return value specified for CheckHeartbeatTimeout")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, clusterId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, clusterId)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, clusterId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_CheckHeartbeatTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckHeartbeatTimeout'
type MockDeployer_CheckHeartbeatTimeout_Call struct {
	*mock.Call
}

// CheckHeartbeatTimeout is a helper method to define mock.On call
//   - ctx context.Context
//   - clusterId string
func (_e *MockDeployer_Expecter) CheckHeartbeatTimeout(ctx interface{}, clusterId interface{}) *MockDeployer_CheckHeartbeatTimeout_Call {
	return &MockDeployer_CheckHeartbeatTimeout_Call{Call: _e.mock.On("CheckHeartbeatTimeout", ctx, clusterId)}
}

func (_c *MockDeployer_CheckHeartbeatTimeout_Call) Run(run func(ctx context.Context, clusterId string)) *MockDeployer_CheckHeartbeatTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDeployer_CheckHeartbeatTimeout_Call) Return(_a0 bool, _a1 error) *MockDeployer_CheckHeartbeatTimeout_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_CheckHeartbeatTimeout_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockDeployer_CheckHeartbeatTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// CheckResourceAvailable provides a mock function with given fields: ctx, clusterId, orderDetailID, hardWare
func (_m *MockDeployer) CheckResourceAvailable(ctx context.Context, clusterId string, orderDetailID int64, hardWare *types.HardWare) (bool, error) {
	ret := _m.Called(ctx, clusterId, orderDetailID, hardWare)

	if len(ret) == 0 {
		panic("no return value specified for CheckResourceAvailable")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, *types.HardWare) (bool, error)); ok {
		return rf(ctx, clusterId, orderDetailID, hardWare)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, *types.HardWare) bool); ok {
		r0 = rf(ctx, clusterId, orderDetailID, hardWare)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64, *types.HardWare) error); ok {
		r1 = rf(ctx, clusterId, orderDetailID, hardWare)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_CheckResourceAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckResourceAvailable'
type MockDeployer_CheckResourceAvailable_Call struct {
	*mock.Call
}

// CheckResourceAvailable is a helper method to define mock.On call
//   - ctx context.Context
//   - clusterId string
//   - orderDetailID int64
//   - hardWare *types.HardWare
func (_e *MockDeployer_Expecter) CheckResourceAvailable(ctx interface{}, clusterId interface{}, orderDetailID interface{}, hardWare interface{}) *MockDeployer_CheckResourceAvailable_Call {
	return &MockDeployer_CheckResourceAvailable_Call{Call: _e.mock.On("CheckResourceAvailable", ctx, clusterId, orderDetailID, hardWare)}
}

func (_c *MockDeployer_CheckResourceAvailable_Call) Run(run func(ctx context.Context, clusterId string, orderDetailID int64, hardWare *types.HardWare)) *MockDeployer_CheckResourceAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(*types.HardWare))
	})
	return _c
}

func (_c *MockDeployer_CheckResourceAvailable_Call) Return(_a0 bool, _a1 error) *MockDeployer_CheckResourceAvailable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_CheckResourceAvailable_Call) RunAndReturn(run func(context.Context, string, int64, *types.HardWare) (bool, error)) *MockDeployer_CheckResourceAvailable_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEvaluation provides a mock function with given fields: ctx, req
func (_m *MockDeployer) DeleteEvaluation(ctx context.Context, req types.ArgoWorkFlowDeleteReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEvaluation")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.ArgoWorkFlowDeleteReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_DeleteEvaluation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEvaluation'
type MockDeployer_DeleteEvaluation_Call struct {
	*mock.Call
}

// DeleteEvaluation is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.ArgoWorkFlowDeleteReq
func (_e *MockDeployer_Expecter) DeleteEvaluation(ctx interface{}, req interface{}) *MockDeployer_DeleteEvaluation_Call {
	return &MockDeployer_DeleteEvaluation_Call{Call: _e.mock.On("DeleteEvaluation", ctx, req)}
}

func (_c *MockDeployer_DeleteEvaluation_Call) Run(run func(ctx context.Context, req types.ArgoWorkFlowDeleteReq)) *MockDeployer_DeleteEvaluation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.ArgoWorkFlowDeleteReq))
	})
	return _c
}

func (_c *MockDeployer_DeleteEvaluation_Call) Return(_a0 error) *MockDeployer_DeleteEvaluation_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDeployer_DeleteEvaluation_Call) RunAndReturn(run func(context.Context, types.ArgoWorkFlowDeleteReq) error) *MockDeployer_DeleteEvaluation_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteFinetuneJob provides a mock function with given fields: ctx, req
func (_m *MockDeployer) DeleteFinetuneJob(ctx context.Context, req types.ArgoWorkFlowDeleteReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFinetuneJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.ArgoWorkFlowDeleteReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_DeleteFinetuneJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFinetuneJob'
type MockDeployer_DeleteFinetuneJob_Call struct {
	*mock.Call
}

// DeleteFinetuneJob is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.ArgoWorkFlowDeleteReq
func (_e *MockDeployer_Expecter) DeleteFinetuneJob(ctx interface{}, req interface{}) *MockDeployer_DeleteFinetuneJob_Call {
	return &MockDeployer_DeleteFinetuneJob_Call{Call: _e.mock.On("DeleteFinetuneJob", ctx, req)}
}

func (_c *MockDeployer_DeleteFinetuneJob_Call) Run(run func(ctx context.Context, req types.ArgoWorkFlowDeleteReq)) *MockDeployer_DeleteFinetuneJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.ArgoWorkFlowDeleteReq))
	})
	return _c
}

func (_c *MockDeployer_DeleteFinetuneJob_Call) Return(_a0 error) *MockDeployer_DeleteFinetuneJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDeployer_DeleteFinetuneJob_Call) RunAndReturn(run func(context.Context, types.ArgoWorkFlowDeleteReq) error) *MockDeployer_DeleteFinetuneJob_Call {
	_c.Call.Return(run)
	return _c
}

// Deploy provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Deploy(ctx context.Context, dr types.DeployRepo) (int64, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Deploy")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (int64, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) int64); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) error); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_Deploy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Deploy'
type MockDeployer_Deploy_Call struct {
	*mock.Call
}

// Deploy is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Deploy(ctx interface{}, dr interface{}) *MockDeployer_Deploy_Call {
	return &MockDeployer_Deploy_Call{Call: _e.mock.On("Deploy", ctx, dr)}
}

func (_c *MockDeployer_Deploy_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Deploy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Deploy_Call) Return(deployID int64, err error) *MockDeployer_Deploy_Call {
	_c.Call.Return(deployID, err)
	return _c
}

func (_c *MockDeployer_Deploy_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (int64, error)) *MockDeployer_Deploy_Call {
	_c.Call.Return(run)
	return _c
}

// Exist provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Exist(ctx context.Context, dr types.DeployRepo) (bool, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Exist")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (bool, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) bool); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) error); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_Exist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exist'
type MockDeployer_Exist_Call struct {
	*mock.Call
}

// Exist is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Exist(ctx interface{}, dr interface{}) *MockDeployer_Exist_Call {
	return &MockDeployer_Exist_Call{Call: _e.mock.On("Exist", ctx, dr)}
}

func (_c *MockDeployer_Exist_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Exist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Exist_Call) Return(_a0 bool, _a1 error) *MockDeployer_Exist_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_Exist_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (bool, error)) *MockDeployer_Exist_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterById provides a mock function with given fields: ctx, clusterId
func (_m *MockDeployer) GetClusterById(ctx context.Context, clusterId string) (*types.ClusterRes, error) {
	ret := _m.Called(ctx, clusterId)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterById")
	}

	var r0 *types.ClusterRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*types.ClusterRes, error)); ok {
		return rf(ctx, clusterId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *types.ClusterRes); ok {
		r0 = rf(ctx, clusterId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ClusterRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, clusterId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_GetClusterById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterById'
type MockDeployer_GetClusterById_Call struct {
	*mock.Call
}

// GetClusterById is a helper method to define mock.On call
//   - ctx context.Context
//   - clusterId string
func (_e *MockDeployer_Expecter) GetClusterById(ctx interface{}, clusterId interface{}) *MockDeployer_GetClusterById_Call {
	return &MockDeployer_GetClusterById_Call{Call: _e.mock.On("GetClusterById", ctx, clusterId)}
}

func (_c *MockDeployer_GetClusterById_Call) Run(run func(ctx context.Context, clusterId string)) *MockDeployer_GetClusterById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDeployer_GetClusterById_Call) Return(_a0 *types.ClusterRes, _a1 error) *MockDeployer_GetClusterById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_GetClusterById_Call) RunAndReturn(run func(context.Context, string) (*types.ClusterRes, error)) *MockDeployer_GetClusterById_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterUsageById provides a mock function with given fields: ctx, clusterId
func (_m *MockDeployer) GetClusterUsageById(ctx context.Context, clusterId string) (*types.ClusterRes, error) {
	ret := _m.Called(ctx, clusterId)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterUsageById")
	}

	var r0 *types.ClusterRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*types.ClusterRes, error)); ok {
		return rf(ctx, clusterId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *types.ClusterRes); ok {
		r0 = rf(ctx, clusterId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ClusterRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, clusterId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_GetClusterUsageById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterUsageById'
type MockDeployer_GetClusterUsageById_Call struct {
	*mock.Call
}

// GetClusterUsageById is a helper method to define mock.On call
//   - ctx context.Context
//   - clusterId string
func (_e *MockDeployer_Expecter) GetClusterUsageById(ctx interface{}, clusterId interface{}) *MockDeployer_GetClusterUsageById_Call {
	return &MockDeployer_GetClusterUsageById_Call{Call: _e.mock.On("GetClusterUsageById", ctx, clusterId)}
}

func (_c *MockDeployer_GetClusterUsageById_Call) Run(run func(ctx context.Context, clusterId string)) *MockDeployer_GetClusterUsageById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDeployer_GetClusterUsageById_Call) Return(_a0 *types.ClusterRes, _a1 error) *MockDeployer_GetClusterUsageById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_GetClusterUsageById_Call) RunAndReturn(run func(context.Context, string) (*types.ClusterRes, error)) *MockDeployer_GetClusterUsageById_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvaluation provides a mock function with given fields: ctx, req
func (_m *MockDeployer) GetEvaluation(ctx context.Context, req types.EvaluationGetReq) (*types.ArgoWorkFlowRes, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetEvaluation")
	}

	var r0 *types.ArgoWorkFlowRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.EvaluationGetReq) (*types.ArgoWorkFlowRes, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.EvaluationGetReq) *types.ArgoWorkFlowRes); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ArgoWorkFlowRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.EvaluationGetReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_GetEvaluation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvaluation'
type MockDeployer_GetEvaluation_Call struct {
	*mock.Call
}

// GetEvaluation is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.EvaluationGetReq
func (_e *MockDeployer_Expecter) GetEvaluation(ctx interface{}, req interface{}) *MockDeployer_GetEvaluation_Call {
	return &MockDeployer_GetEvaluation_Call{Call: _e.mock.On("GetEvaluation", ctx, req)}
}

func (_c *MockDeployer_GetEvaluation_Call) Run(run func(ctx context.Context, req types.EvaluationGetReq)) *MockDeployer_GetEvaluation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.EvaluationGetReq))
	})
	return _c
}

func (_c *MockDeployer_GetEvaluation_Call) Return(_a0 *types.ArgoWorkFlowRes, _a1 error) *MockDeployer_GetEvaluation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_GetEvaluation_Call) RunAndReturn(run func(context.Context, types.EvaluationGetReq) (*types.ArgoWorkFlowRes, error)) *MockDeployer_GetEvaluation_Call {
	_c.Call.Return(run)
	return _c
}

// GetReplica provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) GetReplica(ctx context.Context, dr types.DeployRepo) (int, int, []types.Instance, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for GetReplica")
	}

	var r0 int
	var r1 int
	var r2 []types.Instance
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (int, int, []types.Instance, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) int); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) int); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, types.DeployRepo) []types.Instance); ok {
		r2 = rf(ctx, dr)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, types.DeployRepo) error); ok {
		r3 = rf(ctx, dr)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockDeployer_GetReplica_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReplica'
type MockDeployer_GetReplica_Call struct {
	*mock.Call
}

// GetReplica is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) GetReplica(ctx interface{}, dr interface{}) *MockDeployer_GetReplica_Call {
	return &MockDeployer_GetReplica_Call{Call: _e.mock.On("GetReplica", ctx, dr)}
}

func (_c *MockDeployer_GetReplica_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_GetReplica_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_GetReplica_Call) Return(_a0 int, _a1 int, _a2 []types.Instance, _a3 error) *MockDeployer_GetReplica_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockDeployer_GetReplica_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (int, int, []types.Instance, error)) *MockDeployer_GetReplica_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowLogsInStream provides a mock function with given fields: ctx, req
func (_m *MockDeployer) GetWorkflowLogsInStream(ctx context.Context, req types.FinetuneLogReq) (*deploy.MultiLogReader, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowLogsInStream")
	}

	var r0 *deploy.MultiLogReader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.FinetuneLogReq) (*deploy.MultiLogReader, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.FinetuneLogReq) *deploy.MultiLogReader); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy.MultiLogReader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.FinetuneLogReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_GetWorkflowLogsInStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowLogsInStream'
type MockDeployer_GetWorkflowLogsInStream_Call struct {
	*mock.Call
}

// GetWorkflowLogsInStream is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.FinetuneLogReq
func (_e *MockDeployer_Expecter) GetWorkflowLogsInStream(ctx interface{}, req interface{}) *MockDeployer_GetWorkflowLogsInStream_Call {
	return &MockDeployer_GetWorkflowLogsInStream_Call{Call: _e.mock.On("GetWorkflowLogsInStream", ctx, req)}
}

func (_c *MockDeployer_GetWorkflowLogsInStream_Call) Run(run func(ctx context.Context, req types.FinetuneLogReq)) *MockDeployer_GetWorkflowLogsInStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.FinetuneLogReq))
	})
	return _c
}

func (_c *MockDeployer_GetWorkflowLogsInStream_Call) Return(_a0 *deploy.MultiLogReader, _a1 error) *MockDeployer_GetWorkflowLogsInStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_GetWorkflowLogsInStream_Call) RunAndReturn(run func(context.Context, types.FinetuneLogReq) (*deploy.MultiLogReader, error)) *MockDeployer_GetWorkflowLogsInStream_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowLogsNonStream provides a mock function with given fields: ctx, req
func (_m *MockDeployer) GetWorkflowLogsNonStream(ctx context.Context, req types.FinetuneLogReq) (*loki.LokiQueryResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowLogsNonStream")
	}

	var r0 *loki.LokiQueryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.FinetuneLogReq) (*loki.LokiQueryResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.FinetuneLogReq) *loki.LokiQueryResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*loki.LokiQueryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.FinetuneLogReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_GetWorkflowLogsNonStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowLogsNonStream'
type MockDeployer_GetWorkflowLogsNonStream_Call struct {
	*mock.Call
}

// GetWorkflowLogsNonStream is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.FinetuneLogReq
func (_e *MockDeployer_Expecter) GetWorkflowLogsNonStream(ctx interface{}, req interface{}) *MockDeployer_GetWorkflowLogsNonStream_Call {
	return &MockDeployer_GetWorkflowLogsNonStream_Call{Call: _e.mock.On("GetWorkflowLogsNonStream", ctx, req)}
}

func (_c *MockDeployer_GetWorkflowLogsNonStream_Call) Run(run func(ctx context.Context, req types.FinetuneLogReq)) *MockDeployer_GetWorkflowLogsNonStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.FinetuneLogReq))
	})
	return _c
}

func (_c *MockDeployer_GetWorkflowLogsNonStream_Call) Return(_a0 *loki.LokiQueryResponse, _a1 error) *MockDeployer_GetWorkflowLogsNonStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_GetWorkflowLogsNonStream_Call) RunAndReturn(run func(context.Context, types.FinetuneLogReq) (*loki.LokiQueryResponse, error)) *MockDeployer_GetWorkflowLogsNonStream_Call {
	_c.Call.Return(run)
	return _c
}

// InstanceLogs provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) InstanceLogs(ctx context.Context, dr types.DeployRepo) (*deploy.MultiLogReader, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for InstanceLogs")
	}

	var r0 *deploy.MultiLogReader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (*deploy.MultiLogReader, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) *deploy.MultiLogReader); ok {
		r0 = rf(ctx, dr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy.MultiLogReader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) error); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_InstanceLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstanceLogs'
type MockDeployer_InstanceLogs_Call struct {
	*mock.Call
}

// InstanceLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) InstanceLogs(ctx interface{}, dr interface{}) *MockDeployer_InstanceLogs_Call {
	return &MockDeployer_InstanceLogs_Call{Call: _e.mock.On("InstanceLogs", ctx, dr)}
}

func (_c *MockDeployer_InstanceLogs_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_InstanceLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_InstanceLogs_Call) Return(_a0 *deploy.MultiLogReader, _a1 error) *MockDeployer_InstanceLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_InstanceLogs_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (*deploy.MultiLogReader, error)) *MockDeployer_InstanceLogs_Call {
	_c.Call.Return(run)
	return _c
}

// ListCluster provides a mock function with given fields: ctx
func (_m *MockDeployer) ListCluster(ctx context.Context) ([]types.ClusterRes, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListCluster")
	}

	var r0 []types.ClusterRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]types.ClusterRes, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []types.ClusterRes); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.ClusterRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_ListCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCluster'
type MockDeployer_ListCluster_Call struct {
	*mock.Call
}

// ListCluster is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDeployer_Expecter) ListCluster(ctx interface{}) *MockDeployer_ListCluster_Call {
	return &MockDeployer_ListCluster_Call{Call: _e.mock.On("ListCluster", ctx)}
}

func (_c *MockDeployer_ListCluster_Call) Run(run func(ctx context.Context)) *MockDeployer_ListCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDeployer_ListCluster_Call) Return(_a0 []types.ClusterRes, _a1 error) *MockDeployer_ListCluster_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_ListCluster_Call) RunAndReturn(run func(context.Context) ([]types.ClusterRes, error)) *MockDeployer_ListCluster_Call {
	_c.Call.Return(run)
	return _c
}

// Logs provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Logs(ctx context.Context, dr types.DeployRepo) (*deploy.MultiLogReader, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Logs")
	}

	var r0 *deploy.MultiLogReader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (*deploy.MultiLogReader, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) *deploy.MultiLogReader); ok {
		r0 = rf(ctx, dr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy.MultiLogReader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) error); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_Logs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logs'
type MockDeployer_Logs_Call struct {
	*mock.Call
}

// Logs is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Logs(ctx interface{}, dr interface{}) *MockDeployer_Logs_Call {
	return &MockDeployer_Logs_Call{Call: _e.mock.On("Logs", ctx, dr)}
}

func (_c *MockDeployer_Logs_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Logs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Logs_Call) Return(_a0 *deploy.MultiLogReader, _a1 error) *MockDeployer_Logs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_Logs_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (*deploy.MultiLogReader, error)) *MockDeployer_Logs_Call {
	_c.Call.Return(run)
	return _c
}

// Purge provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Purge(ctx context.Context, dr types.DeployRepo) error {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Purge")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) error); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_Purge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Purge'
type MockDeployer_Purge_Call struct {
	*mock.Call
}

// Purge is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Purge(ctx interface{}, dr interface{}) *MockDeployer_Purge_Call {
	return &MockDeployer_Purge_Call{Call: _e.mock.On("Purge", ctx, dr)}
}

func (_c *MockDeployer_Purge_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Purge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Purge_Call) Return(err error) *MockDeployer_Purge_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDeployer_Purge_Call) RunAndReturn(run func(context.Context, types.DeployRepo) error) *MockDeployer_Purge_Call {
	_c.Call.Return(run)
	return _c
}

// StartDeploy provides a mock function with given fields: ctx, _a1
func (_m *MockDeployer) StartDeploy(ctx context.Context, _a1 *database.Deploy) error {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StartDeploy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *database.Deploy) error); ok {
		r0 = rf(ctx, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_StartDeploy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartDeploy'
type MockDeployer_StartDeploy_Call struct {
	*mock.Call
}

// StartDeploy is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *database.Deploy
func (_e *MockDeployer_Expecter) StartDeploy(ctx interface{}, _a1 interface{}) *MockDeployer_StartDeploy_Call {
	return &MockDeployer_StartDeploy_Call{Call: _e.mock.On("StartDeploy", ctx, _a1)}
}

func (_c *MockDeployer_StartDeploy_Call) Run(run func(ctx context.Context, _a1 *database.Deploy)) *MockDeployer_StartDeploy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*database.Deploy))
	})
	return _c
}

func (_c *MockDeployer_StartDeploy_Call) Return(_a0 error) *MockDeployer_StartDeploy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDeployer_StartDeploy_Call) RunAndReturn(run func(context.Context, *database.Deploy) error) *MockDeployer_StartDeploy_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function with given fields: ctx, dr, needDetails
func (_m *MockDeployer) Status(ctx context.Context, dr types.DeployRepo, needDetails bool) (string, int, []types.Instance, error) {
	ret := _m.Called(ctx, dr, needDetails)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 string
	var r1 int
	var r2 []types.Instance
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo, bool) (string, int, []types.Instance, error)); ok {
		return rf(ctx, dr, needDetails)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo, bool) string); ok {
		r0 = rf(ctx, dr, needDetails)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo, bool) int); ok {
		r1 = rf(ctx, dr, needDetails)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, types.DeployRepo, bool) []types.Instance); ok {
		r2 = rf(ctx, dr, needDetails)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, types.DeployRepo, bool) error); ok {
		r3 = rf(ctx, dr, needDetails)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockDeployer_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockDeployer_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
//   - needDetails bool
func (_e *MockDeployer_Expecter) Status(ctx interface{}, dr interface{}, needDetails interface{}) *MockDeployer_Status_Call {
	return &MockDeployer_Status_Call{Call: _e.mock.On("Status", ctx, dr, needDetails)}
}

func (_c *MockDeployer_Status_Call) Run(run func(ctx context.Context, dr types.DeployRepo, needDetails bool)) *MockDeployer_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo), args[2].(bool))
	})
	return _c
}

func (_c *MockDeployer_Status_Call) Return(srvName string, status int, instances []types.Instance, err error) *MockDeployer_Status_Call {
	_c.Call.Return(srvName, status, instances, err)
	return _c
}

func (_c *MockDeployer_Status_Call) RunAndReturn(run func(context.Context, types.DeployRepo, bool) (string, int, []types.Instance, error)) *MockDeployer_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Stop(ctx context.Context, dr types.DeployRepo) error {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) error); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type MockDeployer_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Stop(ctx interface{}, dr interface{}) *MockDeployer_Stop_Call {
	return &MockDeployer_Stop_Call{Call: _e.mock.On("Stop", ctx, dr)}
}

func (_c *MockDeployer_Stop_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Stop_Call) Return(err error) *MockDeployer_Stop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDeployer_Stop_Call) RunAndReturn(run func(context.Context, types.DeployRepo) error) *MockDeployer_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// StopBuild provides a mock function with given fields: ctx, req
func (_m *MockDeployer) StopBuild(ctx context.Context, req types.ImageBuildStopReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for StopBuild")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.ImageBuildStopReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_StopBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopBuild'
type MockDeployer_StopBuild_Call struct {
	*mock.Call
}

// StopBuild is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.ImageBuildStopReq
func (_e *MockDeployer_Expecter) StopBuild(ctx interface{}, req interface{}) *MockDeployer_StopBuild_Call {
	return &MockDeployer_StopBuild_Call{Call: _e.mock.On("StopBuild", ctx, req)}
}

func (_c *MockDeployer_StopBuild_Call) Run(run func(ctx context.Context, req types.ImageBuildStopReq)) *MockDeployer_StopBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.ImageBuildStopReq))
	})
	return _c
}

func (_c *MockDeployer_StopBuild_Call) Return(err error) *MockDeployer_StopBuild_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDeployer_StopBuild_Call) RunAndReturn(run func(context.Context, types.ImageBuildStopReq) error) *MockDeployer_StopBuild_Call {
	_c.Call.Return(run)
	return _c
}

// SubmitEvaluation provides a mock function with given fields: ctx, req
func (_m *MockDeployer) SubmitEvaluation(ctx context.Context, req types.EvaluationReq) (*types.ArgoWorkFlowRes, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for SubmitEvaluation")
	}

	var r0 *types.ArgoWorkFlowRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.EvaluationReq) (*types.ArgoWorkFlowRes, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.EvaluationReq) *types.ArgoWorkFlowRes); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ArgoWorkFlowRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.EvaluationReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_SubmitEvaluation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubmitEvaluation'
type MockDeployer_SubmitEvaluation_Call struct {
	*mock.Call
}

// SubmitEvaluation is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.EvaluationReq
func (_e *MockDeployer_Expecter) SubmitEvaluation(ctx interface{}, req interface{}) *MockDeployer_SubmitEvaluation_Call {
	return &MockDeployer_SubmitEvaluation_Call{Call: _e.mock.On("SubmitEvaluation", ctx, req)}
}

func (_c *MockDeployer_SubmitEvaluation_Call) Run(run func(ctx context.Context, req types.EvaluationReq)) *MockDeployer_SubmitEvaluation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.EvaluationReq))
	})
	return _c
}

func (_c *MockDeployer_SubmitEvaluation_Call) Return(_a0 *types.ArgoWorkFlowRes, _a1 error) *MockDeployer_SubmitEvaluation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_SubmitEvaluation_Call) RunAndReturn(run func(context.Context, types.EvaluationReq) (*types.ArgoWorkFlowRes, error)) *MockDeployer_SubmitEvaluation_Call {
	_c.Call.Return(run)
	return _c
}

// SubmitFinetuneJob provides a mock function with given fields: ctx, req
func (_m *MockDeployer) SubmitFinetuneJob(ctx context.Context, req types.FinetuneReq) (*types.ArgoWorkFlowRes, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for SubmitFinetuneJob")
	}

	var r0 *types.ArgoWorkFlowRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.FinetuneReq) (*types.ArgoWorkFlowRes, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.FinetuneReq) *types.ArgoWorkFlowRes); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ArgoWorkFlowRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.FinetuneReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_SubmitFinetuneJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubmitFinetuneJob'
type MockDeployer_SubmitFinetuneJob_Call struct {
	*mock.Call
}

// SubmitFinetuneJob is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.FinetuneReq
func (_e *MockDeployer_Expecter) SubmitFinetuneJob(ctx interface{}, req interface{}) *MockDeployer_SubmitFinetuneJob_Call {
	return &MockDeployer_SubmitFinetuneJob_Call{Call: _e.mock.On("SubmitFinetuneJob", ctx, req)}
}

func (_c *MockDeployer_SubmitFinetuneJob_Call) Run(run func(ctx context.Context, req types.FinetuneReq)) *MockDeployer_SubmitFinetuneJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.FinetuneReq))
	})
	return _c
}

func (_c *MockDeployer_SubmitFinetuneJob_Call) Return(_a0 *types.ArgoWorkFlowRes, _a1 error) *MockDeployer_SubmitFinetuneJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_SubmitFinetuneJob_Call) RunAndReturn(run func(context.Context, types.FinetuneReq) (*types.ArgoWorkFlowRes, error)) *MockDeployer_SubmitFinetuneJob_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCluster provides a mock function with given fields: ctx, data
func (_m *MockDeployer) UpdateCluster(ctx context.Context, data types.ClusterRequest) (*types.UpdateClusterResponse, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCluster")
	}

	var r0 *types.UpdateClusterResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.ClusterRequest) (*types.UpdateClusterResponse, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.ClusterRequest) *types.UpdateClusterResponse); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UpdateClusterResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.ClusterRequest) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_UpdateCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCluster'
type MockDeployer_UpdateCluster_Call struct {
	*mock.Call
}

// UpdateCluster is a helper method to define mock.On call
//   - ctx context.Context
//   - data types.ClusterRequest
func (_e *MockDeployer_Expecter) UpdateCluster(ctx interface{}, data interface{}) *MockDeployer_UpdateCluster_Call {
	return &MockDeployer_UpdateCluster_Call{Call: _e.mock.On("UpdateCluster", ctx, data)}
}

func (_c *MockDeployer_UpdateCluster_Call) Run(run func(ctx context.Context, data types.ClusterRequest)) *MockDeployer_UpdateCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.ClusterRequest))
	})
	return _c
}

func (_c *MockDeployer_UpdateCluster_Call) Return(_a0 *types.UpdateClusterResponse, _a1 error) *MockDeployer_UpdateCluster_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_UpdateCluster_Call) RunAndReturn(run func(context.Context, types.ClusterRequest) (*types.UpdateClusterResponse, error)) *MockDeployer_UpdateCluster_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDeploy provides a mock function with given fields: ctx, dur, _a2
func (_m *MockDeployer) UpdateDeploy(ctx context.Context, dur *types.DeployUpdateReq, _a2 *database.Deploy) error {
	ret := _m.Called(ctx, dur, _a2)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDeploy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.DeployUpdateReq, *database.Deploy) error); ok {
		r0 = rf(ctx, dur, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_UpdateDeploy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDeploy'
type MockDeployer_UpdateDeploy_Call struct {
	*mock.Call
}

// UpdateDeploy is a helper method to define mock.On call
//   - ctx context.Context
//   - dur *types.DeployUpdateReq
//   - _a2 *database.Deploy
func (_e *MockDeployer_Expecter) UpdateDeploy(ctx interface{}, dur interface{}, _a2 interface{}) *MockDeployer_UpdateDeploy_Call {
	return &MockDeployer_UpdateDeploy_Call{Call: _e.mock.On("UpdateDeploy", ctx, dur, _a2)}
}

func (_c *MockDeployer_UpdateDeploy_Call) Run(run func(ctx context.Context, dur *types.DeployUpdateReq, _a2 *database.Deploy)) *MockDeployer_UpdateDeploy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.DeployUpdateReq), args[2].(*database.Deploy))
	})
	return _c
}

func (_c *MockDeployer_UpdateDeploy_Call) Return(_a0 error) *MockDeployer_UpdateDeploy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDeployer_UpdateDeploy_Call) RunAndReturn(run func(context.Context, *types.DeployUpdateReq, *database.Deploy) error) *MockDeployer_UpdateDeploy_Call {
	_c.Call.Return(run)
	return _c
}

// Wakeup provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Wakeup(ctx context.Context, dr types.DeployRepo) error {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Wakeup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) error); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_Wakeup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wakeup'
type MockDeployer_Wakeup_Call struct {
	*mock.Call
}

// Wakeup is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Wakeup(ctx interface{}, dr interface{}) *MockDeployer_Wakeup_Call {
	return &MockDeployer_Wakeup_Call{Call: _e.mock.On("Wakeup", ctx, dr)}
}

func (_c *MockDeployer_Wakeup_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Wakeup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Wakeup_Call) Return(err error) *MockDeployer_Wakeup_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDeployer_Wakeup_Call) RunAndReturn(run func(context.Context, types.DeployRepo) error) *MockDeployer_Wakeup_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDeployer creates a new instance of MockDeployer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDeployer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDeployer {
	mock := &MockDeployer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
