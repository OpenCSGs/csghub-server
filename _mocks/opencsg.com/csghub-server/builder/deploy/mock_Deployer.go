// Code generated by mockery v2.53.0. DO NOT EDIT.

package deploy

import (
	context "context"

	deploy "opencsg.com/csghub-server/builder/deploy"
	database "opencsg.com/csghub-server/builder/store/database"

	mock "github.com/stretchr/testify/mock"

	types "opencsg.com/csghub-server/common/types"
)

// MockDeployer is an autogenerated mock type for the Deployer type
type MockDeployer struct {
	mock.Mock
}

type MockDeployer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDeployer) EXPECT() *MockDeployer_Expecter {
	return &MockDeployer_Expecter{mock: &_m.Mock}
}

// CheckResourceAvailable provides a mock function with given fields: ctx, clusterId, orderDetailID, hardWare
func (_m *MockDeployer) CheckResourceAvailable(ctx context.Context, clusterId string, orderDetailID int64, hardWare *types.HardWare) (bool, error) {
	ret := _m.Called(ctx, clusterId, orderDetailID, hardWare)

	if len(ret) == 0 {
		panic("no return value specified for CheckResourceAvailable")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, *types.HardWare) (bool, error)); ok {
		return rf(ctx, clusterId, orderDetailID, hardWare)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, *types.HardWare) bool); ok {
		r0 = rf(ctx, clusterId, orderDetailID, hardWare)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int64, *types.HardWare) error); ok {
		r1 = rf(ctx, clusterId, orderDetailID, hardWare)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_CheckResourceAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckResourceAvailable'
type MockDeployer_CheckResourceAvailable_Call struct {
	*mock.Call
}

// CheckResourceAvailable is a helper method to define mock.On call
//   - ctx context.Context
//   - clusterId string
//   - orderDetailID int64
//   - hardWare *types.HardWare
func (_e *MockDeployer_Expecter) CheckResourceAvailable(ctx interface{}, clusterId interface{}, orderDetailID interface{}, hardWare interface{}) *MockDeployer_CheckResourceAvailable_Call {
	return &MockDeployer_CheckResourceAvailable_Call{Call: _e.mock.On("CheckResourceAvailable", ctx, clusterId, orderDetailID, hardWare)}
}

func (_c *MockDeployer_CheckResourceAvailable_Call) Run(run func(ctx context.Context, clusterId string, orderDetailID int64, hardWare *types.HardWare)) *MockDeployer_CheckResourceAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(*types.HardWare))
	})
	return _c
}

func (_c *MockDeployer_CheckResourceAvailable_Call) Return(_a0 bool, _a1 error) *MockDeployer_CheckResourceAvailable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_CheckResourceAvailable_Call) RunAndReturn(run func(context.Context, string, int64, *types.HardWare) (bool, error)) *MockDeployer_CheckResourceAvailable_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEvaluation provides a mock function with given fields: ctx, req
func (_m *MockDeployer) DeleteEvaluation(ctx context.Context, req types.ArgoWorkFlowDeleteReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEvaluation")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.ArgoWorkFlowDeleteReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_DeleteEvaluation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEvaluation'
type MockDeployer_DeleteEvaluation_Call struct {
	*mock.Call
}

// DeleteEvaluation is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.ArgoWorkFlowDeleteReq
func (_e *MockDeployer_Expecter) DeleteEvaluation(ctx interface{}, req interface{}) *MockDeployer_DeleteEvaluation_Call {
	return &MockDeployer_DeleteEvaluation_Call{Call: _e.mock.On("DeleteEvaluation", ctx, req)}
}

func (_c *MockDeployer_DeleteEvaluation_Call) Run(run func(ctx context.Context, req types.ArgoWorkFlowDeleteReq)) *MockDeployer_DeleteEvaluation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.ArgoWorkFlowDeleteReq))
	})
	return _c
}

func (_c *MockDeployer_DeleteEvaluation_Call) Return(_a0 error) *MockDeployer_DeleteEvaluation_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDeployer_DeleteEvaluation_Call) RunAndReturn(run func(context.Context, types.ArgoWorkFlowDeleteReq) error) *MockDeployer_DeleteEvaluation_Call {
	_c.Call.Return(run)
	return _c
}

// Deploy provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Deploy(ctx context.Context, dr types.DeployRepo) (int64, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Deploy")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (int64, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) int64); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) error); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_Deploy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Deploy'
type MockDeployer_Deploy_Call struct {
	*mock.Call
}

// Deploy is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Deploy(ctx interface{}, dr interface{}) *MockDeployer_Deploy_Call {
	return &MockDeployer_Deploy_Call{Call: _e.mock.On("Deploy", ctx, dr)}
}

func (_c *MockDeployer_Deploy_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Deploy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Deploy_Call) Return(deployID int64, err error) *MockDeployer_Deploy_Call {
	_c.Call.Return(deployID, err)
	return _c
}

func (_c *MockDeployer_Deploy_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (int64, error)) *MockDeployer_Deploy_Call {
	_c.Call.Return(run)
	return _c
}

// Exist provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Exist(ctx context.Context, dr types.DeployRepo) (bool, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Exist")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (bool, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) bool); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) error); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_Exist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exist'
type MockDeployer_Exist_Call struct {
	*mock.Call
}

// Exist is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Exist(ctx interface{}, dr interface{}) *MockDeployer_Exist_Call {
	return &MockDeployer_Exist_Call{Call: _e.mock.On("Exist", ctx, dr)}
}

func (_c *MockDeployer_Exist_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Exist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Exist_Call) Return(_a0 bool, _a1 error) *MockDeployer_Exist_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_Exist_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (bool, error)) *MockDeployer_Exist_Call {
	_c.Call.Return(run)
	return _c
}

// GetClusterById provides a mock function with given fields: ctx, clusterId
func (_m *MockDeployer) GetClusterById(ctx context.Context, clusterId string) (*types.ClusterRes, error) {
	ret := _m.Called(ctx, clusterId)

	if len(ret) == 0 {
		panic("no return value specified for GetClusterById")
	}

	var r0 *types.ClusterRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*types.ClusterRes, error)); ok {
		return rf(ctx, clusterId)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *types.ClusterRes); ok {
		r0 = rf(ctx, clusterId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ClusterRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, clusterId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_GetClusterById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClusterById'
type MockDeployer_GetClusterById_Call struct {
	*mock.Call
}

// GetClusterById is a helper method to define mock.On call
//   - ctx context.Context
//   - clusterId string
func (_e *MockDeployer_Expecter) GetClusterById(ctx interface{}, clusterId interface{}) *MockDeployer_GetClusterById_Call {
	return &MockDeployer_GetClusterById_Call{Call: _e.mock.On("GetClusterById", ctx, clusterId)}
}

func (_c *MockDeployer_GetClusterById_Call) Run(run func(ctx context.Context, clusterId string)) *MockDeployer_GetClusterById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockDeployer_GetClusterById_Call) Return(_a0 *types.ClusterRes, _a1 error) *MockDeployer_GetClusterById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_GetClusterById_Call) RunAndReturn(run func(context.Context, string) (*types.ClusterRes, error)) *MockDeployer_GetClusterById_Call {
	_c.Call.Return(run)
	return _c
}

// GetEvaluation provides a mock function with given fields: ctx, req
func (_m *MockDeployer) GetEvaluation(ctx context.Context, req types.EvaluationGetReq) (*types.ArgoWorkFlowRes, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GetEvaluation")
	}

	var r0 *types.ArgoWorkFlowRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.EvaluationGetReq) (*types.ArgoWorkFlowRes, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.EvaluationGetReq) *types.ArgoWorkFlowRes); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ArgoWorkFlowRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.EvaluationGetReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_GetEvaluation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEvaluation'
type MockDeployer_GetEvaluation_Call struct {
	*mock.Call
}

// GetEvaluation is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.EvaluationGetReq
func (_e *MockDeployer_Expecter) GetEvaluation(ctx interface{}, req interface{}) *MockDeployer_GetEvaluation_Call {
	return &MockDeployer_GetEvaluation_Call{Call: _e.mock.On("GetEvaluation", ctx, req)}
}

func (_c *MockDeployer_GetEvaluation_Call) Run(run func(ctx context.Context, req types.EvaluationGetReq)) *MockDeployer_GetEvaluation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.EvaluationGetReq))
	})
	return _c
}

func (_c *MockDeployer_GetEvaluation_Call) Return(_a0 *types.ArgoWorkFlowRes, _a1 error) *MockDeployer_GetEvaluation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_GetEvaluation_Call) RunAndReturn(run func(context.Context, types.EvaluationGetReq) (*types.ArgoWorkFlowRes, error)) *MockDeployer_GetEvaluation_Call {
	_c.Call.Return(run)
	return _c
}

// GetReplica provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) GetReplica(ctx context.Context, dr types.DeployRepo) (int, int, []types.Instance, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for GetReplica")
	}

	var r0 int
	var r1 int
	var r2 []types.Instance
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (int, int, []types.Instance, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) int); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) int); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, types.DeployRepo) []types.Instance); ok {
		r2 = rf(ctx, dr)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, types.DeployRepo) error); ok {
		r3 = rf(ctx, dr)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockDeployer_GetReplica_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReplica'
type MockDeployer_GetReplica_Call struct {
	*mock.Call
}

// GetReplica is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) GetReplica(ctx interface{}, dr interface{}) *MockDeployer_GetReplica_Call {
	return &MockDeployer_GetReplica_Call{Call: _e.mock.On("GetReplica", ctx, dr)}
}

func (_c *MockDeployer_GetReplica_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_GetReplica_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_GetReplica_Call) Return(_a0 int, _a1 int, _a2 []types.Instance, _a3 error) *MockDeployer_GetReplica_Call {
	_c.Call.Return(_a0, _a1, _a2, _a3)
	return _c
}

func (_c *MockDeployer_GetReplica_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (int, int, []types.Instance, error)) *MockDeployer_GetReplica_Call {
	_c.Call.Return(run)
	return _c
}

// InstanceLogs provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) InstanceLogs(ctx context.Context, dr types.DeployRepo) (*deploy.MultiLogReader, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for InstanceLogs")
	}

	var r0 *deploy.MultiLogReader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (*deploy.MultiLogReader, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) *deploy.MultiLogReader); ok {
		r0 = rf(ctx, dr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy.MultiLogReader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) error); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_InstanceLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstanceLogs'
type MockDeployer_InstanceLogs_Call struct {
	*mock.Call
}

// InstanceLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) InstanceLogs(ctx interface{}, dr interface{}) *MockDeployer_InstanceLogs_Call {
	return &MockDeployer_InstanceLogs_Call{Call: _e.mock.On("InstanceLogs", ctx, dr)}
}

func (_c *MockDeployer_InstanceLogs_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_InstanceLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_InstanceLogs_Call) Return(_a0 *deploy.MultiLogReader, _a1 error) *MockDeployer_InstanceLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_InstanceLogs_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (*deploy.MultiLogReader, error)) *MockDeployer_InstanceLogs_Call {
	_c.Call.Return(run)
	return _c
}

// ListCluster provides a mock function with given fields: ctx
func (_m *MockDeployer) ListCluster(ctx context.Context) ([]types.ClusterRes, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListCluster")
	}

	var r0 []types.ClusterRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]types.ClusterRes, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []types.ClusterRes); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.ClusterRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_ListCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCluster'
type MockDeployer_ListCluster_Call struct {
	*mock.Call
}

// ListCluster is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockDeployer_Expecter) ListCluster(ctx interface{}) *MockDeployer_ListCluster_Call {
	return &MockDeployer_ListCluster_Call{Call: _e.mock.On("ListCluster", ctx)}
}

func (_c *MockDeployer_ListCluster_Call) Run(run func(ctx context.Context)) *MockDeployer_ListCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockDeployer_ListCluster_Call) Return(_a0 []types.ClusterRes, _a1 error) *MockDeployer_ListCluster_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_ListCluster_Call) RunAndReturn(run func(context.Context) ([]types.ClusterRes, error)) *MockDeployer_ListCluster_Call {
	_c.Call.Return(run)
	return _c
}

// ListEvaluations provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *MockDeployer) ListEvaluations(_a0 context.Context, _a1 string, _a2 int, _a3 int) (*types.ArgoWorkFlowListRes, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for ListEvaluations")
	}

	var r0 *types.ArgoWorkFlowListRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) (*types.ArgoWorkFlowListRes, error)); ok {
		return rf(_a0, _a1, _a2, _a3)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *types.ArgoWorkFlowListRes); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ArgoWorkFlowListRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, int) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_ListEvaluations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEvaluations'
type MockDeployer_ListEvaluations_Call struct {
	*mock.Call
}

// ListEvaluations is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 int
//   - _a3 int
func (_e *MockDeployer_Expecter) ListEvaluations(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}) *MockDeployer_ListEvaluations_Call {
	return &MockDeployer_ListEvaluations_Call{Call: _e.mock.On("ListEvaluations", _a0, _a1, _a2, _a3)}
}

func (_c *MockDeployer_ListEvaluations_Call) Run(run func(_a0 context.Context, _a1 string, _a2 int, _a3 int)) *MockDeployer_ListEvaluations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockDeployer_ListEvaluations_Call) Return(_a0 *types.ArgoWorkFlowListRes, _a1 error) *MockDeployer_ListEvaluations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_ListEvaluations_Call) RunAndReturn(run func(context.Context, string, int, int) (*types.ArgoWorkFlowListRes, error)) *MockDeployer_ListEvaluations_Call {
	_c.Call.Return(run)
	return _c
}

// Logs provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Logs(ctx context.Context, dr types.DeployRepo) (*deploy.MultiLogReader, error) {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Logs")
	}

	var r0 *deploy.MultiLogReader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) (*deploy.MultiLogReader, error)); ok {
		return rf(ctx, dr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) *deploy.MultiLogReader); ok {
		r0 = rf(ctx, dr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*deploy.MultiLogReader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo) error); ok {
		r1 = rf(ctx, dr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_Logs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logs'
type MockDeployer_Logs_Call struct {
	*mock.Call
}

// Logs is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Logs(ctx interface{}, dr interface{}) *MockDeployer_Logs_Call {
	return &MockDeployer_Logs_Call{Call: _e.mock.On("Logs", ctx, dr)}
}

func (_c *MockDeployer_Logs_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Logs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Logs_Call) Return(_a0 *deploy.MultiLogReader, _a1 error) *MockDeployer_Logs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_Logs_Call) RunAndReturn(run func(context.Context, types.DeployRepo) (*deploy.MultiLogReader, error)) *MockDeployer_Logs_Call {
	_c.Call.Return(run)
	return _c
}

// Purge provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Purge(ctx context.Context, dr types.DeployRepo) error {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Purge")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) error); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_Purge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Purge'
type MockDeployer_Purge_Call struct {
	*mock.Call
}

// Purge is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Purge(ctx interface{}, dr interface{}) *MockDeployer_Purge_Call {
	return &MockDeployer_Purge_Call{Call: _e.mock.On("Purge", ctx, dr)}
}

func (_c *MockDeployer_Purge_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Purge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Purge_Call) Return(err error) *MockDeployer_Purge_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDeployer_Purge_Call) RunAndReturn(run func(context.Context, types.DeployRepo) error) *MockDeployer_Purge_Call {
	_c.Call.Return(run)
	return _c
}

// StartDeploy provides a mock function with given fields: ctx, _a1
func (_m *MockDeployer) StartDeploy(ctx context.Context, _a1 *database.Deploy) error {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for StartDeploy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *database.Deploy) error); ok {
		r0 = rf(ctx, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_StartDeploy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartDeploy'
type MockDeployer_StartDeploy_Call struct {
	*mock.Call
}

// StartDeploy is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *database.Deploy
func (_e *MockDeployer_Expecter) StartDeploy(ctx interface{}, _a1 interface{}) *MockDeployer_StartDeploy_Call {
	return &MockDeployer_StartDeploy_Call{Call: _e.mock.On("StartDeploy", ctx, _a1)}
}

func (_c *MockDeployer_StartDeploy_Call) Run(run func(ctx context.Context, _a1 *database.Deploy)) *MockDeployer_StartDeploy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*database.Deploy))
	})
	return _c
}

func (_c *MockDeployer_StartDeploy_Call) Return(_a0 error) *MockDeployer_StartDeploy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDeployer_StartDeploy_Call) RunAndReturn(run func(context.Context, *database.Deploy) error) *MockDeployer_StartDeploy_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function with given fields: ctx, dr, needDetails
func (_m *MockDeployer) Status(ctx context.Context, dr types.DeployRepo, needDetails bool) (string, int, []types.Instance, error) {
	ret := _m.Called(ctx, dr, needDetails)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 string
	var r1 int
	var r2 []types.Instance
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo, bool) (string, int, []types.Instance, error)); ok {
		return rf(ctx, dr, needDetails)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo, bool) string); ok {
		r0 = rf(ctx, dr, needDetails)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployRepo, bool) int); ok {
		r1 = rf(ctx, dr, needDetails)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, types.DeployRepo, bool) []types.Instance); ok {
		r2 = rf(ctx, dr, needDetails)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]types.Instance)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, types.DeployRepo, bool) error); ok {
		r3 = rf(ctx, dr, needDetails)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// MockDeployer_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockDeployer_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
//   - needDetails bool
func (_e *MockDeployer_Expecter) Status(ctx interface{}, dr interface{}, needDetails interface{}) *MockDeployer_Status_Call {
	return &MockDeployer_Status_Call{Call: _e.mock.On("Status", ctx, dr, needDetails)}
}

func (_c *MockDeployer_Status_Call) Run(run func(ctx context.Context, dr types.DeployRepo, needDetails bool)) *MockDeployer_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo), args[2].(bool))
	})
	return _c
}

func (_c *MockDeployer_Status_Call) Return(srvName string, status int, instances []types.Instance, err error) *MockDeployer_Status_Call {
	_c.Call.Return(srvName, status, instances, err)
	return _c
}

func (_c *MockDeployer_Status_Call) RunAndReturn(run func(context.Context, types.DeployRepo, bool) (string, int, []types.Instance, error)) *MockDeployer_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Stop(ctx context.Context, dr types.DeployRepo) error {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) error); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type MockDeployer_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Stop(ctx interface{}, dr interface{}) *MockDeployer_Stop_Call {
	return &MockDeployer_Stop_Call{Call: _e.mock.On("Stop", ctx, dr)}
}

func (_c *MockDeployer_Stop_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Stop_Call) Return(err error) *MockDeployer_Stop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDeployer_Stop_Call) RunAndReturn(run func(context.Context, types.DeployRepo) error) *MockDeployer_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// SubmitEvaluation provides a mock function with given fields: ctx, req
func (_m *MockDeployer) SubmitEvaluation(ctx context.Context, req types.EvaluationReq) (*types.ArgoWorkFlowRes, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for SubmitEvaluation")
	}

	var r0 *types.ArgoWorkFlowRes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.EvaluationReq) (*types.ArgoWorkFlowRes, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.EvaluationReq) *types.ArgoWorkFlowRes); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ArgoWorkFlowRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.EvaluationReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_SubmitEvaluation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubmitEvaluation'
type MockDeployer_SubmitEvaluation_Call struct {
	*mock.Call
}

// SubmitEvaluation is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.EvaluationReq
func (_e *MockDeployer_Expecter) SubmitEvaluation(ctx interface{}, req interface{}) *MockDeployer_SubmitEvaluation_Call {
	return &MockDeployer_SubmitEvaluation_Call{Call: _e.mock.On("SubmitEvaluation", ctx, req)}
}

func (_c *MockDeployer_SubmitEvaluation_Call) Run(run func(ctx context.Context, req types.EvaluationReq)) *MockDeployer_SubmitEvaluation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.EvaluationReq))
	})
	return _c
}

func (_c *MockDeployer_SubmitEvaluation_Call) Return(_a0 *types.ArgoWorkFlowRes, _a1 error) *MockDeployer_SubmitEvaluation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_SubmitEvaluation_Call) RunAndReturn(run func(context.Context, types.EvaluationReq) (*types.ArgoWorkFlowRes, error)) *MockDeployer_SubmitEvaluation_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCluster provides a mock function with given fields: ctx, data
func (_m *MockDeployer) UpdateCluster(ctx context.Context, data types.ClusterRequest) (*types.UpdateClusterResponse, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCluster")
	}

	var r0 *types.UpdateClusterResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.ClusterRequest) (*types.UpdateClusterResponse, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.ClusterRequest) *types.UpdateClusterResponse); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UpdateClusterResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.ClusterRequest) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockDeployer_UpdateCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCluster'
type MockDeployer_UpdateCluster_Call struct {
	*mock.Call
}

// UpdateCluster is a helper method to define mock.On call
//   - ctx context.Context
//   - data types.ClusterRequest
func (_e *MockDeployer_Expecter) UpdateCluster(ctx interface{}, data interface{}) *MockDeployer_UpdateCluster_Call {
	return &MockDeployer_UpdateCluster_Call{Call: _e.mock.On("UpdateCluster", ctx, data)}
}

func (_c *MockDeployer_UpdateCluster_Call) Run(run func(ctx context.Context, data types.ClusterRequest)) *MockDeployer_UpdateCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.ClusterRequest))
	})
	return _c
}

func (_c *MockDeployer_UpdateCluster_Call) Return(_a0 *types.UpdateClusterResponse, _a1 error) *MockDeployer_UpdateCluster_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockDeployer_UpdateCluster_Call) RunAndReturn(run func(context.Context, types.ClusterRequest) (*types.UpdateClusterResponse, error)) *MockDeployer_UpdateCluster_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDeploy provides a mock function with given fields: ctx, dur, _a2
func (_m *MockDeployer) UpdateDeploy(ctx context.Context, dur *types.DeployUpdateReq, _a2 *database.Deploy) error {
	ret := _m.Called(ctx, dur, _a2)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDeploy")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.DeployUpdateReq, *database.Deploy) error); ok {
		r0 = rf(ctx, dur, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_UpdateDeploy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDeploy'
type MockDeployer_UpdateDeploy_Call struct {
	*mock.Call
}

// UpdateDeploy is a helper method to define mock.On call
//   - ctx context.Context
//   - dur *types.DeployUpdateReq
//   - _a2 *database.Deploy
func (_e *MockDeployer_Expecter) UpdateDeploy(ctx interface{}, dur interface{}, _a2 interface{}) *MockDeployer_UpdateDeploy_Call {
	return &MockDeployer_UpdateDeploy_Call{Call: _e.mock.On("UpdateDeploy", ctx, dur, _a2)}
}

func (_c *MockDeployer_UpdateDeploy_Call) Run(run func(ctx context.Context, dur *types.DeployUpdateReq, _a2 *database.Deploy)) *MockDeployer_UpdateDeploy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.DeployUpdateReq), args[2].(*database.Deploy))
	})
	return _c
}

func (_c *MockDeployer_UpdateDeploy_Call) Return(_a0 error) *MockDeployer_UpdateDeploy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockDeployer_UpdateDeploy_Call) RunAndReturn(run func(context.Context, *types.DeployUpdateReq, *database.Deploy) error) *MockDeployer_UpdateDeploy_Call {
	_c.Call.Return(run)
	return _c
}

// Wakeup provides a mock function with given fields: ctx, dr
func (_m *MockDeployer) Wakeup(ctx context.Context, dr types.DeployRepo) error {
	ret := _m.Called(ctx, dr)

	if len(ret) == 0 {
		panic("no return value specified for Wakeup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployRepo) error); ok {
		r0 = rf(ctx, dr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockDeployer_Wakeup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wakeup'
type MockDeployer_Wakeup_Call struct {
	*mock.Call
}

// Wakeup is a helper method to define mock.On call
//   - ctx context.Context
//   - dr types.DeployRepo
func (_e *MockDeployer_Expecter) Wakeup(ctx interface{}, dr interface{}) *MockDeployer_Wakeup_Call {
	return &MockDeployer_Wakeup_Call{Call: _e.mock.On("Wakeup", ctx, dr)}
}

func (_c *MockDeployer_Wakeup_Call) Run(run func(ctx context.Context, dr types.DeployRepo)) *MockDeployer_Wakeup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployRepo))
	})
	return _c
}

func (_c *MockDeployer_Wakeup_Call) Return(err error) *MockDeployer_Wakeup_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockDeployer_Wakeup_Call) RunAndReturn(run func(context.Context, types.DeployRepo) error) *MockDeployer_Wakeup_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDeployer creates a new instance of MockDeployer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDeployer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDeployer {
	mock := &MockDeployer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
