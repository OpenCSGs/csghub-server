// Code generated by mockery v2.53.0. DO NOT EDIT.

package multisync

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	types "opencsg.com/csghub-server/common/types"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// DatasetInfo provides a mock function with given fields: ctx, v
func (_m *MockClient) DatasetInfo(ctx context.Context, v types.SyncVersion) (*types.Dataset, error) {
	ret := _m.Called(ctx, v)

	if len(ret) == 0 {
		panic("no return value specified for DatasetInfo")
	}

	var r0 *types.Dataset
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.SyncVersion) (*types.Dataset, error)); ok {
		return rf(ctx, v)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.SyncVersion) *types.Dataset); ok {
		r0 = rf(ctx, v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Dataset)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.SyncVersion) error); ok {
		r1 = rf(ctx, v)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DatasetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DatasetInfo'
type MockClient_DatasetInfo_Call struct {
	*mock.Call
}

// DatasetInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - v types.SyncVersion
func (_e *MockClient_Expecter) DatasetInfo(ctx interface{}, v interface{}) *MockClient_DatasetInfo_Call {
	return &MockClient_DatasetInfo_Call{Call: _e.mock.On("DatasetInfo", ctx, v)}
}

func (_c *MockClient_DatasetInfo_Call) Run(run func(ctx context.Context, v types.SyncVersion)) *MockClient_DatasetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.SyncVersion))
	})
	return _c
}

func (_c *MockClient_DatasetInfo_Call) Return(_a0 *types.Dataset, _a1 error) *MockClient_DatasetInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DatasetInfo_Call) RunAndReturn(run func(context.Context, types.SyncVersion) (*types.Dataset, error)) *MockClient_DatasetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// FileList provides a mock function with given fields: ctx, v
func (_m *MockClient) FileList(ctx context.Context, v types.SyncVersion) ([]types.File, error) {
	ret := _m.Called(ctx, v)

	if len(ret) == 0 {
		panic("no return value specified for FileList")
	}

	var r0 []types.File
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.SyncVersion) ([]types.File, error)); ok {
		return rf(ctx, v)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.SyncVersion) []types.File); ok {
		r0 = rf(ctx, v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.File)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.SyncVersion) error); ok {
		r1 = rf(ctx, v)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_FileList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FileList'
type MockClient_FileList_Call struct {
	*mock.Call
}

// FileList is a helper method to define mock.On call
//   - ctx context.Context
//   - v types.SyncVersion
func (_e *MockClient_Expecter) FileList(ctx interface{}, v interface{}) *MockClient_FileList_Call {
	return &MockClient_FileList_Call{Call: _e.mock.On("FileList", ctx, v)}
}

func (_c *MockClient_FileList_Call) Run(run func(ctx context.Context, v types.SyncVersion)) *MockClient_FileList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.SyncVersion))
	})
	return _c
}

func (_c *MockClient_FileList_Call) Return(_a0 []types.File, _a1 error) *MockClient_FileList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_FileList_Call) RunAndReturn(run func(context.Context, types.SyncVersion) ([]types.File, error)) *MockClient_FileList_Call {
	_c.Call.Return(run)
	return _c
}

// Latest provides a mock function with given fields: ctx, currentVersion
func (_m *MockClient) Latest(ctx context.Context, currentVersion int64) (types.SyncVersionResponse, error) {
	ret := _m.Called(ctx, currentVersion)

	if len(ret) == 0 {
		panic("no return value specified for Latest")
	}

	var r0 types.SyncVersionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (types.SyncVersionResponse, error)); ok {
		return rf(ctx, currentVersion)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) types.SyncVersionResponse); ok {
		r0 = rf(ctx, currentVersion)
	} else {
		r0 = ret.Get(0).(types.SyncVersionResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, currentVersion)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_Latest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Latest'
type MockClient_Latest_Call struct {
	*mock.Call
}

// Latest is a helper method to define mock.On call
//   - ctx context.Context
//   - currentVersion int64
func (_e *MockClient_Expecter) Latest(ctx interface{}, currentVersion interface{}) *MockClient_Latest_Call {
	return &MockClient_Latest_Call{Call: _e.mock.On("Latest", ctx, currentVersion)}
}

func (_c *MockClient_Latest_Call) Run(run func(ctx context.Context, currentVersion int64)) *MockClient_Latest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockClient_Latest_Call) Return(_a0 types.SyncVersionResponse, _a1 error) *MockClient_Latest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_Latest_Call) RunAndReturn(run func(context.Context, int64) (types.SyncVersionResponse, error)) *MockClient_Latest_Call {
	_c.Call.Return(run)
	return _c
}

// ModelInfo provides a mock function with given fields: ctx, v
func (_m *MockClient) ModelInfo(ctx context.Context, v types.SyncVersion) (*types.Model, error) {
	ret := _m.Called(ctx, v)

	if len(ret) == 0 {
		panic("no return value specified for ModelInfo")
	}

	var r0 *types.Model
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.SyncVersion) (*types.Model, error)); ok {
		return rf(ctx, v)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.SyncVersion) *types.Model); ok {
		r0 = rf(ctx, v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Model)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.SyncVersion) error); ok {
		r1 = rf(ctx, v)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ModelInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModelInfo'
type MockClient_ModelInfo_Call struct {
	*mock.Call
}

// ModelInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - v types.SyncVersion
func (_e *MockClient_Expecter) ModelInfo(ctx interface{}, v interface{}) *MockClient_ModelInfo_Call {
	return &MockClient_ModelInfo_Call{Call: _e.mock.On("ModelInfo", ctx, v)}
}

func (_c *MockClient_ModelInfo_Call) Run(run func(ctx context.Context, v types.SyncVersion)) *MockClient_ModelInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.SyncVersion))
	})
	return _c
}

func (_c *MockClient_ModelInfo_Call) Return(_a0 *types.Model, _a1 error) *MockClient_ModelInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ModelInfo_Call) RunAndReturn(run func(context.Context, types.SyncVersion) (*types.Model, error)) *MockClient_ModelInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ReadMeData provides a mock function with given fields: ctx, v
func (_m *MockClient) ReadMeData(ctx context.Context, v types.SyncVersion) (string, error) {
	ret := _m.Called(ctx, v)

	if len(ret) == 0 {
		panic("no return value specified for ReadMeData")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.SyncVersion) (string, error)); ok {
		return rf(ctx, v)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.SyncVersion) string); ok {
		r0 = rf(ctx, v)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.SyncVersion) error); ok {
		r1 = rf(ctx, v)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ReadMeData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadMeData'
type MockClient_ReadMeData_Call struct {
	*mock.Call
}

// ReadMeData is a helper method to define mock.On call
//   - ctx context.Context
//   - v types.SyncVersion
func (_e *MockClient_Expecter) ReadMeData(ctx interface{}, v interface{}) *MockClient_ReadMeData_Call {
	return &MockClient_ReadMeData_Call{Call: _e.mock.On("ReadMeData", ctx, v)}
}

func (_c *MockClient_ReadMeData_Call) Run(run func(ctx context.Context, v types.SyncVersion)) *MockClient_ReadMeData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.SyncVersion))
	})
	return _c
}

func (_c *MockClient_ReadMeData_Call) Return(_a0 string, _a1 error) *MockClient_ReadMeData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ReadMeData_Call) RunAndReturn(run func(context.Context, types.SyncVersion) (string, error)) *MockClient_ReadMeData_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
