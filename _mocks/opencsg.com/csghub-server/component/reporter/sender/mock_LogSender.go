// Code generated by mockery v2.53.5. DO NOT EDIT.

package sender

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	loki "opencsg.com/csghub-server/builder/loki"

	time "time"

	types "opencsg.com/csghub-server/common/types"
)

// MockLogSender is an autogenerated mock type for the LogSender type
type MockLogSender struct {
	mock.Mock
}

type MockLogSender_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLogSender) EXPECT() *MockLogSender_Expecter {
	return &MockLogSender_Expecter{mock: &_m.Mock}
}

// GetLastReportedTimestamp provides a mock function with given fields: ctx
func (_m *MockLogSender) GetLastReportedTimestamp(ctx context.Context) (time.Time, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastReportedTimestamp")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (time.Time, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) time.Time); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLogSender_GetLastReportedTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastReportedTimestamp'
type MockLogSender_GetLastReportedTimestamp_Call struct {
	*mock.Call
}

// GetLastReportedTimestamp is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLogSender_Expecter) GetLastReportedTimestamp(ctx interface{}) *MockLogSender_GetLastReportedTimestamp_Call {
	return &MockLogSender_GetLastReportedTimestamp_Call{Call: _e.mock.On("GetLastReportedTimestamp", ctx)}
}

func (_c *MockLogSender_GetLastReportedTimestamp_Call) Run(run func(ctx context.Context)) *MockLogSender_GetLastReportedTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLogSender_GetLastReportedTimestamp_Call) Return(_a0 time.Time, _a1 error) *MockLogSender_GetLastReportedTimestamp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLogSender_GetLastReportedTimestamp_Call) RunAndReturn(run func(context.Context) (time.Time, error)) *MockLogSender_GetLastReportedTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// Health provides a mock function with given fields: ctx
func (_m *MockLogSender) Health(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Health")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLogSender_Health_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Health'
type MockLogSender_Health_Call struct {
	*mock.Call
}

// Health is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLogSender_Expecter) Health(ctx interface{}) *MockLogSender_Health_Call {
	return &MockLogSender_Health_Call{Call: _e.mock.On("Health", ctx)}
}

func (_c *MockLogSender_Health_Call) Run(run func(ctx context.Context)) *MockLogSender_Health_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLogSender_Health_Call) Return(_a0 error) *MockLogSender_Health_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLogSender_Health_Call) RunAndReturn(run func(context.Context) error) *MockLogSender_Health_Call {
	_c.Call.Return(run)
	return _c
}

// QueryRange provides a mock function with given fields: ctx, params
func (_m *MockLogSender) QueryRange(ctx context.Context, params loki.QueryRangeParams) (*loki.LokiQueryResponse, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for QueryRange")
	}

	var r0 *loki.LokiQueryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, loki.QueryRangeParams) (*loki.LokiQueryResponse, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, loki.QueryRangeParams) *loki.LokiQueryResponse); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*loki.LokiQueryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, loki.QueryRangeParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLogSender_QueryRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRange'
type MockLogSender_QueryRange_Call struct {
	*mock.Call
}

// QueryRange is a helper method to define mock.On call
//   - ctx context.Context
//   - params loki.QueryRangeParams
func (_e *MockLogSender_Expecter) QueryRange(ctx interface{}, params interface{}) *MockLogSender_QueryRange_Call {
	return &MockLogSender_QueryRange_Call{Call: _e.mock.On("QueryRange", ctx, params)}
}

func (_c *MockLogSender_QueryRange_Call) Run(run func(ctx context.Context, params loki.QueryRangeParams)) *MockLogSender_QueryRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(loki.QueryRangeParams))
	})
	return _c
}

func (_c *MockLogSender_QueryRange_Call) Return(_a0 *loki.LokiQueryResponse, _a1 error) *MockLogSender_QueryRange_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLogSender_QueryRange_Call) RunAndReturn(run func(context.Context, loki.QueryRangeParams) (*loki.LokiQueryResponse, error)) *MockLogSender_QueryRange_Call {
	_c.Call.Return(run)
	return _c
}

// SendLogs provides a mock function with given fields: ctx, entries
func (_m *MockLogSender) SendLogs(ctx context.Context, entries []types.LogEntry) error {
	ret := _m.Called(ctx, entries)

	if len(ret) == 0 {
		panic("no return value specified for SendLogs")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []types.LogEntry) error); ok {
		r0 = rf(ctx, entries)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLogSender_SendLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendLogs'
type MockLogSender_SendLogs_Call struct {
	*mock.Call
}

// SendLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - entries []types.LogEntry
func (_e *MockLogSender_Expecter) SendLogs(ctx interface{}, entries interface{}) *MockLogSender_SendLogs_Call {
	return &MockLogSender_SendLogs_Call{Call: _e.mock.On("SendLogs", ctx, entries)}
}

func (_c *MockLogSender_SendLogs_Call) Run(run func(ctx context.Context, entries []types.LogEntry)) *MockLogSender_SendLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]types.LogEntry))
	})
	return _c
}

func (_c *MockLogSender_SendLogs_Call) Return(_a0 error) *MockLogSender_SendLogs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLogSender_SendLogs_Call) RunAndReturn(run func(context.Context, []types.LogEntry) error) *MockLogSender_SendLogs_Call {
	_c.Call.Return(run)
	return _c
}

// StreamAllLogs provides a mock function with given fields: ctx, id, start, lables, timeLoc
func (_m *MockLogSender) StreamAllLogs(ctx context.Context, id string, start time.Time, lables map[string]string, timeLoc *time.Location) (chan string, error) {
	ret := _m.Called(ctx, id, start, lables, timeLoc)

	if len(ret) == 0 {
		panic("no return value specified for StreamAllLogs")
	}

	var r0 chan string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, map[string]string, *time.Location) (chan string, error)); ok {
		return rf(ctx, id, start, lables, timeLoc)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, map[string]string, *time.Location) chan string); ok {
		r0 = rf(ctx, id, start, lables, timeLoc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, time.Time, map[string]string, *time.Location) error); ok {
		r1 = rf(ctx, id, start, lables, timeLoc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLogSender_StreamAllLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamAllLogs'
type MockLogSender_StreamAllLogs_Call struct {
	*mock.Call
}

// StreamAllLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - start time.Time
//   - lables map[string]string
//   - timeLoc *time.Location
func (_e *MockLogSender_Expecter) StreamAllLogs(ctx interface{}, id interface{}, start interface{}, lables interface{}, timeLoc interface{}) *MockLogSender_StreamAllLogs_Call {
	return &MockLogSender_StreamAllLogs_Call{Call: _e.mock.On("StreamAllLogs", ctx, id, start, lables, timeLoc)}
}

func (_c *MockLogSender_StreamAllLogs_Call) Run(run func(ctx context.Context, id string, start time.Time, lables map[string]string, timeLoc *time.Location)) *MockLogSender_StreamAllLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), args[3].(map[string]string), args[4].(*time.Location))
	})
	return _c
}

func (_c *MockLogSender_StreamAllLogs_Call) Return(_a0 chan string, _a1 error) *MockLogSender_StreamAllLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLogSender_StreamAllLogs_Call) RunAndReturn(run func(context.Context, string, time.Time, map[string]string, *time.Location) (chan string, error)) *MockLogSender_StreamAllLogs_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLogSender creates a new instance of MockLogSender. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLogSender(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLogSender {
	mock := &MockLogSender{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
