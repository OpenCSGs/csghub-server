// Code generated by mockery v2.53.0. DO NOT EDIT.

package component

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	database "opencsg.com/csghub-server/builder/store/database"

	types "opencsg.com/csghub-server/common/types"
)

// MockUserComponent is an autogenerated mock type for the UserComponent type
type MockUserComponent struct {
	mock.Mock
}

type MockUserComponent_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserComponent) EXPECT() *MockUserComponent_Expecter {
	return &MockUserComponent_Expecter{mock: &_m.Mock}
}

// AddLikes provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) AddLikes(ctx context.Context, req *types.UserLikesRequest) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for AddLikes")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserLikesRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_AddLikes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddLikes'
type MockUserComponent_AddLikes_Call struct {
	*mock.Call
}

// AddLikes is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserLikesRequest
func (_e *MockUserComponent_Expecter) AddLikes(ctx interface{}, req interface{}) *MockUserComponent_AddLikes_Call {
	return &MockUserComponent_AddLikes_Call{Call: _e.mock.On("AddLikes", ctx, req)}
}

func (_c *MockUserComponent_AddLikes_Call) Run(run func(ctx context.Context, req *types.UserLikesRequest)) *MockUserComponent_AddLikes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserLikesRequest))
	})
	return _c
}

func (_c *MockUserComponent_AddLikes_Call) Return(_a0 error) *MockUserComponent_AddLikes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_AddLikes_Call) RunAndReturn(run func(context.Context, *types.UserLikesRequest) error) *MockUserComponent_AddLikes_Call {
	_c.Call.Return(run)
	return _c
}

// Codes provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) Codes(ctx context.Context, req *types.UserModelsReq) ([]types.Code, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Codes")
	}

	var r0 []types.Code
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserModelsReq) ([]types.Code, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserModelsReq) []types.Code); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Code)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserModelsReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserModelsReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_Codes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Codes'
type MockUserComponent_Codes_Call struct {
	*mock.Call
}

// Codes is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserModelsReq
func (_e *MockUserComponent_Expecter) Codes(ctx interface{}, req interface{}) *MockUserComponent_Codes_Call {
	return &MockUserComponent_Codes_Call{Call: _e.mock.On("Codes", ctx, req)}
}

func (_c *MockUserComponent_Codes_Call) Run(run func(ctx context.Context, req *types.UserModelsReq)) *MockUserComponent_Codes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserModelsReq))
	})
	return _c
}

func (_c *MockUserComponent_Codes_Call) Return(_a0 []types.Code, _a1 int, _a2 error) *MockUserComponent_Codes_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_Codes_Call) RunAndReturn(run func(context.Context, *types.UserModelsReq) ([]types.Code, int, error)) *MockUserComponent_Codes_Call {
	_c.Call.Return(run)
	return _c
}

// Collections provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) Collections(ctx context.Context, req *types.UserCollectionReq) ([]types.Collection, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Collections")
	}

	var r0 []types.Collection
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserCollectionReq) ([]types.Collection, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserCollectionReq) []types.Collection); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserCollectionReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserCollectionReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_Collections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Collections'
type MockUserComponent_Collections_Call struct {
	*mock.Call
}

// Collections is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserCollectionReq
func (_e *MockUserComponent_Expecter) Collections(ctx interface{}, req interface{}) *MockUserComponent_Collections_Call {
	return &MockUserComponent_Collections_Call{Call: _e.mock.On("Collections", ctx, req)}
}

func (_c *MockUserComponent_Collections_Call) Run(run func(ctx context.Context, req *types.UserCollectionReq)) *MockUserComponent_Collections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserCollectionReq))
	})
	return _c
}

func (_c *MockUserComponent_Collections_Call) Return(_a0 []types.Collection, _a1 int, _a2 error) *MockUserComponent_Collections_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_Collections_Call) RunAndReturn(run func(context.Context, *types.UserCollectionReq) ([]types.Collection, int, error)) *MockUserComponent_Collections_Call {
	_c.Call.Return(run)
	return _c
}

// Datasets provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) Datasets(ctx context.Context, req *types.UserDatasetsReq) ([]types.Dataset, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Datasets")
	}

	var r0 []types.Dataset
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserDatasetsReq) ([]types.Dataset, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserDatasetsReq) []types.Dataset); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Dataset)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserDatasetsReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserDatasetsReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_Datasets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Datasets'
type MockUserComponent_Datasets_Call struct {
	*mock.Call
}

// Datasets is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserDatasetsReq
func (_e *MockUserComponent_Expecter) Datasets(ctx interface{}, req interface{}) *MockUserComponent_Datasets_Call {
	return &MockUserComponent_Datasets_Call{Call: _e.mock.On("Datasets", ctx, req)}
}

func (_c *MockUserComponent_Datasets_Call) Run(run func(ctx context.Context, req *types.UserDatasetsReq)) *MockUserComponent_Datasets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserDatasetsReq))
	})
	return _c
}

func (_c *MockUserComponent_Datasets_Call) Return(_a0 []types.Dataset, _a1 int, _a2 error) *MockUserComponent_Datasets_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_Datasets_Call) RunAndReturn(run func(context.Context, *types.UserDatasetsReq) ([]types.Dataset, int, error)) *MockUserComponent_Datasets_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLikes provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) DeleteLikes(ctx context.Context, req *types.UserLikesRequest) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for DeleteLikes")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserLikesRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_DeleteLikes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLikes'
type MockUserComponent_DeleteLikes_Call struct {
	*mock.Call
}

// DeleteLikes is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserLikesRequest
func (_e *MockUserComponent_Expecter) DeleteLikes(ctx interface{}, req interface{}) *MockUserComponent_DeleteLikes_Call {
	return &MockUserComponent_DeleteLikes_Call{Call: _e.mock.On("DeleteLikes", ctx, req)}
}

func (_c *MockUserComponent_DeleteLikes_Call) Run(run func(ctx context.Context, req *types.UserLikesRequest)) *MockUserComponent_DeleteLikes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserLikesRequest))
	})
	return _c
}

func (_c *MockUserComponent_DeleteLikes_Call) Return(_a0 error) *MockUserComponent_DeleteLikes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_DeleteLikes_Call) RunAndReturn(run func(context.Context, *types.UserLikesRequest) error) *MockUserComponent_DeleteLikes_Call {
	_c.Call.Return(run)
	return _c
}

// Evaluations provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) Evaluations(ctx context.Context, req *types.UserEvaluationReq) ([]types.ArgoWorkFlowRes, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Evaluations")
	}

	var r0 []types.ArgoWorkFlowRes
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserEvaluationReq) ([]types.ArgoWorkFlowRes, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserEvaluationReq) []types.ArgoWorkFlowRes); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.ArgoWorkFlowRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserEvaluationReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserEvaluationReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_Evaluations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Evaluations'
type MockUserComponent_Evaluations_Call struct {
	*mock.Call
}

// Evaluations is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserEvaluationReq
func (_e *MockUserComponent_Expecter) Evaluations(ctx interface{}, req interface{}) *MockUserComponent_Evaluations_Call {
	return &MockUserComponent_Evaluations_Call{Call: _e.mock.On("Evaluations", ctx, req)}
}

func (_c *MockUserComponent_Evaluations_Call) Run(run func(ctx context.Context, req *types.UserEvaluationReq)) *MockUserComponent_Evaluations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserEvaluationReq))
	})
	return _c
}

func (_c *MockUserComponent_Evaluations_Call) Return(_a0 []types.ArgoWorkFlowRes, _a1 int, _a2 error) *MockUserComponent_Evaluations_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_Evaluations_Call) RunAndReturn(run func(context.Context, *types.UserEvaluationReq) ([]types.ArgoWorkFlowRes, int, error)) *MockUserComponent_Evaluations_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByName provides a mock function with given fields: ctx, userName
func (_m *MockUserComponent) GetUserByName(ctx context.Context, userName string) (*database.User, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByName")
	}

	var r0 *database.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*database.User, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *database.User); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUserComponent_GetUserByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByName'
type MockUserComponent_GetUserByName_Call struct {
	*mock.Call
}

// GetUserByName is a helper method to define mock.On call
//   - ctx context.Context
//   - userName string
func (_e *MockUserComponent_Expecter) GetUserByName(ctx interface{}, userName interface{}) *MockUserComponent_GetUserByName_Call {
	return &MockUserComponent_GetUserByName_Call{Call: _e.mock.On("GetUserByName", ctx, userName)}
}

func (_c *MockUserComponent_GetUserByName_Call) Run(run func(ctx context.Context, userName string)) *MockUserComponent_GetUserByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUserComponent_GetUserByName_Call) Return(_a0 *database.User, _a1 error) *MockUserComponent_GetUserByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUserComponent_GetUserByName_Call) RunAndReturn(run func(context.Context, string) (*database.User, error)) *MockUserComponent_GetUserByName_Call {
	_c.Call.Return(run)
	return _c
}

// LikeCollection provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) LikeCollection(ctx context.Context, req *types.UserLikesRequest) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LikeCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserLikesRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_LikeCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LikeCollection'
type MockUserComponent_LikeCollection_Call struct {
	*mock.Call
}

// LikeCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserLikesRequest
func (_e *MockUserComponent_Expecter) LikeCollection(ctx interface{}, req interface{}) *MockUserComponent_LikeCollection_Call {
	return &MockUserComponent_LikeCollection_Call{Call: _e.mock.On("LikeCollection", ctx, req)}
}

func (_c *MockUserComponent_LikeCollection_Call) Run(run func(ctx context.Context, req *types.UserLikesRequest)) *MockUserComponent_LikeCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserLikesRequest))
	})
	return _c
}

func (_c *MockUserComponent_LikeCollection_Call) Return(_a0 error) *MockUserComponent_LikeCollection_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_LikeCollection_Call) RunAndReturn(run func(context.Context, *types.UserLikesRequest) error) *MockUserComponent_LikeCollection_Call {
	_c.Call.Return(run)
	return _c
}

// LikesCodes provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) LikesCodes(ctx context.Context, req *types.UserModelsReq) ([]types.Code, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LikesCodes")
	}

	var r0 []types.Code
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserModelsReq) ([]types.Code, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserModelsReq) []types.Code); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Code)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserModelsReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserModelsReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_LikesCodes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LikesCodes'
type MockUserComponent_LikesCodes_Call struct {
	*mock.Call
}

// LikesCodes is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserModelsReq
func (_e *MockUserComponent_Expecter) LikesCodes(ctx interface{}, req interface{}) *MockUserComponent_LikesCodes_Call {
	return &MockUserComponent_LikesCodes_Call{Call: _e.mock.On("LikesCodes", ctx, req)}
}

func (_c *MockUserComponent_LikesCodes_Call) Run(run func(ctx context.Context, req *types.UserModelsReq)) *MockUserComponent_LikesCodes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserModelsReq))
	})
	return _c
}

func (_c *MockUserComponent_LikesCodes_Call) Return(_a0 []types.Code, _a1 int, _a2 error) *MockUserComponent_LikesCodes_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_LikesCodes_Call) RunAndReturn(run func(context.Context, *types.UserModelsReq) ([]types.Code, int, error)) *MockUserComponent_LikesCodes_Call {
	_c.Call.Return(run)
	return _c
}

// LikesCollection provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) LikesCollection(ctx context.Context, req *types.UserSpacesReq) ([]types.Collection, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LikesCollection")
	}

	var r0 []types.Collection
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserSpacesReq) ([]types.Collection, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserSpacesReq) []types.Collection); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserSpacesReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserSpacesReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_LikesCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LikesCollection'
type MockUserComponent_LikesCollection_Call struct {
	*mock.Call
}

// LikesCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserSpacesReq
func (_e *MockUserComponent_Expecter) LikesCollection(ctx interface{}, req interface{}) *MockUserComponent_LikesCollection_Call {
	return &MockUserComponent_LikesCollection_Call{Call: _e.mock.On("LikesCollection", ctx, req)}
}

func (_c *MockUserComponent_LikesCollection_Call) Run(run func(ctx context.Context, req *types.UserSpacesReq)) *MockUserComponent_LikesCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserSpacesReq))
	})
	return _c
}

func (_c *MockUserComponent_LikesCollection_Call) Return(_a0 []types.Collection, _a1 int, _a2 error) *MockUserComponent_LikesCollection_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_LikesCollection_Call) RunAndReturn(run func(context.Context, *types.UserSpacesReq) ([]types.Collection, int, error)) *MockUserComponent_LikesCollection_Call {
	_c.Call.Return(run)
	return _c
}

// LikesDatasets provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) LikesDatasets(ctx context.Context, req *types.UserDatasetsReq) ([]types.Dataset, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LikesDatasets")
	}

	var r0 []types.Dataset
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserDatasetsReq) ([]types.Dataset, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserDatasetsReq) []types.Dataset); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Dataset)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserDatasetsReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserDatasetsReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_LikesDatasets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LikesDatasets'
type MockUserComponent_LikesDatasets_Call struct {
	*mock.Call
}

// LikesDatasets is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserDatasetsReq
func (_e *MockUserComponent_Expecter) LikesDatasets(ctx interface{}, req interface{}) *MockUserComponent_LikesDatasets_Call {
	return &MockUserComponent_LikesDatasets_Call{Call: _e.mock.On("LikesDatasets", ctx, req)}
}

func (_c *MockUserComponent_LikesDatasets_Call) Run(run func(ctx context.Context, req *types.UserDatasetsReq)) *MockUserComponent_LikesDatasets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserDatasetsReq))
	})
	return _c
}

func (_c *MockUserComponent_LikesDatasets_Call) Return(_a0 []types.Dataset, _a1 int, _a2 error) *MockUserComponent_LikesDatasets_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_LikesDatasets_Call) RunAndReturn(run func(context.Context, *types.UserDatasetsReq) ([]types.Dataset, int, error)) *MockUserComponent_LikesDatasets_Call {
	_c.Call.Return(run)
	return _c
}

// LikesModels provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) LikesModels(ctx context.Context, req *types.UserModelsReq) ([]types.Model, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LikesModels")
	}

	var r0 []types.Model
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserModelsReq) ([]types.Model, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserModelsReq) []types.Model); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Model)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserModelsReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserModelsReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_LikesModels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LikesModels'
type MockUserComponent_LikesModels_Call struct {
	*mock.Call
}

// LikesModels is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserModelsReq
func (_e *MockUserComponent_Expecter) LikesModels(ctx interface{}, req interface{}) *MockUserComponent_LikesModels_Call {
	return &MockUserComponent_LikesModels_Call{Call: _e.mock.On("LikesModels", ctx, req)}
}

func (_c *MockUserComponent_LikesModels_Call) Run(run func(ctx context.Context, req *types.UserModelsReq)) *MockUserComponent_LikesModels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserModelsReq))
	})
	return _c
}

func (_c *MockUserComponent_LikesModels_Call) Return(_a0 []types.Model, _a1 int, _a2 error) *MockUserComponent_LikesModels_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_LikesModels_Call) RunAndReturn(run func(context.Context, *types.UserModelsReq) ([]types.Model, int, error)) *MockUserComponent_LikesModels_Call {
	_c.Call.Return(run)
	return _c
}

// LikesSpaces provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) LikesSpaces(ctx context.Context, req *types.UserSpacesReq) ([]types.Space, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LikesSpaces")
	}

	var r0 []types.Space
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserSpacesReq) ([]types.Space, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserSpacesReq) []types.Space); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Space)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserSpacesReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserSpacesReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_LikesSpaces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LikesSpaces'
type MockUserComponent_LikesSpaces_Call struct {
	*mock.Call
}

// LikesSpaces is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserSpacesReq
func (_e *MockUserComponent_Expecter) LikesSpaces(ctx interface{}, req interface{}) *MockUserComponent_LikesSpaces_Call {
	return &MockUserComponent_LikesSpaces_Call{Call: _e.mock.On("LikesSpaces", ctx, req)}
}

func (_c *MockUserComponent_LikesSpaces_Call) Run(run func(ctx context.Context, req *types.UserSpacesReq)) *MockUserComponent_LikesSpaces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserSpacesReq))
	})
	return _c
}

func (_c *MockUserComponent_LikesSpaces_Call) Return(_a0 []types.Space, _a1 int, _a2 error) *MockUserComponent_LikesSpaces_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_LikesSpaces_Call) RunAndReturn(run func(context.Context, *types.UserSpacesReq) ([]types.Space, int, error)) *MockUserComponent_LikesSpaces_Call {
	_c.Call.Return(run)
	return _c
}

// ListDeploys provides a mock function with given fields: ctx, repoType, req
func (_m *MockUserComponent) ListDeploys(ctx context.Context, repoType types.RepositoryType, req *types.DeployReq) ([]types.DeployRepo, int, error) {
	ret := _m.Called(ctx, repoType, req)

	if len(ret) == 0 {
		panic("no return value specified for ListDeploys")
	}

	var r0 []types.DeployRepo
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, types.RepositoryType, *types.DeployReq) ([]types.DeployRepo, int, error)); ok {
		return rf(ctx, repoType, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.RepositoryType, *types.DeployReq) []types.DeployRepo); ok {
		r0 = rf(ctx, repoType, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.DeployRepo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.RepositoryType, *types.DeployReq) int); ok {
		r1 = rf(ctx, repoType, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, types.RepositoryType, *types.DeployReq) error); ok {
		r2 = rf(ctx, repoType, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_ListDeploys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDeploys'
type MockUserComponent_ListDeploys_Call struct {
	*mock.Call
}

// ListDeploys is a helper method to define mock.On call
//   - ctx context.Context
//   - repoType types.RepositoryType
//   - req *types.DeployReq
func (_e *MockUserComponent_Expecter) ListDeploys(ctx interface{}, repoType interface{}, req interface{}) *MockUserComponent_ListDeploys_Call {
	return &MockUserComponent_ListDeploys_Call{Call: _e.mock.On("ListDeploys", ctx, repoType, req)}
}

func (_c *MockUserComponent_ListDeploys_Call) Run(run func(ctx context.Context, repoType types.RepositoryType, req *types.DeployReq)) *MockUserComponent_ListDeploys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.RepositoryType), args[2].(*types.DeployReq))
	})
	return _c
}

func (_c *MockUserComponent_ListDeploys_Call) Return(_a0 []types.DeployRepo, _a1 int, _a2 error) *MockUserComponent_ListDeploys_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_ListDeploys_Call) RunAndReturn(run func(context.Context, types.RepositoryType, *types.DeployReq) ([]types.DeployRepo, int, error)) *MockUserComponent_ListDeploys_Call {
	_c.Call.Return(run)
	return _c
}

// ListInstances provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) ListInstances(ctx context.Context, req *types.UserRepoReq) ([]types.DeployRepo, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ListInstances")
	}

	var r0 []types.DeployRepo
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserRepoReq) ([]types.DeployRepo, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserRepoReq) []types.DeployRepo); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.DeployRepo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserRepoReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserRepoReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_ListInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListInstances'
type MockUserComponent_ListInstances_Call struct {
	*mock.Call
}

// ListInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserRepoReq
func (_e *MockUserComponent_Expecter) ListInstances(ctx interface{}, req interface{}) *MockUserComponent_ListInstances_Call {
	return &MockUserComponent_ListInstances_Call{Call: _e.mock.On("ListInstances", ctx, req)}
}

func (_c *MockUserComponent_ListInstances_Call) Run(run func(ctx context.Context, req *types.UserRepoReq)) *MockUserComponent_ListInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserRepoReq))
	})
	return _c
}

func (_c *MockUserComponent_ListInstances_Call) Return(_a0 []types.DeployRepo, _a1 int, _a2 error) *MockUserComponent_ListInstances_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_ListInstances_Call) RunAndReturn(run func(context.Context, *types.UserRepoReq) ([]types.DeployRepo, int, error)) *MockUserComponent_ListInstances_Call {
	_c.Call.Return(run)
	return _c
}

// ListServerless provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) ListServerless(ctx context.Context, req types.DeployReq) ([]types.DeployRepo, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ListServerless")
	}

	var r0 []types.DeployRepo
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployReq) ([]types.DeployRepo, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DeployReq) []types.DeployRepo); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.DeployRepo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DeployReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, types.DeployReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_ListServerless_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListServerless'
type MockUserComponent_ListServerless_Call struct {
	*mock.Call
}

// ListServerless is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.DeployReq
func (_e *MockUserComponent_Expecter) ListServerless(ctx interface{}, req interface{}) *MockUserComponent_ListServerless_Call {
	return &MockUserComponent_ListServerless_Call{Call: _e.mock.On("ListServerless", ctx, req)}
}

func (_c *MockUserComponent_ListServerless_Call) Run(run func(ctx context.Context, req types.DeployReq)) *MockUserComponent_ListServerless_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DeployReq))
	})
	return _c
}

func (_c *MockUserComponent_ListServerless_Call) Return(_a0 []types.DeployRepo, _a1 int, _a2 error) *MockUserComponent_ListServerless_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_ListServerless_Call) RunAndReturn(run func(context.Context, types.DeployReq) ([]types.DeployRepo, int, error)) *MockUserComponent_ListServerless_Call {
	_c.Call.Return(run)
	return _c
}

// Models provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) Models(ctx context.Context, req *types.UserModelsReq) ([]types.Model, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Models")
	}

	var r0 []types.Model
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserModelsReq) ([]types.Model, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserModelsReq) []types.Model); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Model)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserModelsReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserModelsReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_Models_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Models'
type MockUserComponent_Models_Call struct {
	*mock.Call
}

// Models is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserModelsReq
func (_e *MockUserComponent_Expecter) Models(ctx interface{}, req interface{}) *MockUserComponent_Models_Call {
	return &MockUserComponent_Models_Call{Call: _e.mock.On("Models", ctx, req)}
}

func (_c *MockUserComponent_Models_Call) Run(run func(ctx context.Context, req *types.UserModelsReq)) *MockUserComponent_Models_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserModelsReq))
	})
	return _c
}

func (_c *MockUserComponent_Models_Call) Return(_a0 []types.Model, _a1 int, _a2 error) *MockUserComponent_Models_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_Models_Call) RunAndReturn(run func(context.Context, *types.UserModelsReq) ([]types.Model, int, error)) *MockUserComponent_Models_Call {
	_c.Call.Return(run)
	return _c
}

// Prompts provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) Prompts(ctx context.Context, req *types.UserPromptsReq) ([]types.PromptRes, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Prompts")
	}

	var r0 []types.PromptRes
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserPromptsReq) ([]types.PromptRes, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserPromptsReq) []types.PromptRes); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.PromptRes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserPromptsReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserPromptsReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_Prompts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Prompts'
type MockUserComponent_Prompts_Call struct {
	*mock.Call
}

// Prompts is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserPromptsReq
func (_e *MockUserComponent_Expecter) Prompts(ctx interface{}, req interface{}) *MockUserComponent_Prompts_Call {
	return &MockUserComponent_Prompts_Call{Call: _e.mock.On("Prompts", ctx, req)}
}

func (_c *MockUserComponent_Prompts_Call) Run(run func(ctx context.Context, req *types.UserPromptsReq)) *MockUserComponent_Prompts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserPromptsReq))
	})
	return _c
}

func (_c *MockUserComponent_Prompts_Call) Return(_a0 []types.PromptRes, _a1 int, _a2 error) *MockUserComponent_Prompts_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_Prompts_Call) RunAndReturn(run func(context.Context, *types.UserPromptsReq) ([]types.PromptRes, int, error)) *MockUserComponent_Prompts_Call {
	_c.Call.Return(run)
	return _c
}

// Spaces provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) Spaces(ctx context.Context, req *types.UserSpacesReq) ([]types.Space, int, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Spaces")
	}

	var r0 []types.Space
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserSpacesReq) ([]types.Space, int, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserSpacesReq) []types.Space); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Space)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.UserSpacesReq) int); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *types.UserSpacesReq) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockUserComponent_Spaces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Spaces'
type MockUserComponent_Spaces_Call struct {
	*mock.Call
}

// Spaces is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserSpacesReq
func (_e *MockUserComponent_Expecter) Spaces(ctx interface{}, req interface{}) *MockUserComponent_Spaces_Call {
	return &MockUserComponent_Spaces_Call{Call: _e.mock.On("Spaces", ctx, req)}
}

func (_c *MockUserComponent_Spaces_Call) Run(run func(ctx context.Context, req *types.UserSpacesReq)) *MockUserComponent_Spaces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserSpacesReq))
	})
	return _c
}

func (_c *MockUserComponent_Spaces_Call) Return(_a0 []types.Space, _a1 int, _a2 error) *MockUserComponent_Spaces_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockUserComponent_Spaces_Call) RunAndReturn(run func(context.Context, *types.UserSpacesReq) ([]types.Space, int, error)) *MockUserComponent_Spaces_Call {
	_c.Call.Return(run)
	return _c
}

// UnLikeCollection provides a mock function with given fields: ctx, req
func (_m *MockUserComponent) UnLikeCollection(ctx context.Context, req *types.UserLikesRequest) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for UnLikeCollection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.UserLikesRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUserComponent_UnLikeCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnLikeCollection'
type MockUserComponent_UnLikeCollection_Call struct {
	*mock.Call
}

// UnLikeCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - req *types.UserLikesRequest
func (_e *MockUserComponent_Expecter) UnLikeCollection(ctx interface{}, req interface{}) *MockUserComponent_UnLikeCollection_Call {
	return &MockUserComponent_UnLikeCollection_Call{Call: _e.mock.On("UnLikeCollection", ctx, req)}
}

func (_c *MockUserComponent_UnLikeCollection_Call) Run(run func(ctx context.Context, req *types.UserLikesRequest)) *MockUserComponent_UnLikeCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*types.UserLikesRequest))
	})
	return _c
}

func (_c *MockUserComponent_UnLikeCollection_Call) Return(_a0 error) *MockUserComponent_UnLikeCollection_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUserComponent_UnLikeCollection_Call) RunAndReturn(run func(context.Context, *types.UserLikesRequest) error) *MockUserComponent_UnLikeCollection_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserComponent creates a new instance of MockUserComponent. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserComponent(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserComponent {
	mock := &MockUserComponent{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
