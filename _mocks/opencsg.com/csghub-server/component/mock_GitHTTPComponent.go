// Code generated by mockery v2.53.0. DO NOT EDIT.

package component

import (
	context "context"
	io "io"

	database "opencsg.com/csghub-server/builder/store/database"

	mock "github.com/stretchr/testify/mock"

	types "opencsg.com/csghub-server/common/types"

	url "net/url"
)

// MockGitHTTPComponent is an autogenerated mock type for the GitHTTPComponent type
type MockGitHTTPComponent struct {
	mock.Mock
}

type MockGitHTTPComponent_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGitHTTPComponent) EXPECT() *MockGitHTTPComponent_Expecter {
	return &MockGitHTTPComponent_Expecter{mock: &_m.Mock}
}

// CompleteMultipartUpload provides a mock function with given fields: ctx, req, bodyReq
func (_m *MockGitHTTPComponent) CompleteMultipartUpload(ctx context.Context, req types.CompleteMultipartUploadReq, bodyReq types.CompleteMultipartUploadBody) (int, error) {
	ret := _m.Called(ctx, req, bodyReq)

	if len(ret) == 0 {
		panic("no return value specified for CompleteMultipartUpload")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.CompleteMultipartUploadReq, types.CompleteMultipartUploadBody) (int, error)); ok {
		return rf(ctx, req, bodyReq)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.CompleteMultipartUploadReq, types.CompleteMultipartUploadBody) int); ok {
		r0 = rf(ctx, req, bodyReq)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.CompleteMultipartUploadReq, types.CompleteMultipartUploadBody) error); ok {
		r1 = rf(ctx, req, bodyReq)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitHTTPComponent_CompleteMultipartUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteMultipartUpload'
type MockGitHTTPComponent_CompleteMultipartUpload_Call struct {
	*mock.Call
}

// CompleteMultipartUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.CompleteMultipartUploadReq
//   - bodyReq types.CompleteMultipartUploadBody
func (_e *MockGitHTTPComponent_Expecter) CompleteMultipartUpload(ctx interface{}, req interface{}, bodyReq interface{}) *MockGitHTTPComponent_CompleteMultipartUpload_Call {
	return &MockGitHTTPComponent_CompleteMultipartUpload_Call{Call: _e.mock.On("CompleteMultipartUpload", ctx, req, bodyReq)}
}

func (_c *MockGitHTTPComponent_CompleteMultipartUpload_Call) Run(run func(ctx context.Context, req types.CompleteMultipartUploadReq, bodyReq types.CompleteMultipartUploadBody)) *MockGitHTTPComponent_CompleteMultipartUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.CompleteMultipartUploadReq), args[2].(types.CompleteMultipartUploadBody))
	})
	return _c
}

func (_c *MockGitHTTPComponent_CompleteMultipartUpload_Call) Return(_a0 int, _a1 error) *MockGitHTTPComponent_CompleteMultipartUpload_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitHTTPComponent_CompleteMultipartUpload_Call) RunAndReturn(run func(context.Context, types.CompleteMultipartUploadReq, types.CompleteMultipartUploadBody) (int, error)) *MockGitHTTPComponent_CompleteMultipartUpload_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLock provides a mock function with given fields: ctx, req
func (_m *MockGitHTTPComponent) CreateLock(ctx context.Context, req types.LfsLockReq) (*database.LfsLock, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateLock")
	}

	var r0 *database.LfsLock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.LfsLockReq) (*database.LfsLock, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.LfsLockReq) *database.LfsLock); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.LfsLock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.LfsLockReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitHTTPComponent_CreateLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLock'
type MockGitHTTPComponent_CreateLock_Call struct {
	*mock.Call
}

// CreateLock is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.LfsLockReq
func (_e *MockGitHTTPComponent_Expecter) CreateLock(ctx interface{}, req interface{}) *MockGitHTTPComponent_CreateLock_Call {
	return &MockGitHTTPComponent_CreateLock_Call{Call: _e.mock.On("CreateLock", ctx, req)}
}

func (_c *MockGitHTTPComponent_CreateLock_Call) Run(run func(ctx context.Context, req types.LfsLockReq)) *MockGitHTTPComponent_CreateLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.LfsLockReq))
	})
	return _c
}

func (_c *MockGitHTTPComponent_CreateLock_Call) Return(_a0 *database.LfsLock, _a1 error) *MockGitHTTPComponent_CreateLock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitHTTPComponent_CreateLock_Call) RunAndReturn(run func(context.Context, types.LfsLockReq) (*database.LfsLock, error)) *MockGitHTTPComponent_CreateLock_Call {
	_c.Call.Return(run)
	return _c
}

// GitReceivePack provides a mock function with given fields: ctx, req
func (_m *MockGitHTTPComponent) GitReceivePack(ctx context.Context, req types.GitReceivePackReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GitReceivePack")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.GitReceivePackReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitHTTPComponent_GitReceivePack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GitReceivePack'
type MockGitHTTPComponent_GitReceivePack_Call struct {
	*mock.Call
}

// GitReceivePack is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.GitReceivePackReq
func (_e *MockGitHTTPComponent_Expecter) GitReceivePack(ctx interface{}, req interface{}) *MockGitHTTPComponent_GitReceivePack_Call {
	return &MockGitHTTPComponent_GitReceivePack_Call{Call: _e.mock.On("GitReceivePack", ctx, req)}
}

func (_c *MockGitHTTPComponent_GitReceivePack_Call) Run(run func(ctx context.Context, req types.GitReceivePackReq)) *MockGitHTTPComponent_GitReceivePack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.GitReceivePackReq))
	})
	return _c
}

func (_c *MockGitHTTPComponent_GitReceivePack_Call) Return(_a0 error) *MockGitHTTPComponent_GitReceivePack_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitHTTPComponent_GitReceivePack_Call) RunAndReturn(run func(context.Context, types.GitReceivePackReq) error) *MockGitHTTPComponent_GitReceivePack_Call {
	_c.Call.Return(run)
	return _c
}

// GitUploadPack provides a mock function with given fields: ctx, req
func (_m *MockGitHTTPComponent) GitUploadPack(ctx context.Context, req types.GitUploadPackReq) error {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for GitUploadPack")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.GitUploadPackReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitHTTPComponent_GitUploadPack_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GitUploadPack'
type MockGitHTTPComponent_GitUploadPack_Call struct {
	*mock.Call
}

// GitUploadPack is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.GitUploadPackReq
func (_e *MockGitHTTPComponent_Expecter) GitUploadPack(ctx interface{}, req interface{}) *MockGitHTTPComponent_GitUploadPack_Call {
	return &MockGitHTTPComponent_GitUploadPack_Call{Call: _e.mock.On("GitUploadPack", ctx, req)}
}

func (_c *MockGitHTTPComponent_GitUploadPack_Call) Run(run func(ctx context.Context, req types.GitUploadPackReq)) *MockGitHTTPComponent_GitUploadPack_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.GitUploadPackReq))
	})
	return _c
}

func (_c *MockGitHTTPComponent_GitUploadPack_Call) Return(_a0 error) *MockGitHTTPComponent_GitUploadPack_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitHTTPComponent_GitUploadPack_Call) RunAndReturn(run func(context.Context, types.GitUploadPackReq) error) *MockGitHTTPComponent_GitUploadPack_Call {
	_c.Call.Return(run)
	return _c
}

// InfoRefs provides a mock function with given fields: ctx, req
func (_m *MockGitHTTPComponent) InfoRefs(ctx context.Context, req types.InfoRefsReq) (io.Reader, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for InfoRefs")
	}

	var r0 io.Reader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.InfoRefsReq) (io.Reader, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.InfoRefsReq) io.Reader); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Reader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.InfoRefsReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitHTTPComponent_InfoRefs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InfoRefs'
type MockGitHTTPComponent_InfoRefs_Call struct {
	*mock.Call
}

// InfoRefs is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.InfoRefsReq
func (_e *MockGitHTTPComponent_Expecter) InfoRefs(ctx interface{}, req interface{}) *MockGitHTTPComponent_InfoRefs_Call {
	return &MockGitHTTPComponent_InfoRefs_Call{Call: _e.mock.On("InfoRefs", ctx, req)}
}

func (_c *MockGitHTTPComponent_InfoRefs_Call) Run(run func(ctx context.Context, req types.InfoRefsReq)) *MockGitHTTPComponent_InfoRefs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.InfoRefsReq))
	})
	return _c
}

func (_c *MockGitHTTPComponent_InfoRefs_Call) Return(_a0 io.Reader, _a1 error) *MockGitHTTPComponent_InfoRefs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitHTTPComponent_InfoRefs_Call) RunAndReturn(run func(context.Context, types.InfoRefsReq) (io.Reader, error)) *MockGitHTTPComponent_InfoRefs_Call {
	_c.Call.Return(run)
	return _c
}

// LFSBatch provides a mock function with given fields: ctx, req
func (_m *MockGitHTTPComponent) LFSBatch(ctx context.Context, req types.BatchRequest) (*types.BatchResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LFSBatch")
	}

	var r0 *types.BatchResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.BatchRequest) (*types.BatchResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.BatchRequest) *types.BatchResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BatchResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.BatchRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitHTTPComponent_LFSBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LFSBatch'
type MockGitHTTPComponent_LFSBatch_Call struct {
	*mock.Call
}

// LFSBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.BatchRequest
func (_e *MockGitHTTPComponent_Expecter) LFSBatch(ctx interface{}, req interface{}) *MockGitHTTPComponent_LFSBatch_Call {
	return &MockGitHTTPComponent_LFSBatch_Call{Call: _e.mock.On("LFSBatch", ctx, req)}
}

func (_c *MockGitHTTPComponent_LFSBatch_Call) Run(run func(ctx context.Context, req types.BatchRequest)) *MockGitHTTPComponent_LFSBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.BatchRequest))
	})
	return _c
}

func (_c *MockGitHTTPComponent_LFSBatch_Call) Return(_a0 *types.BatchResponse, _a1 error) *MockGitHTTPComponent_LFSBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitHTTPComponent_LFSBatch_Call) RunAndReturn(run func(context.Context, types.BatchRequest) (*types.BatchResponse, error)) *MockGitHTTPComponent_LFSBatch_Call {
	_c.Call.Return(run)
	return _c
}

// LfsDownload provides a mock function with given fields: ctx, req
func (_m *MockGitHTTPComponent) LfsDownload(ctx context.Context, req types.DownloadRequest) (*url.URL, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LfsDownload")
	}

	var r0 *url.URL
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.DownloadRequest) (*url.URL, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.DownloadRequest) *url.URL); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*url.URL)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.DownloadRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitHTTPComponent_LfsDownload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LfsDownload'
type MockGitHTTPComponent_LfsDownload_Call struct {
	*mock.Call
}

// LfsDownload is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.DownloadRequest
func (_e *MockGitHTTPComponent_Expecter) LfsDownload(ctx interface{}, req interface{}) *MockGitHTTPComponent_LfsDownload_Call {
	return &MockGitHTTPComponent_LfsDownload_Call{Call: _e.mock.On("LfsDownload", ctx, req)}
}

func (_c *MockGitHTTPComponent_LfsDownload_Call) Run(run func(ctx context.Context, req types.DownloadRequest)) *MockGitHTTPComponent_LfsDownload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.DownloadRequest))
	})
	return _c
}

func (_c *MockGitHTTPComponent_LfsDownload_Call) Return(_a0 *url.URL, _a1 error) *MockGitHTTPComponent_LfsDownload_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitHTTPComponent_LfsDownload_Call) RunAndReturn(run func(context.Context, types.DownloadRequest) (*url.URL, error)) *MockGitHTTPComponent_LfsDownload_Call {
	_c.Call.Return(run)
	return _c
}

// LfsUpload provides a mock function with given fields: ctx, body, req
func (_m *MockGitHTTPComponent) LfsUpload(ctx context.Context, body io.ReadCloser, req types.UploadRequest) error {
	ret := _m.Called(ctx, body, req)

	if len(ret) == 0 {
		panic("no return value specified for LfsUpload")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, io.ReadCloser, types.UploadRequest) error); ok {
		r0 = rf(ctx, body, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitHTTPComponent_LfsUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LfsUpload'
type MockGitHTTPComponent_LfsUpload_Call struct {
	*mock.Call
}

// LfsUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - body io.ReadCloser
//   - req types.UploadRequest
func (_e *MockGitHTTPComponent_Expecter) LfsUpload(ctx interface{}, body interface{}, req interface{}) *MockGitHTTPComponent_LfsUpload_Call {
	return &MockGitHTTPComponent_LfsUpload_Call{Call: _e.mock.On("LfsUpload", ctx, body, req)}
}

func (_c *MockGitHTTPComponent_LfsUpload_Call) Run(run func(ctx context.Context, body io.ReadCloser, req types.UploadRequest)) *MockGitHTTPComponent_LfsUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(io.ReadCloser), args[2].(types.UploadRequest))
	})
	return _c
}

func (_c *MockGitHTTPComponent_LfsUpload_Call) Return(_a0 error) *MockGitHTTPComponent_LfsUpload_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitHTTPComponent_LfsUpload_Call) RunAndReturn(run func(context.Context, io.ReadCloser, types.UploadRequest) error) *MockGitHTTPComponent_LfsUpload_Call {
	_c.Call.Return(run)
	return _c
}

// LfsVerify provides a mock function with given fields: ctx, req, p
func (_m *MockGitHTTPComponent) LfsVerify(ctx context.Context, req types.VerifyRequest, p types.Pointer) error {
	ret := _m.Called(ctx, req, p)

	if len(ret) == 0 {
		panic("no return value specified for LfsVerify")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.VerifyRequest, types.Pointer) error); ok {
		r0 = rf(ctx, req, p)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitHTTPComponent_LfsVerify_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LfsVerify'
type MockGitHTTPComponent_LfsVerify_Call struct {
	*mock.Call
}

// LfsVerify is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.VerifyRequest
//   - p types.Pointer
func (_e *MockGitHTTPComponent_Expecter) LfsVerify(ctx interface{}, req interface{}, p interface{}) *MockGitHTTPComponent_LfsVerify_Call {
	return &MockGitHTTPComponent_LfsVerify_Call{Call: _e.mock.On("LfsVerify", ctx, req, p)}
}

func (_c *MockGitHTTPComponent_LfsVerify_Call) Run(run func(ctx context.Context, req types.VerifyRequest, p types.Pointer)) *MockGitHTTPComponent_LfsVerify_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.VerifyRequest), args[2].(types.Pointer))
	})
	return _c
}

func (_c *MockGitHTTPComponent_LfsVerify_Call) Return(_a0 error) *MockGitHTTPComponent_LfsVerify_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitHTTPComponent_LfsVerify_Call) RunAndReturn(run func(context.Context, types.VerifyRequest, types.Pointer) error) *MockGitHTTPComponent_LfsVerify_Call {
	_c.Call.Return(run)
	return _c
}

// ListLocks provides a mock function with given fields: ctx, req
func (_m *MockGitHTTPComponent) ListLocks(ctx context.Context, req types.ListLFSLockReq) (*types.LFSLockList, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ListLocks")
	}

	var r0 *types.LFSLockList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.ListLFSLockReq) (*types.LFSLockList, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.ListLFSLockReq) *types.LFSLockList); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.LFSLockList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.ListLFSLockReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitHTTPComponent_ListLocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListLocks'
type MockGitHTTPComponent_ListLocks_Call struct {
	*mock.Call
}

// ListLocks is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.ListLFSLockReq
func (_e *MockGitHTTPComponent_Expecter) ListLocks(ctx interface{}, req interface{}) *MockGitHTTPComponent_ListLocks_Call {
	return &MockGitHTTPComponent_ListLocks_Call{Call: _e.mock.On("ListLocks", ctx, req)}
}

func (_c *MockGitHTTPComponent_ListLocks_Call) Run(run func(ctx context.Context, req types.ListLFSLockReq)) *MockGitHTTPComponent_ListLocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.ListLFSLockReq))
	})
	return _c
}

func (_c *MockGitHTTPComponent_ListLocks_Call) Return(_a0 *types.LFSLockList, _a1 error) *MockGitHTTPComponent_ListLocks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitHTTPComponent_ListLocks_Call) RunAndReturn(run func(context.Context, types.ListLFSLockReq) (*types.LFSLockList, error)) *MockGitHTTPComponent_ListLocks_Call {
	_c.Call.Return(run)
	return _c
}

// UnLock provides a mock function with given fields: ctx, req
func (_m *MockGitHTTPComponent) UnLock(ctx context.Context, req types.UnlockLFSReq) (*database.LfsLock, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for UnLock")
	}

	var r0 *database.LfsLock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.UnlockLFSReq) (*database.LfsLock, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.UnlockLFSReq) *database.LfsLock); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.LfsLock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.UnlockLFSReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitHTTPComponent_UnLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnLock'
type MockGitHTTPComponent_UnLock_Call struct {
	*mock.Call
}

// UnLock is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.UnlockLFSReq
func (_e *MockGitHTTPComponent_Expecter) UnLock(ctx interface{}, req interface{}) *MockGitHTTPComponent_UnLock_Call {
	return &MockGitHTTPComponent_UnLock_Call{Call: _e.mock.On("UnLock", ctx, req)}
}

func (_c *MockGitHTTPComponent_UnLock_Call) Run(run func(ctx context.Context, req types.UnlockLFSReq)) *MockGitHTTPComponent_UnLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.UnlockLFSReq))
	})
	return _c
}

func (_c *MockGitHTTPComponent_UnLock_Call) Return(_a0 *database.LfsLock, _a1 error) *MockGitHTTPComponent_UnLock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitHTTPComponent_UnLock_Call) RunAndReturn(run func(context.Context, types.UnlockLFSReq) (*database.LfsLock, error)) *MockGitHTTPComponent_UnLock_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyLock provides a mock function with given fields: ctx, req
func (_m *MockGitHTTPComponent) VerifyLock(ctx context.Context, req types.VerifyLFSLockReq) (*types.LFSLockListVerify, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for VerifyLock")
	}

	var r0 *types.LFSLockListVerify
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.VerifyLFSLockReq) (*types.LFSLockListVerify, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.VerifyLFSLockReq) *types.LFSLockListVerify); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.LFSLockListVerify)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.VerifyLFSLockReq) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitHTTPComponent_VerifyLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyLock'
type MockGitHTTPComponent_VerifyLock_Call struct {
	*mock.Call
}

// VerifyLock is a helper method to define mock.On call
//   - ctx context.Context
//   - req types.VerifyLFSLockReq
func (_e *MockGitHTTPComponent_Expecter) VerifyLock(ctx interface{}, req interface{}) *MockGitHTTPComponent_VerifyLock_Call {
	return &MockGitHTTPComponent_VerifyLock_Call{Call: _e.mock.On("VerifyLock", ctx, req)}
}

func (_c *MockGitHTTPComponent_VerifyLock_Call) Run(run func(ctx context.Context, req types.VerifyLFSLockReq)) *MockGitHTTPComponent_VerifyLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.VerifyLFSLockReq))
	})
	return _c
}

func (_c *MockGitHTTPComponent_VerifyLock_Call) Return(_a0 *types.LFSLockListVerify, _a1 error) *MockGitHTTPComponent_VerifyLock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitHTTPComponent_VerifyLock_Call) RunAndReturn(run func(context.Context, types.VerifyLFSLockReq) (*types.LFSLockListVerify, error)) *MockGitHTTPComponent_VerifyLock_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGitHTTPComponent creates a new instance of MockGitHTTPComponent. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGitHTTPComponent(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGitHTTPComponent {
	mock := &MockGitHTTPComponent{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
